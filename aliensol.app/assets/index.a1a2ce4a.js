var I6 = Object.defineProperty,
    C6 = Object.defineProperties;
var B6 = Object.getOwnPropertyDescriptors;
var Ul = Object.getOwnPropertySymbols;
var tm = Object.prototype.hasOwnProperty,
    rm = Object.prototype.propertyIsEnumerable;
var Ph = (t, e, r) => e in t ? I6(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    Ce = (t, e) => {
        for (var r in e || (e = {})) tm.call(e, r) && Ph(t, r, e[r]);
        if (Ul)
            for (var r of Ul(e)) rm.call(e, r) && Ph(t, r, e[r]);
        return t
    },
    xt = (t, e) => C6(t, B6(e));
var Wn = (t, e) => {
    var r = {};
    for (var n in t) tm.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && Ul)
        for (var n of Ul(t)) e.indexOf(n) < 0 && rm.call(t, n) && (r[n] = t[n]);
    return r
};
var nm = (t, e, r) => (Ph(t, typeof e != "symbol" ? e + "" : e, r), r);
const k6 = function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function r(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity), i.referrerpolicy && (s.referrerPolicy = i.referrerpolicy), i.crossorigin === "use-credentials" ? s.credentials = "include" : i.crossorigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
    }

    function n(i) {
        if (i.ep) return;
        i.ep = !0;
        const s = r(i);
        fetch(i.href, s)
    }
};
k6();
var zn = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};

function mp(t) {
    if (t.__esModule) return t;
    var e = Object.defineProperty({}, "__esModule", {
        value: !0
    });
    return Object.keys(t).forEach(function(r) {
        var n = Object.getOwnPropertyDescriptor(t, r);
        Object.defineProperty(e, r, n.get ? n : {
            enumerable: !0,
            get: function() {
                return t[r]
            }
        })
    }), e
}

function N6(t) {
    throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var _e = {
        exports: {}
    },
    Rt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gl = Symbol.for("react.element"),
    T6 = Symbol.for("react.portal"),
    O6 = Symbol.for("react.fragment"),
    R6 = Symbol.for("react.strict_mode"),
    D6 = Symbol.for("react.profiler"),
    P6 = Symbol.for("react.provider"),
    L6 = Symbol.for("react.context"),
    F6 = Symbol.for("react.forward_ref"),
    U6 = Symbol.for("react.suspense"),
    z6 = Symbol.for("react.memo"),
    j6 = Symbol.for("react.lazy"),
    im = Symbol.iterator;

function $6(t) {
    return t === null || typeof t != "object" ? null : (t = im && t[im] || t["@@iterator"], typeof t == "function" ? t : null)
}
var Wg = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    },
    Vg = Object.assign,
    Gg = {};

function za(t, e, r) {
    this.props = t, this.context = e, this.refs = Gg, this.updater = r || Wg
}
za.prototype.isReactComponent = {};
za.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState")
};
za.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
};

function Yg() {}
Yg.prototype = za.prototype;

function vp(t, e, r) {
    this.props = t, this.context = e, this.refs = Gg, this.updater = r || Wg
}
var gp = vp.prototype = new Yg;
gp.constructor = vp;
Vg(gp, za.prototype);
gp.isPureReactComponent = !0;
var sm = Array.isArray,
    Kg = Object.prototype.hasOwnProperty,
    yp = {
        current: null
    },
    Zg = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function Jg(t, e, r) {
    var n, i = {},
        s = null,
        o = null;
    if (e != null)
        for (n in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) Kg.call(e, n) && !Zg.hasOwnProperty(n) && (i[n] = e[n]);
    var a = arguments.length - 2;
    if (a === 1) i.children = r;
    else if (1 < a) {
        for (var c = Array(a), d = 0; d < a; d++) c[d] = arguments[d + 2];
        i.children = c
    }
    if (t && t.defaultProps)
        for (n in a = t.defaultProps, a) i[n] === void 0 && (i[n] = a[n]);
    return {
        $$typeof: gl,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: yp.current
    }
}

function H6(t, e) {
    return {
        $$typeof: gl,
        type: t.type,
        key: e,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}

function wp(t) {
    return typeof t == "object" && t !== null && t.$$typeof === gl
}

function Q6(t) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(r) {
        return e[r]
    })
}
var om = /\/+/g;

function Lh(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? Q6("" + t.key) : e.toString(36)
}

function wf(t, e, r, n, i) {
    var s = typeof t;
    (s === "undefined" || s === "boolean") && (t = null);
    var o = !1;
    if (t === null) o = !0;
    else switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (t.$$typeof) {
                case gl:
                case T6:
                    o = !0
            }
    }
    if (o) return o = t, i = i(o), t = n === "" ? "." + Lh(o, 0) : n, sm(i) ? (r = "", t != null && (r = t.replace(om, "$&/") + "/"), wf(i, e, r, "", function(d) {
        return d
    })) : i != null && (wp(i) && (i = H6(i, r + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(om, "$&/") + "/") + t)), e.push(i)), 1;
    if (o = 0, n = n === "" ? "." : n + ":", sm(t))
        for (var a = 0; a < t.length; a++) {
            s = t[a];
            var c = n + Lh(s, a);
            o += wf(s, e, r, c, i)
        } else if (c = $6(t), typeof c == "function")
            for (t = c.call(t), a = 0; !(s = t.next()).done;) s = s.value, c = n + Lh(s, a++), o += wf(s, e, r, c, i);
        else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}

function zl(t, e, r) {
    if (t == null) return t;
    var n = [],
        i = 0;
    return wf(t, n, "", "", function(s) {
        return e.call(r, s, i++)
    }), n
}

function q6(t) {
    if (t._status === -1) {
        var e = t._result;
        e = e(), e.then(function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 1, t._result = r)
        }, function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 2, t._result = r)
        }), t._status === -1 && (t._status = 0, t._result = e)
    }
    if (t._status === 1) return t._result.default;
    throw t._result
}
var xn = {
        current: null
    },
    xf = {
        transition: null
    },
    W6 = {
        ReactCurrentDispatcher: xn,
        ReactCurrentBatchConfig: xf,
        ReactCurrentOwner: yp
    };
Rt.Children = {
    map: zl,
    forEach: function(t, e, r) {
        zl(t, function() {
            e.apply(this, arguments)
        }, r)
    },
    count: function(t) {
        var e = 0;
        return zl(t, function() {
            e++
        }), e
    },
    toArray: function(t) {
        return zl(t, function(e) {
            return e
        }) || []
    },
    only: function(t) {
        if (!wp(t)) throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
Rt.Component = za;
Rt.Fragment = O6;
Rt.Profiler = D6;
Rt.PureComponent = vp;
Rt.StrictMode = R6;
Rt.Suspense = U6;
Rt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W6;
Rt.cloneElement = function(t, e, r) {
    if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var n = Vg({}, t.props),
        i = t.key,
        s = t.ref,
        o = t._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref, o = yp.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps;
        for (c in e) Kg.call(e, c) && !Zg.hasOwnProperty(c) && (n[c] = e[c] === void 0 && a !== void 0 ? a[c] : e[c])
    }
    var c = arguments.length - 2;
    if (c === 1) n.children = r;
    else if (1 < c) {
        a = Array(c);
        for (var d = 0; d < c; d++) a[d] = arguments[d + 2];
        n.children = a
    }
    return {
        $$typeof: gl,
        type: t.type,
        key: i,
        ref: s,
        props: n,
        _owner: o
    }
};
Rt.createContext = function(t) {
    return t = {
        $$typeof: L6,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    }, t.Provider = {
        $$typeof: P6,
        _context: t
    }, t.Consumer = t
};
Rt.createElement = Jg;
Rt.createFactory = function(t) {
    var e = Jg.bind(null, t);
    return e.type = t, e
};
Rt.createRef = function() {
    return {
        current: null
    }
};
Rt.forwardRef = function(t) {
    return {
        $$typeof: F6,
        render: t
    }
};
Rt.isValidElement = wp;
Rt.lazy = function(t) {
    return {
        $$typeof: j6,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: q6
    }
};
Rt.memo = function(t, e) {
    return {
        $$typeof: z6,
        type: t,
        compare: e === void 0 ? null : e
    }
};
Rt.startTransition = function(t) {
    var e = xf.transition;
    xf.transition = {};
    try {
        t()
    } finally {
        xf.transition = e
    }
};
Rt.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
};
Rt.useCallback = function(t, e) {
    return xn.current.useCallback(t, e)
};
Rt.useContext = function(t) {
    return xn.current.useContext(t)
};
Rt.useDebugValue = function() {};
Rt.useDeferredValue = function(t) {
    return xn.current.useDeferredValue(t)
};
Rt.useEffect = function(t, e) {
    return xn.current.useEffect(t, e)
};
Rt.useId = function() {
    return xn.current.useId()
};
Rt.useImperativeHandle = function(t, e, r) {
    return xn.current.useImperativeHandle(t, e, r)
};
Rt.useInsertionEffect = function(t, e) {
    return xn.current.useInsertionEffect(t, e)
};
Rt.useLayoutEffect = function(t, e) {
    return xn.current.useLayoutEffect(t, e)
};
Rt.useMemo = function(t, e) {
    return xn.current.useMemo(t, e)
};
Rt.useReducer = function(t, e, r) {
    return xn.current.useReducer(t, e, r)
};
Rt.useRef = function(t) {
    return xn.current.useRef(t)
};
Rt.useState = function(t) {
    return xn.current.useState(t)
};
Rt.useSyncExternalStore = function(t, e, r) {
    return xn.current.useSyncExternalStore(t, e, r)
};
Rt.useTransition = function() {
    return xn.current.useTransition()
};
Rt.version = "18.1.0";
_e.exports = Rt;
var Qe = _e.exports,
    V0 = {},
    Tc = {
        exports: {}
    },
    $n = {},
    Xg = {
        exports: {}
    },
    ey = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(_, M) {
        var m = _.length;
        _.push(M);
        e: for (; 0 < m;) {
            var A = m - 1 >>> 1,
                x = _[A];
            if (0 < i(x, M)) _[A] = M, _[m] = x, m = A;
            else break e
        }
    }

    function r(_) {
        return _.length === 0 ? null : _[0]
    }

    function n(_) {
        if (_.length === 0) return null;
        var M = _[0],
            m = _.pop();
        if (m !== M) {
            _[0] = m;
            e: for (var A = 0, x = _.length, z = x >>> 1; A < z;) {
                var oe = 2 * (A + 1) - 1,
                    k = _[oe],
                    X = oe + 1,
                    re = _[X];
                if (0 > i(k, m)) X < x && 0 > i(re, k) ? (_[A] = re, _[X] = m, A = X) : (_[A] = k, _[oe] = m, A = oe);
                else if (X < x && 0 > i(re, m)) _[A] = re, _[X] = m, A = X;
                else break e
            }
        }
        return M
    }

    function i(_, M) {
        var m = _.sortIndex - M.sortIndex;
        return m !== 0 ? m : _.id - M.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        t.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date,
            a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var c = [],
        d = [],
        y = 1,
        I = null,
        N = 3,
        E = !1,
        T = !1,
        j = !1,
        V = typeof setTimeout == "function" ? setTimeout : null,
        P = typeof clearTimeout == "function" ? clearTimeout : null,
        O = typeof setImmediate != "undefined" ? setImmediate : null;
    typeof navigator != "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function R(_) {
        for (var M = r(d); M !== null;) {
            if (M.callback === null) n(d);
            else if (M.startTime <= _) n(d), M.sortIndex = M.expirationTime, e(c, M);
            else break;
            M = r(d)
        }
    }

    function q(_) {
        if (j = !1, R(_), !T)
            if (r(c) !== null) T = !0, b(W);
            else {
                var M = r(d);
                M !== null && C(q, M.startTime - _)
            }
    }

    function W(_, M) {
        T = !1, j && (j = !1, P(J), J = -1), E = !0;
        var m = N;
        try {
            for (R(M), I = r(c); I !== null && (!(I.expirationTime > M) || _ && !H());) {
                var A = I.callback;
                if (typeof A == "function") {
                    I.callback = null, N = I.priorityLevel;
                    var x = A(I.expirationTime <= M);
                    M = t.unstable_now(), typeof x == "function" ? I.callback = x : I === r(c) && n(c), R(M)
                } else n(c);
                I = r(c)
            }
            if (I !== null) var z = !0;
            else {
                var oe = r(d);
                oe !== null && C(q, oe.startTime - M), z = !1
            }
            return z
        } finally {
            I = null, N = m, E = !1
        }
    }
    var Y = !1,
        G = null,
        J = -1,
        pe = 5,
        we = -1;

    function H() {
        return !(t.unstable_now() - we < pe)
    }

    function w() {
        if (G !== null) {
            var _ = t.unstable_now();
            we = _;
            var M = !0;
            try {
                M = G(!0, _)
            } finally {
                M ? p() : (Y = !1, G = null)
            }
        } else Y = !1
    }
    var p;
    if (typeof O == "function") p = function() {
        O(w)
    };
    else if (typeof MessageChannel != "undefined") {
        var f = new MessageChannel,
            h = f.port2;
        f.port1.onmessage = w, p = function() {
            h.postMessage(null)
        }
    } else p = function() {
        V(w, 0)
    };

    function b(_) {
        G = _, Y || (Y = !0, p())
    }

    function C(_, M) {
        J = V(function() {
            _(t.unstable_now())
        }, M)
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(_) {
        _.callback = null
    }, t.unstable_continueExecution = function() {
        T || E || (T = !0, b(W))
    }, t.unstable_forceFrameRate = function(_) {
        0 > _ || 125 < _ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : pe = 0 < _ ? Math.floor(1e3 / _) : 5
    }, t.unstable_getCurrentPriorityLevel = function() {
        return N
    }, t.unstable_getFirstCallbackNode = function() {
        return r(c)
    }, t.unstable_next = function(_) {
        switch (N) {
            case 1:
            case 2:
            case 3:
                var M = 3;
                break;
            default:
                M = N
        }
        var m = N;
        N = M;
        try {
            return _()
        } finally {
            N = m
        }
    }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(_, M) {
        switch (_) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                _ = 3
        }
        var m = N;
        N = _;
        try {
            return M()
        } finally {
            N = m
        }
    }, t.unstable_scheduleCallback = function(_, M, m) {
        var A = t.unstable_now();
        switch (typeof m == "object" && m !== null ? (m = m.delay, m = typeof m == "number" && 0 < m ? A + m : A) : m = A, _) {
            case 1:
                var x = -1;
                break;
            case 2:
                x = 250;
                break;
            case 5:
                x = 1073741823;
                break;
            case 4:
                x = 1e4;
                break;
            default:
                x = 5e3
        }
        return x = m + x, _ = {
            id: y++,
            callback: M,
            priorityLevel: _,
            startTime: m,
            expirationTime: x,
            sortIndex: -1
        }, m > A ? (_.sortIndex = m, e(d, _), r(c) === null && _ === r(d) && (j ? (P(J), J = -1) : j = !0, C(q, m - A))) : (_.sortIndex = x, e(c, _), T || E || (T = !0, b(W))), _
    }, t.unstable_shouldYield = H, t.unstable_wrapCallback = function(_) {
        var M = N;
        return function() {
            var m = N;
            N = M;
            try {
                return _.apply(this, arguments)
            } finally {
                N = m
            }
        }
    }
})(ey);
Xg.exports = ey;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ty = _e.exports,
    jn = Xg.exports;

function be(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, r = 1; r < arguments.length; r++) e += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var ry = new Set,
    Zu = {};

function Ro(t, e) {
    wa(t, e), wa(t + "Capture", e)
}

function wa(t, e) {
    for (Zu[t] = e, t = 0; t < e.length; t++) ry.add(e[t])
}
var ps = !(typeof window == "undefined" || typeof window.document == "undefined" || typeof window.document.createElement == "undefined"),
    G0 = Object.prototype.hasOwnProperty,
    V6 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    am = {},
    um = {};

function G6(t) {
    return G0.call(um, t) ? !0 : G0.call(am, t) ? !1 : V6.test(t) ? um[t] = !0 : (am[t] = !0, !1)
}

function Y6(t, e, r, n) {
    if (r !== null && r.type === 0) return !1;
    switch (typeof e) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return n ? !1 : r !== null ? !r.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
        default:
            return !1
    }
}

function K6(t, e, r, n) {
    if (e === null || typeof e == "undefined" || Y6(t, e, r, n)) return !0;
    if (n) return !1;
    if (r !== null) switch (r.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
    }
    return !1
}

function bn(t, e, r, n, i, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = n, this.attributeNamespace = i, this.mustUseProperty = r, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o
}
var Jr = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    Jr[t] = new bn(t, 0, !1, t, null, !1, !1)
});
[
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
].forEach(function(t) {
    var e = t[0];
    Jr[e] = new bn(e, 1, !1, t[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    Jr[t] = new bn(t, 2, !1, t.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    Jr[t] = new bn(t, 2, !1, t, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    Jr[t] = new bn(t, 3, !1, t.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    Jr[t] = new bn(t, 3, !0, t, null, !1, !1)
});
["capture", "download"].forEach(function(t) {
    Jr[t] = new bn(t, 4, !1, t, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    Jr[t] = new bn(t, 6, !1, t, null, !1, !1)
});
["rowSpan", "start"].forEach(function(t) {
    Jr[t] = new bn(t, 5, !1, t.toLowerCase(), null, !1, !1)
});
var xp = /[\-:]([a-z])/g;

function bp(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(xp, bp);
    Jr[e] = new bn(e, 1, !1, t, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(xp, bp);
    Jr[e] = new bn(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var e = t.replace(xp, bp);
    Jr[e] = new bn(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    Jr[t] = new bn(t, 1, !1, t.toLowerCase(), null, !1, !1)
});
Jr.xlinkHref = new bn("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(t) {
    Jr[t] = new bn(t, 1, !1, t.toLowerCase(), null, !0, !0)
});

function Ap(t, e, r, n) {
    var i = Jr.hasOwnProperty(e) ? Jr[e] : null;
    (i !== null ? i.type !== 0 : n || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (K6(e, r, i, n) && (r = null), n || i === null ? G6(e) && (r === null ? t.removeAttribute(e) : t.setAttribute(e, "" + r)) : i.mustUseProperty ? t[i.propertyName] = r === null ? i.type === 3 ? !1 : "" : r : (e = i.attributeName, n = i.attributeNamespace, r === null ? t.removeAttribute(e) : (i = i.type, r = i === 3 || i === 4 && r === !0 ? "" : "" + r, n ? t.setAttributeNS(n, e, r) : t.setAttribute(e, r))))
}
var Ss = ty.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    jl = Symbol.for("react.element"),
    Ko = Symbol.for("react.portal"),
    Zo = Symbol.for("react.fragment"),
    Sp = Symbol.for("react.strict_mode"),
    Y0 = Symbol.for("react.profiler"),
    ny = Symbol.for("react.provider"),
    iy = Symbol.for("react.context"),
    Mp = Symbol.for("react.forward_ref"),
    K0 = Symbol.for("react.suspense"),
    Z0 = Symbol.for("react.suspense_list"),
    Ep = Symbol.for("react.memo"),
    Bs = Symbol.for("react.lazy"),
    sy = Symbol.for("react.offscreen"),
    lm = Symbol.iterator;

function uu(t) {
    return t === null || typeof t != "object" ? null : (t = lm && t[lm] || t["@@iterator"], typeof t == "function" ? t : null)
}
var xr = Object.assign,
    Fh;

function Cu(t) {
    if (Fh === void 0) try {
        throw Error()
    } catch (r) {
        var e = r.stack.trim().match(/\n( *(at )?)/);
        Fh = e && e[1] || ""
    }
    return `
` + Fh + t
}
var Uh = !1;

function zh(t, e) {
    if (!t || Uh) return "";
    Uh = !0;
    var r = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                    throw Error()
                }, Object.defineProperty(e.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (d) {
                    var n = d
                }
                Reflect.construct(t, [], e)
            } else {
                try {
                    e.call()
                } catch (d) {
                    n = d
                }
                t.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (d) {
                n = d
            }
            t()
        }
    } catch (d) {
        if (d && n && typeof d.stack == "string") {
            for (var i = d.stack.split(`
`), s = n.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];) a--;
            for (; 1 <= o && 0 <= a; o--, a--)
                if (i[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--, a--, 0 > a || i[o] !== s[a]) {
                                var c = `
` + i[o].replace(" at new ", " at ");
                                return t.displayName && c.includes("<anonymous>") && (c = c.replace("<anonymous>", t.displayName)), c
                            }
                    while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        Uh = !1, Error.prepareStackTrace = r
    }
    return (t = t ? t.displayName || t.name : "") ? Cu(t) : ""
}

function Z6(t) {
    switch (t.tag) {
        case 5:
            return Cu(t.type);
        case 16:
            return Cu("Lazy");
        case 13:
            return Cu("Suspense");
        case 19:
            return Cu("SuspenseList");
        case 0:
        case 2:
        case 15:
            return t = zh(t.type, !1), t;
        case 11:
            return t = zh(t.type.render, !1), t;
        case 1:
            return t = zh(t.type, !0), t;
        default:
            return ""
    }
}

function J0(t) {
    if (t == null) return null;
    if (typeof t == "function") return t.displayName || t.name || null;
    if (typeof t == "string") return t;
    switch (t) {
        case Zo:
            return "Fragment";
        case Ko:
            return "Portal";
        case Y0:
            return "Profiler";
        case Sp:
            return "StrictMode";
        case K0:
            return "Suspense";
        case Z0:
            return "SuspenseList"
    }
    if (typeof t == "object") switch (t.$$typeof) {
        case iy:
            return (t.displayName || "Context") + ".Consumer";
        case ny:
            return (t._context.displayName || "Context") + ".Provider";
        case Mp:
            var e = t.render;
            return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
        case Ep:
            return e = t.displayName || null, e !== null ? e : J0(t.type) || "Memo";
        case Bs:
            e = t._payload, t = t._init;
            try {
                return J0(t(e))
            } catch {}
    }
    return null
}

function J6(t) {
    var e = t.type;
    switch (t.tag) {
        case 24:
            return "Cache";
        case 9:
            return (e.displayName || "Context") + ".Consumer";
        case 10:
            return (e._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return e;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return J0(e);
        case 8:
            return e === Sp ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof e == "function") return e.displayName || e.name || null;
            if (typeof e == "string") return e
    }
    return null
}

function Xs(t) {
    switch (typeof t) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return t;
        case "object":
            return t;
        default:
            return ""
    }
}

function oy(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}

function X6(t) {
    var e = oy(t) ? "checked" : "value",
        r = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
        n = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof r != "undefined" && typeof r.get == "function" && typeof r.set == "function") {
        var i = r.get,
            s = r.set;
        return Object.defineProperty(t, e, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(o) {
                n = "" + o, s.call(this, o)
            }
        }), Object.defineProperty(t, e, {
            enumerable: r.enumerable
        }), {
            getValue: function() {
                return n
            },
            setValue: function(o) {
                n = "" + o
            },
            stopTracking: function() {
                t._valueTracker = null, delete t[e]
            }
        }
    }
}

function $l(t) {
    t._valueTracker || (t._valueTracker = X6(t))
}

function ay(t) {
    if (!t) return !1;
    var e = t._valueTracker;
    if (!e) return !0;
    var r = e.getValue(),
        n = "";
    return t && (n = oy(t) ? t.checked ? "true" : "false" : t.value), t = n, t !== r ? (e.setValue(t), !0) : !1
}

function $f(t) {
    if (t = t || (typeof document != "undefined" ? document : void 0), typeof t == "undefined") return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}

function X0(t, e) {
    var r = e.checked;
    return xr({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: r != null ? r : t._wrapperState.initialChecked
    })
}

function fm(t, e) {
    var r = e.defaultValue == null ? "" : e.defaultValue,
        n = e.checked != null ? e.checked : e.defaultChecked;
    r = Xs(e.value != null ? e.value : r), t._wrapperState = {
        initialChecked: n,
        initialValue: r,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}

function uy(t, e) {
    e = e.checked, e != null && Ap(t, "checked", e, !1)
}

function ed(t, e) {
    uy(t, e);
    var r = Xs(e.value),
        n = e.type;
    if (r != null) n === "number" ? (r === 0 && t.value === "" || t.value != r) && (t.value = "" + r) : t.value !== "" + r && (t.value = "" + r);
    else if (n === "submit" || n === "reset") {
        t.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? td(t, e.type, r) : e.hasOwnProperty("defaultValue") && td(t, e.type, Xs(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}

function cm(t, e, r) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var n = e.type;
        if (!(n !== "submit" && n !== "reset" || e.value !== void 0 && e.value !== null)) return;
        e = "" + t._wrapperState.initialValue, r || e === t.value || (t.value = e), t.defaultValue = e
    }
    r = t.name, r !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, r !== "" && (t.name = r)
}

function td(t, e, r) {
    (e !== "number" || $f(t.ownerDocument) !== t) && (r == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + r && (t.defaultValue = "" + r))
}
var Bu = Array.isArray;

function fa(t, e, r, n) {
    if (t = t.options, e) {
        e = {};
        for (var i = 0; i < r.length; i++) e["$" + r[i]] = !0;
        for (r = 0; r < t.length; r++) i = e.hasOwnProperty("$" + t[r].value), t[r].selected !== i && (t[r].selected = i), i && n && (t[r].defaultSelected = !0)
    } else {
        for (r = "" + Xs(r), e = null, i = 0; i < t.length; i++) {
            if (t[i].value === r) {
                t[i].selected = !0, n && (t[i].defaultSelected = !0);
                return
            }
            e !== null || t[i].disabled || (e = t[i])
        }
        e !== null && (e.selected = !0)
    }
}

function rd(t, e) {
    if (e.dangerouslySetInnerHTML != null) throw Error(be(91));
    return xr({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}

function hm(t, e) {
    var r = e.value;
    if (r == null) {
        if (r = e.children, e = e.defaultValue, r != null) {
            if (e != null) throw Error(be(92));
            if (Bu(r)) {
                if (1 < r.length) throw Error(be(93));
                r = r[0]
            }
            e = r
        }
        e == null && (e = ""), r = e
    }
    t._wrapperState = {
        initialValue: Xs(r)
    }
}

function ly(t, e) {
    var r = Xs(e.value),
        n = Xs(e.defaultValue);
    r != null && (r = "" + r, r !== t.value && (t.value = r), e.defaultValue == null && t.defaultValue !== r && (t.defaultValue = r)), n != null && (t.defaultValue = "" + n)
}

function dm(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}

function fy(t) {
    switch (t) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function nd(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? fy(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var Hl, cy = function(t) {
    return typeof MSApp != "undefined" && MSApp.execUnsafeLocalFunction ? function(e, r, n, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(e, r, n, i)
        })
    } : t
}(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e;
    else {
        for (Hl = Hl || document.createElement("div"), Hl.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Hl.firstChild; t.firstChild;) t.removeChild(t.firstChild);
        for (; e.firstChild;) t.appendChild(e.firstChild)
    }
});

function Ju(t, e) {
    if (e) {
        var r = t.firstChild;
        if (r && r === t.lastChild && r.nodeType === 3) {
            r.nodeValue = e;
            return
        }
    }
    t.textContent = e
}
var Fu = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    e4 = ["Webkit", "ms", "Moz", "O"];
Object.keys(Fu).forEach(function(t) {
    e4.forEach(function(e) {
        e = e + t.charAt(0).toUpperCase() + t.substring(1), Fu[e] = Fu[t]
    })
});

function hy(t, e, r) {
    return e == null || typeof e == "boolean" || e === "" ? "" : r || typeof e != "number" || e === 0 || Fu.hasOwnProperty(t) && Fu[t] ? ("" + e).trim() : e + "px"
}

function dy(t, e) {
    t = t.style;
    for (var r in e)
        if (e.hasOwnProperty(r)) {
            var n = r.indexOf("--") === 0,
                i = hy(r, e[r], n);
            r === "float" && (r = "cssFloat"), n ? t.setProperty(r, i) : t[r] = i
        }
}
var t4 = xr({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function id(t, e) {
    if (e) {
        if (t4[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(be(137, t));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null) throw Error(be(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(be(61))
        }
        if (e.style != null && typeof e.style != "object") throw Error(be(62))
    }
}

function sd(t, e) {
    if (t.indexOf("-") === -1) return typeof e.is == "string";
    switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}
var od = null;

function _p(t) {
    return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t
}
var ad = null,
    ca = null,
    ha = null;

function pm(t) {
    if (t = xl(t)) {
        if (typeof ad != "function") throw Error(be(280));
        var e = t.stateNode;
        e && (e = Lc(e), ad(t.stateNode, t.type, e))
    }
}

function py(t) {
    ca ? ha ? ha.push(t) : ha = [t] : ca = t
}

function my() {
    if (ca) {
        var t = ca,
            e = ha;
        if (ha = ca = null, pm(t), e)
            for (t = 0; t < e.length; t++) pm(e[t])
    }
}

function vy(t, e) {
    return t(e)
}

function gy() {}
var jh = !1;

function yy(t, e, r) {
    if (jh) return t(e, r);
    jh = !0;
    try {
        return vy(t, e, r)
    } finally {
        jh = !1, (ca !== null || ha !== null) && (gy(), my())
    }
}

function Xu(t, e) {
    var r = t.stateNode;
    if (r === null) return null;
    var n = Lc(r);
    if (n === null) return null;
    r = n[e];
    e: switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (n = !n.disabled) || (t = t.type, n = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !n;
            break e;
        default:
            t = !1
    }
    if (t) return null;
    if (r && typeof r != "function") throw Error(be(231, e, typeof r));
    return r
}
var ud = !1;
if (ps) try {
    var lu = {};
    Object.defineProperty(lu, "passive", {
        get: function() {
            ud = !0
        }
    }), window.addEventListener("test", lu, lu), window.removeEventListener("test", lu, lu)
} catch {
    ud = !1
}

function r4(t, e, r, n, i, s, o, a, c) {
    var d = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(r, d)
    } catch (y) {
        this.onError(y)
    }
}
var Uu = !1,
    Hf = null,
    Qf = !1,
    ld = null,
    n4 = {
        onError: function(t) {
            Uu = !0, Hf = t
        }
    };

function i4(t, e, r, n, i, s, o, a, c) {
    Uu = !1, Hf = null, r4.apply(n4, arguments)
}

function s4(t, e, r, n, i, s, o, a, c) {
    if (i4.apply(this, arguments), Uu) {
        if (Uu) {
            var d = Hf;
            Uu = !1, Hf = null
        } else throw Error(be(198));
        Qf || (Qf = !0, ld = d)
    }
}

function Do(t) {
    var e = t,
        r = t;
    if (t.alternate)
        for (; e.return;) e = e.return;
    else {
        t = e;
        do e = t, (e.flags & 4098) !== 0 && (r = e.return), t = e.return; while (t)
    }
    return e.tag === 3 ? r : null
}

function wy(t) {
    if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated
    }
    return null
}

function mm(t) {
    if (Do(t) !== t) throw Error(be(188))
}

function o4(t) {
    var e = t.alternate;
    if (!e) {
        if (e = Do(t), e === null) throw Error(be(188));
        return e !== t ? null : t
    }
    for (var r = t, n = e;;) {
        var i = r.return;
        if (i === null) break;
        var s = i.alternate;
        if (s === null) {
            if (n = i.return, n !== null) {
                r = n;
                continue
            }
            break
        }
        if (i.child === s.child) {
            for (s = i.child; s;) {
                if (s === r) return mm(i), t;
                if (s === n) return mm(i), e;
                s = s.sibling
            }
            throw Error(be(188))
        }
        if (r.return !== n.return) r = i, n = s;
        else {
            for (var o = !1, a = i.child; a;) {
                if (a === r) {
                    o = !0, r = i, n = s;
                    break
                }
                if (a === n) {
                    o = !0, n = i, r = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a;) {
                    if (a === r) {
                        o = !0, r = s, n = i;
                        break
                    }
                    if (a === n) {
                        o = !0, n = s, r = i;
                        break
                    }
                    a = a.sibling
                }
                if (!o) throw Error(be(189))
            }
        }
        if (r.alternate !== n) throw Error(be(190))
    }
    if (r.tag !== 3) throw Error(be(188));
    return r.stateNode.current === r ? t : e
}

function xy(t) {
    return t = o4(t), t !== null ? by(t) : null
}

function by(t) {
    if (t.tag === 5 || t.tag === 6) return t;
    for (t = t.child; t !== null;) {
        var e = by(t);
        if (e !== null) return e;
        t = t.sibling
    }
    return null
}
var Ay = jn.unstable_scheduleCallback,
    vm = jn.unstable_cancelCallback,
    a4 = jn.unstable_shouldYield,
    u4 = jn.unstable_requestPaint,
    Cr = jn.unstable_now,
    l4 = jn.unstable_getCurrentPriorityLevel,
    Ip = jn.unstable_ImmediatePriority,
    Sy = jn.unstable_UserBlockingPriority,
    qf = jn.unstable_NormalPriority,
    f4 = jn.unstable_LowPriority,
    My = jn.unstable_IdlePriority,
    Oc = null,
    Li = null;

function c4(t) {
    if (Li && typeof Li.onCommitFiberRoot == "function") try {
        Li.onCommitFiberRoot(Oc, t, void 0, (t.current.flags & 128) === 128)
    } catch {}
}
var Mi = Math.clz32 ? Math.clz32 : p4,
    h4 = Math.log,
    d4 = Math.LN2;

function p4(t) {
    return t >>>= 0, t === 0 ? 32 : 31 - (h4(t) / d4 | 0) | 0
}
var Ql = 64,
    ql = 4194304;

function ku(t) {
    switch (t & -t) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return t & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return t & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return t
    }
}

function Wf(t, e) {
    var r = t.pendingLanes;
    if (r === 0) return 0;
    var n = 0,
        i = t.suspendedLanes,
        s = t.pingedLanes,
        o = r & 268435455;
    if (o !== 0) {
        var a = o & ~i;
        a !== 0 ? n = ku(a) : (s &= o, s !== 0 && (n = ku(s)))
    } else o = r & ~i, o !== 0 ? n = ku(o) : s !== 0 && (n = ku(s));
    if (n === 0) return 0;
    if (e !== 0 && e !== n && (e & i) === 0 && (i = n & -n, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e;
    if ((n & 4) !== 0 && (n |= r & 16), e = t.entangledLanes, e !== 0)
        for (t = t.entanglements, e &= n; 0 < e;) r = 31 - Mi(e), i = 1 << r, n |= t[r], e &= ~i;
    return n
}

function m4(t, e) {
    switch (t) {
        case 1:
        case 2:
        case 4:
            return e + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return e + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}

function v4(t, e) {
    for (var r = t.suspendedLanes, n = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s;) {
        var o = 31 - Mi(s),
            a = 1 << o,
            c = i[o];
        c === -1 ? ((a & r) === 0 || (a & n) !== 0) && (i[o] = m4(a, e)) : c <= e && (t.expiredLanes |= a), s &= ~a
    }
}

function fd(t) {
    return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}

function Ey() {
    var t = Ql;
    return Ql <<= 1, (Ql & 4194240) === 0 && (Ql = 64), t
}

function $h(t) {
    for (var e = [], r = 0; 31 > r; r++) e.push(t);
    return e
}

function yl(t, e, r) {
    t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - Mi(e), t[e] = r
}

function g4(t, e) {
    var r = t.pendingLanes & ~e;
    t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
    var n = t.eventTimes;
    for (t = t.expirationTimes; 0 < r;) {
        var i = 31 - Mi(r),
            s = 1 << i;
        e[i] = 0, n[i] = -1, t[i] = -1, r &= ~s
    }
}

function Cp(t, e) {
    var r = t.entangledLanes |= e;
    for (t = t.entanglements; r;) {
        var n = 31 - Mi(r),
            i = 1 << n;
        i & e | t[n] & e && (t[n] |= e), r &= ~i
    }
}
var sr = 0;

function _y(t) {
    return t &= -t, 1 < t ? 4 < t ? (t & 268435455) !== 0 ? 16 : 536870912 : 4 : 1
}
var Iy, Bp, Cy, By, ky, cd = !1,
    Wl = [],
    Ws = null,
    Vs = null,
    Gs = null,
    el = new Map,
    tl = new Map,
    Ds = [],
    y4 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function gm(t, e) {
    switch (t) {
        case "focusin":
        case "focusout":
            Ws = null;
            break;
        case "dragenter":
        case "dragleave":
            Vs = null;
            break;
        case "mouseover":
        case "mouseout":
            Gs = null;
            break;
        case "pointerover":
        case "pointerout":
            el.delete(e.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            tl.delete(e.pointerId)
    }
}

function fu(t, e, r, n, i, s) {
    return t === null || t.nativeEvent !== s ? (t = {
        blockedOn: e,
        domEventName: r,
        eventSystemFlags: n,
        nativeEvent: s,
        targetContainers: [i]
    }, e !== null && (e = xl(e), e !== null && Bp(e)), t) : (t.eventSystemFlags |= n, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t)
}

function w4(t, e, r, n, i) {
    switch (e) {
        case "focusin":
            return Ws = fu(Ws, t, e, r, n, i), !0;
        case "dragenter":
            return Vs = fu(Vs, t, e, r, n, i), !0;
        case "mouseover":
            return Gs = fu(Gs, t, e, r, n, i), !0;
        case "pointerover":
            var s = i.pointerId;
            return el.set(s, fu(el.get(s) || null, t, e, r, n, i)), !0;
        case "gotpointercapture":
            return s = i.pointerId, tl.set(s, fu(tl.get(s) || null, t, e, r, n, i)), !0
    }
    return !1
}

function Ny(t) {
    var e = yo(t.target);
    if (e !== null) {
        var r = Do(e);
        if (r !== null) {
            if (e = r.tag, e === 13) {
                if (e = wy(r), e !== null) {
                    t.blockedOn = e, ky(t.priority, function() {
                        Cy(r)
                    });
                    return
                }
            } else if (e === 3 && r.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}

function bf(t) {
    if (t.blockedOn !== null) return !1;
    for (var e = t.targetContainers; 0 < e.length;) {
        var r = hd(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
        if (r === null) {
            r = t.nativeEvent;
            var n = new r.constructor(r.type, r);
            od = n, r.target.dispatchEvent(n), od = null
        } else return e = xl(r), e !== null && Bp(e), t.blockedOn = r, !1;
        e.shift()
    }
    return !0
}

function ym(t, e, r) {
    bf(t) && r.delete(e)
}

function x4() {
    cd = !1, Ws !== null && bf(Ws) && (Ws = null), Vs !== null && bf(Vs) && (Vs = null), Gs !== null && bf(Gs) && (Gs = null), el.forEach(ym), tl.forEach(ym)
}

function cu(t, e) {
    t.blockedOn === e && (t.blockedOn = null, cd || (cd = !0, jn.unstable_scheduleCallback(jn.unstable_NormalPriority, x4)))
}

function rl(t) {
    function e(i) {
        return cu(i, t)
    }
    if (0 < Wl.length) {
        cu(Wl[0], t);
        for (var r = 1; r < Wl.length; r++) {
            var n = Wl[r];
            n.blockedOn === t && (n.blockedOn = null)
        }
    }
    for (Ws !== null && cu(Ws, t), Vs !== null && cu(Vs, t), Gs !== null && cu(Gs, t), el.forEach(e), tl.forEach(e), r = 0; r < Ds.length; r++) n = Ds[r], n.blockedOn === t && (n.blockedOn = null);
    for (; 0 < Ds.length && (r = Ds[0], r.blockedOn === null);) Ny(r), r.blockedOn === null && Ds.shift()
}
var da = Ss.ReactCurrentBatchConfig,
    Vf = !0;

function b4(t, e, r, n) {
    var i = sr,
        s = da.transition;
    da.transition = null;
    try {
        sr = 1, kp(t, e, r, n)
    } finally {
        sr = i, da.transition = s
    }
}

function A4(t, e, r, n) {
    var i = sr,
        s = da.transition;
    da.transition = null;
    try {
        sr = 4, kp(t, e, r, n)
    } finally {
        sr = i, da.transition = s
    }
}

function kp(t, e, r, n) {
    if (Vf) {
        var i = hd(t, e, r, n);
        if (i === null) Jh(t, e, n, Gf, r), gm(t, n);
        else if (w4(i, t, e, r, n)) n.stopPropagation();
        else if (gm(t, n), e & 4 && -1 < y4.indexOf(t)) {
            for (; i !== null;) {
                var s = xl(i);
                if (s !== null && Iy(s), s = hd(t, e, r, n), s === null && Jh(t, e, n, Gf, r), s === i) break;
                i = s
            }
            i !== null && n.stopPropagation()
        } else Jh(t, e, n, null, r)
    }
}
var Gf = null;

function hd(t, e, r, n) {
    if (Gf = null, t = _p(n), t = yo(t), t !== null)
        if (e = Do(t), e === null) t = null;
        else if (r = e.tag, r === 13) {
        if (t = wy(e), t !== null) return t;
        t = null
    } else if (r === 3) {
        if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
        t = null
    } else e !== t && (t = null);
    return Gf = t, null
}

function Ty(t) {
    switch (t) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (l4()) {
                case Ip:
                    return 1;
                case Sy:
                    return 4;
                case qf:
                case f4:
                    return 16;
                case My:
                    return 536870912;
                default:
                    return 16
            }
        default:
            return 16
    }
}
var Us = null,
    Np = null,
    Af = null;

function Oy() {
    if (Af) return Af;
    var t, e = Np,
        r = e.length,
        n, i = "value" in Us ? Us.value : Us.textContent,
        s = i.length;
    for (t = 0; t < r && e[t] === i[t]; t++);
    var o = r - t;
    for (n = 1; n <= o && e[r - n] === i[s - n]; n++);
    return Af = i.slice(t, 1 < n ? 1 - n : void 0)
}

function Sf(t) {
    var e = t.keyCode;
    return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0
}

function Vl() {
    return !0
}

function wm() {
    return !1
}

function Hn(t) {
    function e(r, n, i, s, o) {
        this._reactName = r, this._targetInst = i, this.type = n, this.nativeEvent = s, this.target = o, this.currentTarget = null;
        for (var a in t) t.hasOwnProperty(a) && (r = t[a], this[a] = r ? r(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Vl : wm, this.isPropagationStopped = wm, this
    }
    return xr(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var r = this.nativeEvent;
            r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1), this.isDefaultPrevented = Vl)
        },
        stopPropagation: function() {
            var r = this.nativeEvent;
            r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0), this.isPropagationStopped = Vl)
        },
        persist: function() {},
        isPersistent: Vl
    }), e
}
var ja = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(t) {
            return t.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    },
    Tp = Hn(ja),
    wl = xr({}, ja, {
        view: 0,
        detail: 0
    }),
    S4 = Hn(wl),
    Hh, Qh, hu, Rc = xr({}, wl, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Op,
        button: 0,
        buttons: 0,
        relatedTarget: function(t) {
            return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
        },
        movementX: function(t) {
            return "movementX" in t ? t.movementX : (t !== hu && (hu && t.type === "mousemove" ? (Hh = t.screenX - hu.screenX, Qh = t.screenY - hu.screenY) : Qh = Hh = 0, hu = t), Hh)
        },
        movementY: function(t) {
            return "movementY" in t ? t.movementY : Qh
        }
    }),
    xm = Hn(Rc),
    M4 = xr({}, Rc, {
        dataTransfer: 0
    }),
    E4 = Hn(M4),
    _4 = xr({}, wl, {
        relatedTarget: 0
    }),
    qh = Hn(_4),
    I4 = xr({}, ja, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    C4 = Hn(I4),
    B4 = xr({}, ja, {
        clipboardData: function(t) {
            return "clipboardData" in t ? t.clipboardData : window.clipboardData
        }
    }),
    k4 = Hn(B4),
    N4 = xr({}, ja, {
        data: 0
    }),
    bm = Hn(N4),
    T4 = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    },
    O4 = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    },
    R4 = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };

function D4(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = R4[t]) ? !!e[t] : !1
}

function Op() {
    return D4
}
var P4 = xr({}, wl, {
        key: function(t) {
            if (t.key) {
                var e = T4[t.key] || t.key;
                if (e !== "Unidentified") return e
            }
            return t.type === "keypress" ? (t = Sf(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? O4[t.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Op,
        charCode: function(t) {
            return t.type === "keypress" ? Sf(t) : 0
        },
        keyCode: function(t) {
            return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        },
        which: function(t) {
            return t.type === "keypress" ? Sf(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        }
    }),
    L4 = Hn(P4),
    F4 = xr({}, Rc, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }),
    Am = Hn(F4),
    U4 = xr({}, wl, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Op
    }),
    z4 = Hn(U4),
    j4 = xr({}, ja, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    $4 = Hn(j4),
    H4 = xr({}, Rc, {
        deltaX: function(t) {
            return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0
        },
        deltaY: function(t) {
            return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }),
    Q4 = Hn(H4),
    q4 = [9, 13, 27, 32],
    Rp = ps && "CompositionEvent" in window,
    zu = null;
ps && "documentMode" in document && (zu = document.documentMode);
var W4 = ps && "TextEvent" in window && !zu,
    Ry = ps && (!Rp || zu && 8 < zu && 11 >= zu),
    Sm = String.fromCharCode(32),
    Mm = !1;

function Dy(t, e) {
    switch (t) {
        case "keyup":
            return q4.indexOf(e.keyCode) !== -1;
        case "keydown":
            return e.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}

function Py(t) {
    return t = t.detail, typeof t == "object" && "data" in t ? t.data : null
}
var Jo = !1;

function V4(t, e) {
    switch (t) {
        case "compositionend":
            return Py(e);
        case "keypress":
            return e.which !== 32 ? null : (Mm = !0, Sm);
        case "textInput":
            return t = e.data, t === Sm && Mm ? null : t;
        default:
            return null
    }
}

function G4(t, e) {
    if (Jo) return t === "compositionend" || !Rp && Dy(t, e) ? (t = Oy(), Af = Np = Us = null, Jo = !1, t) : null;
    switch (t) {
        case "paste":
            return null;
        case "keypress":
            if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
                if (e.char && 1 < e.char.length) return e.char;
                if (e.which) return String.fromCharCode(e.which)
            }
            return null;
        case "compositionend":
            return Ry && e.locale !== "ko" ? null : e.data;
        default:
            return null
    }
}
var Y4 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function Em(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!Y4[t.type] : e === "textarea"
}

function Ly(t, e, r, n) {
    py(n), e = Yf(e, "onChange"), 0 < e.length && (r = new Tp("onChange", "change", null, r, n), t.push({
        event: r,
        listeners: e
    }))
}
var ju = null,
    nl = null;

function K4(t) {
    Gy(t, 0)
}

function Dc(t) {
    var e = ta(t);
    if (ay(e)) return t
}

function Z4(t, e) {
    if (t === "change") return e
}
var Fy = !1;
if (ps) {
    var Wh;
    if (ps) {
        var Vh = "oninput" in document;
        if (!Vh) {
            var _m = document.createElement("div");
            _m.setAttribute("oninput", "return;"), Vh = typeof _m.oninput == "function"
        }
        Wh = Vh
    } else Wh = !1;
    Fy = Wh && (!document.documentMode || 9 < document.documentMode)
}

function Im() {
    ju && (ju.detachEvent("onpropertychange", Uy), nl = ju = null)
}

function Uy(t) {
    if (t.propertyName === "value" && Dc(nl)) {
        var e = [];
        Ly(e, nl, t, _p(t)), yy(K4, e)
    }
}

function J4(t, e, r) {
    t === "focusin" ? (Im(), ju = e, nl = r, ju.attachEvent("onpropertychange", Uy)) : t === "focusout" && Im()
}

function X4(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown") return Dc(nl)
}

function eb(t, e) {
    if (t === "click") return Dc(e)
}

function tb(t, e) {
    if (t === "input" || t === "change") return Dc(e)
}

function rb(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var _i = typeof Object.is == "function" ? Object.is : rb;

function il(t, e) {
    if (_i(t, e)) return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
    var r = Object.keys(t),
        n = Object.keys(e);
    if (r.length !== n.length) return !1;
    for (n = 0; n < r.length; n++) {
        var i = r[n];
        if (!G0.call(e, i) || !_i(t[i], e[i])) return !1
    }
    return !0
}

function Cm(t) {
    for (; t && t.firstChild;) t = t.firstChild;
    return t
}

function Bm(t, e) {
    var r = Cm(t);
    t = 0;
    for (var n; r;) {
        if (r.nodeType === 3) {
            if (n = t + r.textContent.length, t <= e && n >= e) return {
                node: r,
                offset: e - t
            };
            t = n
        }
        e: {
            for (; r;) {
                if (r.nextSibling) {
                    r = r.nextSibling;
                    break e
                }
                r = r.parentNode
            }
            r = void 0
        }
        r = Cm(r)
    }
}

function zy(t, e) {
    return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? zy(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}

function jy() {
    for (var t = window, e = $f(); e instanceof t.HTMLIFrameElement;) {
        try {
            var r = typeof e.contentWindow.location.href == "string"
        } catch {
            r = !1
        }
        if (r) t = e.contentWindow;
        else break;
        e = $f(t.document)
    }
    return e
}

function Dp(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}

function nb(t) {
    var e = jy(),
        r = t.focusedElem,
        n = t.selectionRange;
    if (e !== r && r && r.ownerDocument && zy(r.ownerDocument.documentElement, r)) {
        if (n !== null && Dp(r)) {
            if (e = n.start, t = n.end, t === void 0 && (t = e), "selectionStart" in r) r.selectionStart = e, r.selectionEnd = Math.min(t, r.value.length);
            else if (t = (e = r.ownerDocument || document) && e.defaultView || window, t.getSelection) {
                t = t.getSelection();
                var i = r.textContent.length,
                    s = Math.min(n.start, i);
                n = n.end === void 0 ? s : Math.min(n.end, i), !t.extend && s > n && (i = n, n = s, s = i), i = Bm(r, s);
                var o = Bm(r, n);
                i && o && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), s > n ? (t.addRange(e), t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), t.addRange(e)))
            }
        }
        for (e = [], t = r; t = t.parentNode;) t.nodeType === 1 && e.push({
            element: t,
            left: t.scrollLeft,
            top: t.scrollTop
        });
        for (typeof r.focus == "function" && r.focus(), r = 0; r < e.length; r++) t = e[r], t.element.scrollLeft = t.left, t.element.scrollTop = t.top
    }
}
var ib = ps && "documentMode" in document && 11 >= document.documentMode,
    Xo = null,
    dd = null,
    $u = null,
    pd = !1;

function km(t, e, r) {
    var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
    pd || Xo == null || Xo !== $f(n) || (n = Xo, "selectionStart" in n && Dp(n) ? n = {
        start: n.selectionStart,
        end: n.selectionEnd
    } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(), n = {
        anchorNode: n.anchorNode,
        anchorOffset: n.anchorOffset,
        focusNode: n.focusNode,
        focusOffset: n.focusOffset
    }), $u && il($u, n) || ($u = n, n = Yf(dd, "onSelect"), 0 < n.length && (e = new Tp("onSelect", "select", null, e, r), t.push({
        event: e,
        listeners: n
    }), e.target = Xo)))
}

function Gl(t, e) {
    var r = {};
    return r[t.toLowerCase()] = e.toLowerCase(), r["Webkit" + t] = "webkit" + e, r["Moz" + t] = "moz" + e, r
}
var ea = {
        animationend: Gl("Animation", "AnimationEnd"),
        animationiteration: Gl("Animation", "AnimationIteration"),
        animationstart: Gl("Animation", "AnimationStart"),
        transitionend: Gl("Transition", "TransitionEnd")
    },
    Gh = {},
    $y = {};
ps && ($y = document.createElement("div").style, "AnimationEvent" in window || (delete ea.animationend.animation, delete ea.animationiteration.animation, delete ea.animationstart.animation), "TransitionEvent" in window || delete ea.transitionend.transition);

function Pc(t) {
    if (Gh[t]) return Gh[t];
    if (!ea[t]) return t;
    var e = ea[t],
        r;
    for (r in e)
        if (e.hasOwnProperty(r) && r in $y) return Gh[t] = e[r];
    return t
}
var Hy = Pc("animationend"),
    Qy = Pc("animationiteration"),
    qy = Pc("animationstart"),
    Wy = Pc("transitionend"),
    Vy = new Map,
    Nm = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function io(t, e) {
    Vy.set(t, e), Ro(e, [t])
}
for (var Yh = 0; Yh < Nm.length; Yh++) {
    var Kh = Nm[Yh],
        sb = Kh.toLowerCase(),
        ob = Kh[0].toUpperCase() + Kh.slice(1);
    io(sb, "on" + ob)
}
io(Hy, "onAnimationEnd");
io(Qy, "onAnimationIteration");
io(qy, "onAnimationStart");
io("dblclick", "onDoubleClick");
io("focusin", "onFocus");
io("focusout", "onBlur");
io(Wy, "onTransitionEnd");
wa("onMouseEnter", ["mouseout", "mouseover"]);
wa("onMouseLeave", ["mouseout", "mouseover"]);
wa("onPointerEnter", ["pointerout", "pointerover"]);
wa("onPointerLeave", ["pointerout", "pointerover"]);
Ro("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Ro("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Ro("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Ro("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Ro("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Ro("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Nu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    ab = new Set("cancel close invalid load scroll toggle".split(" ").concat(Nu));

function Tm(t, e, r) {
    var n = t.type || "unknown-event";
    t.currentTarget = r, s4(n, e, void 0, t), t.currentTarget = null
}

function Gy(t, e) {
    e = (e & 4) !== 0;
    for (var r = 0; r < t.length; r++) {
        var n = t[r],
            i = n.event;
        n = n.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = n.length - 1; 0 <= o; o--) {
                    var a = n[o],
                        c = a.instance,
                        d = a.currentTarget;
                    if (a = a.listener, c !== s && i.isPropagationStopped()) break e;
                    Tm(i, a, d), s = c
                } else
                    for (o = 0; o < n.length; o++) {
                        if (a = n[o], c = a.instance, d = a.currentTarget, a = a.listener, c !== s && i.isPropagationStopped()) break e;
                        Tm(i, a, d), s = c
                    }
        }
    }
    if (Qf) throw t = ld, Qf = !1, ld = null, t
}

function cr(t, e) {
    var r = e[wd];
    r === void 0 && (r = e[wd] = new Set);
    var n = t + "__bubble";
    r.has(n) || (Yy(e, t, 2, !1), r.add(n))
}

function Zh(t, e, r) {
    var n = 0;
    e && (n |= 4), Yy(r, t, n, e)
}
var Yl = "_reactListening" + Math.random().toString(36).slice(2);

function sl(t) {
    if (!t[Yl]) {
        t[Yl] = !0, ry.forEach(function(r) {
            r !== "selectionchange" && (ab.has(r) || Zh(r, !1, t), Zh(r, !0, t))
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[Yl] || (e[Yl] = !0, Zh("selectionchange", !1, e))
    }
}

function Yy(t, e, r, n) {
    switch (Ty(e)) {
        case 1:
            var i = b4;
            break;
        case 4:
            i = A4;
            break;
        default:
            i = kp
    }
    r = i.bind(null, e, r, t), i = void 0, !ud || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), n ? i !== void 0 ? t.addEventListener(e, r, {
        capture: !0,
        passive: i
    }) : t.addEventListener(e, r, !0) : i !== void 0 ? t.addEventListener(e, r, {
        passive: i
    }) : t.addEventListener(e, r, !1)
}

function Jh(t, e, r, n, i) {
    var s = n;
    if ((e & 1) === 0 && (e & 2) === 0 && n !== null) e: for (;;) {
        if (n === null) return;
        var o = n.tag;
        if (o === 3 || o === 4) {
            var a = n.stateNode.containerInfo;
            if (a === i || a.nodeType === 8 && a.parentNode === i) break;
            if (o === 4)
                for (o = n.return; o !== null;) {
                    var c = o.tag;
                    if ((c === 3 || c === 4) && (c = o.stateNode.containerInfo, c === i || c.nodeType === 8 && c.parentNode === i)) return;
                    o = o.return
                }
            for (; a !== null;) {
                if (o = yo(a), o === null) return;
                if (c = o.tag, c === 5 || c === 6) {
                    n = s = o;
                    continue e
                }
                a = a.parentNode
            }
        }
        n = n.return
    }
    yy(function() {
        var d = s,
            y = _p(r),
            I = [];
        e: {
            var N = Vy.get(t);
            if (N !== void 0) {
                var E = Tp,
                    T = t;
                switch (t) {
                    case "keypress":
                        if (Sf(r) === 0) break e;
                    case "keydown":
                    case "keyup":
                        E = L4;
                        break;
                    case "focusin":
                        T = "focus", E = qh;
                        break;
                    case "focusout":
                        T = "blur", E = qh;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        E = qh;
                        break;
                    case "click":
                        if (r.button === 2) break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        E = xm;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        E = E4;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        E = z4;
                        break;
                    case Hy:
                    case Qy:
                    case qy:
                        E = C4;
                        break;
                    case Wy:
                        E = $4;
                        break;
                    case "scroll":
                        E = S4;
                        break;
                    case "wheel":
                        E = Q4;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        E = k4;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        E = Am
                }
                var j = (e & 4) !== 0,
                    V = !j && t === "scroll",
                    P = j ? N !== null ? N + "Capture" : null : N;
                j = [];
                for (var O = d, R; O !== null;) {
                    R = O;
                    var q = R.stateNode;
                    if (R.tag === 5 && q !== null && (R = q, P !== null && (q = Xu(O, P), q != null && j.push(ol(O, q, R)))), V) break;
                    O = O.return
                }
                0 < j.length && (N = new E(N, T, null, r, y), I.push({
                    event: N,
                    listeners: j
                }))
            }
        }
        if ((e & 7) === 0) {
            e: {
                if (N = t === "mouseover" || t === "pointerover", E = t === "mouseout" || t === "pointerout", N && r !== od && (T = r.relatedTarget || r.fromElement) && (yo(T) || T[ms])) break e;
                if ((E || N) && (N = y.window === y ? y : (N = y.ownerDocument) ? N.defaultView || N.parentWindow : window, E ? (T = r.relatedTarget || r.toElement, E = d, T = T ? yo(T) : null, T !== null && (V = Do(T), T !== V || T.tag !== 5 && T.tag !== 6) && (T = null)) : (E = null, T = d), E !== T)) {
                    if (j = xm, q = "onMouseLeave", P = "onMouseEnter", O = "mouse", (t === "pointerout" || t === "pointerover") && (j = Am, q = "onPointerLeave", P = "onPointerEnter", O = "pointer"), V = E == null ? N : ta(E), R = T == null ? N : ta(T), N = new j(q, O + "leave", E, r, y), N.target = V, N.relatedTarget = R, q = null, yo(y) === d && (j = new j(P, O + "enter", T, r, y), j.target = R, j.relatedTarget = V, q = j), V = q, E && T) t: {
                        for (j = E, P = T, O = 0, R = j; R; R = Qo(R)) O++;
                        for (R = 0, q = P; q; q = Qo(q)) R++;
                        for (; 0 < O - R;) j = Qo(j),
                        O--;
                        for (; 0 < R - O;) P = Qo(P),
                        R--;
                        for (; O--;) {
                            if (j === P || P !== null && j === P.alternate) break t;
                            j = Qo(j), P = Qo(P)
                        }
                        j = null
                    }
                    else j = null;
                    E !== null && Om(I, N, E, j, !1), T !== null && V !== null && Om(I, V, T, j, !0)
                }
            }
            e: {
                if (N = d ? ta(d) : window, E = N.nodeName && N.nodeName.toLowerCase(), E === "select" || E === "input" && N.type === "file") var W = Z4;
                else if (Em(N))
                    if (Fy) W = tb;
                    else {
                        W = X4;
                        var Y = J4
                    }
                else(E = N.nodeName) && E.toLowerCase() === "input" && (N.type === "checkbox" || N.type === "radio") && (W = eb);
                if (W && (W = W(t, d))) {
                    Ly(I, W, r, y);
                    break e
                }
                Y && Y(t, N, d),
                t === "focusout" && (Y = N._wrapperState) && Y.controlled && N.type === "number" && td(N, "number", N.value)
            }
            switch (Y = d ? ta(d) : window, t) {
                case "focusin":
                    (Em(Y) || Y.contentEditable === "true") && (Xo = Y, dd = d, $u = null);
                    break;
                case "focusout":
                    $u = dd = Xo = null;
                    break;
                case "mousedown":
                    pd = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    pd = !1, km(I, r, y);
                    break;
                case "selectionchange":
                    if (ib) break;
                case "keydown":
                case "keyup":
                    km(I, r, y)
            }
            var G;
            if (Rp) e: {
                switch (t) {
                    case "compositionstart":
                        var J = "onCompositionStart";
                        break e;
                    case "compositionend":
                        J = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        J = "onCompositionUpdate";
                        break e
                }
                J = void 0
            }
            else Jo ? Dy(t, r) && (J = "onCompositionEnd") : t === "keydown" && r.keyCode === 229 && (J = "onCompositionStart");J && (Ry && r.locale !== "ko" && (Jo || J !== "onCompositionStart" ? J === "onCompositionEnd" && Jo && (G = Oy()) : (Us = y, Np = "value" in Us ? Us.value : Us.textContent, Jo = !0)), Y = Yf(d, J), 0 < Y.length && (J = new bm(J, t, null, r, y), I.push({
                event: J,
                listeners: Y
            }), G ? J.data = G : (G = Py(r), G !== null && (J.data = G)))),
            (G = W4 ? V4(t, r) : G4(t, r)) && (d = Yf(d, "onBeforeInput"), 0 < d.length && (y = new bm("onBeforeInput", "beforeinput", null, r, y), I.push({
                event: y,
                listeners: d
            }), y.data = G))
        }
        Gy(I, e)
    })
}

function ol(t, e, r) {
    return {
        instance: t,
        listener: e,
        currentTarget: r
    }
}

function Yf(t, e) {
    for (var r = e + "Capture", n = []; t !== null;) {
        var i = t,
            s = i.stateNode;
        i.tag === 5 && s !== null && (i = s, s = Xu(t, r), s != null && n.unshift(ol(t, s, i)), s = Xu(t, e), s != null && n.push(ol(t, s, i))), t = t.return
    }
    return n
}

function Qo(t) {
    if (t === null) return null;
    do t = t.return; while (t && t.tag !== 5);
    return t || null
}

function Om(t, e, r, n, i) {
    for (var s = e._reactName, o = []; r !== null && r !== n;) {
        var a = r,
            c = a.alternate,
            d = a.stateNode;
        if (c !== null && c === n) break;
        a.tag === 5 && d !== null && (a = d, i ? (c = Xu(r, s), c != null && o.unshift(ol(r, c, a))) : i || (c = Xu(r, s), c != null && o.push(ol(r, c, a)))), r = r.return
    }
    o.length !== 0 && t.push({
        event: e,
        listeners: o
    })
}
var ub = /\r\n?/g,
    lb = /\u0000|\uFFFD/g;

function Rm(t) {
    return (typeof t == "string" ? t : "" + t).replace(ub, `
`).replace(lb, "")
}

function Kl(t, e, r) {
    if (e = Rm(e), Rm(t) !== e && r) throw Error(be(425))
}

function Kf() {}
var md = null,
    vd = null;

function gd(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var yd = typeof setTimeout == "function" ? setTimeout : void 0,
    fb = typeof clearTimeout == "function" ? clearTimeout : void 0,
    Dm = typeof Promise == "function" ? Promise : void 0,
    cb = typeof queueMicrotask == "function" ? queueMicrotask : typeof Dm != "undefined" ? function(t) {
        return Dm.resolve(null).then(t).catch(hb)
    } : yd;

function hb(t) {
    setTimeout(function() {
        throw t
    })
}

function Xh(t, e) {
    var r = e,
        n = 0;
    do {
        var i = r.nextSibling;
        if (t.removeChild(r), i && i.nodeType === 8)
            if (r = i.data, r === "/$") {
                if (n === 0) {
                    t.removeChild(i), rl(e);
                    return
                }
                n--
            } else r !== "$" && r !== "$?" && r !== "$!" || n++;
        r = i
    } while (r);
    rl(e)
}

function us(t) {
    for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3) break;
        if (e === 8) {
            if (e = t.data, e === "$" || e === "$!" || e === "$?") break;
            if (e === "/$") return null
        }
    }
    return t
}

function Pm(t) {
    t = t.previousSibling;
    for (var e = 0; t;) {
        if (t.nodeType === 8) {
            var r = t.data;
            if (r === "$" || r === "$!" || r === "$?") {
                if (e === 0) return t;
                e--
            } else r === "/$" && e++
        }
        t = t.previousSibling
    }
    return null
}
var $a = Math.random().toString(36).slice(2),
    Di = "__reactFiber$" + $a,
    al = "__reactProps$" + $a,
    ms = "__reactContainer$" + $a,
    wd = "__reactEvents$" + $a,
    db = "__reactListeners$" + $a,
    pb = "__reactHandles$" + $a;

function yo(t) {
    var e = t[Di];
    if (e) return e;
    for (var r = t.parentNode; r;) {
        if (e = r[ms] || r[Di]) {
            if (r = e.alternate, e.child !== null || r !== null && r.child !== null)
                for (t = Pm(t); t !== null;) {
                    if (r = t[Di]) return r;
                    t = Pm(t)
                }
            return e
        }
        t = r, r = t.parentNode
    }
    return null
}

function xl(t) {
    return t = t[Di] || t[ms], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}

function ta(t) {
    if (t.tag === 5 || t.tag === 6) return t.stateNode;
    throw Error(be(33))
}

function Lc(t) {
    return t[al] || null
}
var xd = [],
    ra = -1;

function so(t) {
    return {
        current: t
    }
}

function hr(t) {
    0 > ra || (t.current = xd[ra], xd[ra] = null, ra--)
}

function lr(t, e) {
    ra++, xd[ra] = t.current, t.current = e
}
var eo = {},
    mn = so(eo),
    In = so(!1),
    Io = eo;

function xa(t, e) {
    var r = t.type.contextTypes;
    if (!r) return eo;
    var n = t.stateNode;
    if (n && n.__reactInternalMemoizedUnmaskedChildContext === e) return n.__reactInternalMemoizedMaskedChildContext;
    var i = {},
        s;
    for (s in r) i[s] = e[s];
    return n && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i
}

function Cn(t) {
    return t = t.childContextTypes, t != null
}

function Zf() {
    hr(In), hr(mn)
}

function Lm(t, e, r) {
    if (mn.current !== eo) throw Error(be(168));
    lr(mn, e), lr(In, r)
}

function Ky(t, e, r) {
    var n = t.stateNode;
    if (e = e.childContextTypes, typeof n.getChildContext != "function") return r;
    n = n.getChildContext();
    for (var i in n)
        if (!(i in e)) throw Error(be(108, J6(t) || "Unknown", i));
    return xr({}, r, n)
}

function Jf(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || eo, Io = mn.current, lr(mn, t), lr(In, In.current), !0
}

function Fm(t, e, r) {
    var n = t.stateNode;
    if (!n) throw Error(be(169));
    r ? (t = Ky(t, e, Io), n.__reactInternalMemoizedMergedChildContext = t, hr(In), hr(mn), lr(mn, t)) : hr(In), lr(In, r)
}
var os = null,
    Fc = !1,
    e0 = !1;

function Zy(t) {
    os === null ? os = [t] : os.push(t)
}

function mb(t) {
    Fc = !0, Zy(t)
}

function oo() {
    if (!e0 && os !== null) {
        e0 = !0;
        var t = 0,
            e = sr;
        try {
            var r = os;
            for (sr = 1; t < r.length; t++) {
                var n = r[t];
                do n = n(!0); while (n !== null)
            }
            os = null, Fc = !1
        } catch (i) {
            throw os !== null && (os = os.slice(t + 1)), Ay(Ip, oo), i
        } finally {
            sr = e, e0 = !1
        }
    }
    return null
}
var vb = Ss.ReactCurrentBatchConfig;

function yi(t, e) {
    if (t && t.defaultProps) {
        e = xr({}, e), t = t.defaultProps;
        for (var r in t) e[r] === void 0 && (e[r] = t[r]);
        return e
    }
    return e
}
var Xf = so(null),
    ec = null,
    na = null,
    Pp = null;

function Lp() {
    Pp = na = ec = null
}

function Fp(t) {
    var e = Xf.current;
    hr(Xf), t._currentValue = e
}

function bd(t, e, r) {
    for (; t !== null;) {
        var n = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e, n !== null && (n.childLanes |= e)) : n !== null && (n.childLanes & e) !== e && (n.childLanes |= e), t === r) break;
        t = t.return
    }
}

function pa(t, e) {
    ec = t, Pp = na = null, t = t.dependencies, t !== null && t.firstContext !== null && ((t.lanes & e) !== 0 && (En = !0), t.firstContext = null)
}

function oi(t) {
    var e = t._currentValue;
    if (Pp !== t)
        if (t = {
                context: t,
                memoizedValue: e,
                next: null
            }, na === null) {
            if (ec === null) throw Error(be(308));
            na = t, ec.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else na = na.next = t;
    return e
}
var Ai = null,
    ks = !1;

function Up(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}

function Jy(t, e) {
    t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}

function ds(t, e) {
    return {
        eventTime: t,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}

function Ys(t, e) {
    var r = t.updateQueue;
    r !== null && (r = r.shared, jw(t) ? (t = r.interleaved, t === null ? (e.next = e, Ai === null ? Ai = [r] : Ai.push(r)) : (e.next = t.next, t.next = e), r.interleaved = e) : (t = r.pending, t === null ? e.next = e : (e.next = t.next, t.next = e), r.pending = e))
}

function Mf(t, e, r) {
    if (e = e.updateQueue, e !== null && (e = e.shared, (r & 4194240) !== 0)) {
        var n = e.lanes;
        n &= t.pendingLanes, r |= n, e.lanes = r, Cp(t, r)
    }
}

function Um(t, e) {
    var r = t.updateQueue,
        n = t.alternate;
    if (n !== null && (n = n.updateQueue, r === n)) {
        var i = null,
            s = null;
        if (r = r.firstBaseUpdate, r !== null) {
            do {
                var o = {
                    eventTime: r.eventTime,
                    lane: r.lane,
                    tag: r.tag,
                    payload: r.payload,
                    callback: r.callback,
                    next: null
                };
                s === null ? i = s = o : s = s.next = o, r = r.next
            } while (r !== null);
            s === null ? i = s = e : s = s.next = e
        } else i = s = e;
        r = {
            baseState: n.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: s,
            shared: n.shared,
            effects: n.effects
        }, t.updateQueue = r;
        return
    }
    t = r.lastBaseUpdate, t === null ? r.firstBaseUpdate = e : t.next = e, r.lastBaseUpdate = e
}

function tc(t, e, r, n) {
    var i = t.updateQueue;
    ks = !1;
    var s = i.firstBaseUpdate,
        o = i.lastBaseUpdate,
        a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var c = a,
            d = c.next;
        c.next = null, o === null ? s = d : o.next = d, o = c;
        var y = t.alternate;
        y !== null && (y = y.updateQueue, a = y.lastBaseUpdate, a !== o && (a === null ? y.firstBaseUpdate = d : a.next = d, y.lastBaseUpdate = c))
    }
    if (s !== null) {
        var I = i.baseState;
        o = 0, y = d = c = null, a = s;
        do {
            var N = a.lane,
                E = a.eventTime;
            if ((n & N) === N) {
                y !== null && (y = y.next = {
                    eventTime: E,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var T = t,
                        j = a;
                    switch (N = e, E = r, j.tag) {
                        case 1:
                            if (T = j.payload, typeof T == "function") {
                                I = T.call(E, I, N);
                                break e
                            }
                            I = T;
                            break e;
                        case 3:
                            T.flags = T.flags & -65537 | 128;
                        case 0:
                            if (T = j.payload, N = typeof T == "function" ? T.call(E, I, N) : T, N == null) break e;
                            I = xr({}, I, N);
                            break e;
                        case 2:
                            ks = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (t.flags |= 64, N = i.effects, N === null ? i.effects = [a] : N.push(a))
            } else E = {
                eventTime: E,
                lane: N,
                tag: a.tag,
                payload: a.payload,
                callback: a.callback,
                next: null
            }, y === null ? (d = y = E, c = I) : y = y.next = E, o |= N;
            if (a = a.next, a === null) {
                if (a = i.shared.pending, a === null) break;
                N = a, a = N.next, N.next = null, i.lastBaseUpdate = N, i.shared.pending = null
            }
        } while (1);
        if (y === null && (c = I), i.baseState = c, i.firstBaseUpdate = d, i.lastBaseUpdate = y, e = i.shared.interleaved, e !== null) {
            i = e;
            do o |= i.lane, i = i.next; while (i !== e)
        } else s === null && (i.shared.lanes = 0);
        ko |= o, t.lanes = o, t.memoizedState = I
    }
}

function zm(t, e, r) {
    if (t = e.effects, e.effects = null, t !== null)
        for (e = 0; e < t.length; e++) {
            var n = t[e],
                i = n.callback;
            if (i !== null) {
                if (n.callback = null, n = r, typeof i != "function") throw Error(be(191, i));
                i.call(n)
            }
        }
}
var Xy = new ty.Component().refs;

function Ad(t, e, r, n) {
    e = t.memoizedState, r = r(n, e), r = r == null ? e : xr({}, e, r), t.memoizedState = r, t.lanes === 0 && (t.updateQueue.baseState = r)
}
var Uc = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? Do(t) === t : !1
    },
    enqueueSetState: function(t, e, r) {
        t = t._reactInternals;
        var n = wn(),
            i = Zs(t),
            s = ds(n, i);
        s.payload = e, r != null && (s.callback = r), Ys(t, s), e = ii(t, i, n), e !== null && Mf(e, t, i)
    },
    enqueueReplaceState: function(t, e, r) {
        t = t._reactInternals;
        var n = wn(),
            i = Zs(t),
            s = ds(n, i);
        s.tag = 1, s.payload = e, r != null && (s.callback = r), Ys(t, s), e = ii(t, i, n), e !== null && Mf(e, t, i)
    },
    enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var r = wn(),
            n = Zs(t),
            i = ds(r, n);
        i.tag = 2, e != null && (i.callback = e), Ys(t, i), e = ii(t, n, r), e !== null && Mf(e, t, n)
    }
};

function jm(t, e, r, n, i, s, o) {
    return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(n, s, o) : e.prototype && e.prototype.isPureReactComponent ? !il(r, n) || !il(i, s) : !0
}

function ew(t, e, r) {
    var n = !1,
        i = eo,
        s = e.contextType;
    return typeof s == "object" && s !== null ? s = oi(s) : (i = Cn(e) ? Io : mn.current, n = e.contextTypes, s = (n = n != null) ? xa(t, i) : eo), e = new e(r, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = Uc, t.stateNode = e, e._reactInternals = t, n && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = s), e
}

function $m(t, e, r, n) {
    t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(r, n), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(r, n), e.state !== t && Uc.enqueueReplaceState(e, e.state, null)
}

function Sd(t, e, r, n) {
    var i = t.stateNode;
    i.props = r, i.state = t.memoizedState, i.refs = Xy, Up(t);
    var s = e.contextType;
    typeof s == "object" && s !== null ? i.context = oi(s) : (s = Cn(e) ? Io : mn.current, i.context = xa(t, s)), i.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (Ad(t, e, s, r), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && Uc.enqueueReplaceState(i, i.state, null), tc(t, r, i, n), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308)
}
var ia = [],
    sa = 0,
    rc = null,
    nc = 0,
    Zn = [],
    Jn = 0,
    Co = null,
    ls = 1,
    fs = "";

function ho(t, e) {
    ia[sa++] = nc, ia[sa++] = rc, rc = t, nc = e
}

function tw(t, e, r) {
    Zn[Jn++] = ls, Zn[Jn++] = fs, Zn[Jn++] = Co, Co = t;
    var n = ls;
    t = fs;
    var i = 32 - Mi(n) - 1;
    n &= ~(1 << i), r += 1;
    var s = 32 - Mi(e) + i;
    if (30 < s) {
        var o = i - i % 5;
        s = (n & (1 << o) - 1).toString(32), n >>= o, i -= o, ls = 1 << 32 - Mi(e) + i | r << i | n, fs = s + t
    } else ls = 1 << s | r << i | n, fs = t
}

function zp(t) {
    t.return !== null && (ho(t, 1), tw(t, 1, 0))
}

function jp(t) {
    for (; t === rc;) rc = ia[--sa], ia[sa] = null, nc = ia[--sa], ia[sa] = null;
    for (; t === Co;) Co = Zn[--Jn], Zn[Jn] = null, fs = Zn[--Jn], Zn[Jn] = null, ls = Zn[--Jn], Zn[Jn] = null
}
var Fn = null,
    Sn = null,
    pr = !1,
    bi = null;

function rw(t, e) {
    var r = ti(5, null, null, 0);
    r.elementType = "DELETED", r.stateNode = e, r.return = t, e = t.deletions, e === null ? (t.deletions = [r], t.flags |= 16) : e.push(r)
}

function Hm(t, e) {
    switch (t.tag) {
        case 5:
            var r = t.type;
            return e = e.nodeType !== 1 || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Fn = t, Sn = us(e.firstChild), !0) : !1;
        case 6:
            return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Fn = t, Sn = null, !0) : !1;
        case 13:
            return e = e.nodeType !== 8 ? null : e, e !== null ? (r = Co !== null ? {
                id: ls,
                overflow: fs
            } : null, t.memoizedState = {
                dehydrated: e,
                treeContext: r,
                retryLane: 1073741824
            }, r = ti(18, null, null, 0), r.stateNode = e, r.return = t, t.child = r, Fn = t, Sn = null, !0) : !1;
        default:
            return !1
    }
}

function Md(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}

function Ed(t) {
    if (pr) {
        var e = Sn;
        if (e) {
            var r = e;
            if (!Hm(t, e)) {
                if (Md(t)) throw Error(be(418));
                e = us(r.nextSibling);
                var n = Fn;
                e && Hm(t, e) ? rw(n, r) : (t.flags = t.flags & -4097 | 2, pr = !1, Fn = t)
            }
        } else {
            if (Md(t)) throw Error(be(418));
            t.flags = t.flags & -4097 | 2, pr = !1, Fn = t
        }
    }
}

function Qm(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;) t = t.return;
    Fn = t
}

function du(t) {
    if (t !== Fn) return !1;
    if (!pr) return Qm(t), pr = !0, !1;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !gd(t.type, t.memoizedProps)), e && (e = Sn)) {
        if (Md(t)) {
            for (t = Sn; t;) t = us(t.nextSibling);
            throw Error(be(418))
        }
        for (; e;) rw(t, e), e = us(e.nextSibling)
    }
    if (Qm(t), t.tag === 13) {
        if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(be(317));
        e: {
            for (t = t.nextSibling, e = 0; t;) {
                if (t.nodeType === 8) {
                    var r = t.data;
                    if (r === "/$") {
                        if (e === 0) {
                            Sn = us(t.nextSibling);
                            break e
                        }
                        e--
                    } else r !== "$" && r !== "$!" && r !== "$?" || e++
                }
                t = t.nextSibling
            }
            Sn = null
        }
    } else Sn = Fn ? us(t.stateNode.nextSibling) : null;
    return !0
}

function ba() {
    Sn = Fn = null, pr = !1
}

function $p(t) {
    bi === null ? bi = [t] : bi.push(t)
}

function pu(t, e, r) {
    if (t = r.ref, t !== null && typeof t != "function" && typeof t != "object") {
        if (r._owner) {
            if (r = r._owner, r) {
                if (r.tag !== 1) throw Error(be(309));
                var n = r.stateNode
            }
            if (!n) throw Error(be(147, t));
            var i = n,
                s = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = i.refs;
                a === Xy && (a = i.refs = {}), o === null ? delete a[s] : a[s] = o
            }, e._stringRef = s, e)
        }
        if (typeof t != "string") throw Error(be(284));
        if (!r._owner) throw Error(be(290, t))
    }
    return t
}

function Zl(t, e) {
    throw t = Object.prototype.toString.call(e), Error(be(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}

function qm(t) {
    var e = t._init;
    return e(t._payload)
}

function nw(t) {
    function e(P, O) {
        if (t) {
            var R = P.deletions;
            R === null ? (P.deletions = [O], P.flags |= 16) : R.push(O)
        }
    }

    function r(P, O) {
        if (!t) return null;
        for (; O !== null;) e(P, O), O = O.sibling;
        return null
    }

    function n(P, O) {
        for (P = new Map; O !== null;) O.key !== null ? P.set(O.key, O) : P.set(O.index, O), O = O.sibling;
        return P
    }

    function i(P, O) {
        return P = to(P, O), P.index = 0, P.sibling = null, P
    }

    function s(P, O, R) {
        return P.index = R, t ? (R = P.alternate, R !== null ? (R = R.index, R < O ? (P.flags |= 2, O) : R) : (P.flags |= 2, O)) : (P.flags |= 1048576, O)
    }

    function o(P) {
        return t && P.alternate === null && (P.flags |= 2), P
    }

    function a(P, O, R, q) {
        return O === null || O.tag !== 6 ? (O = o0(R, P.mode, q), O.return = P, O) : (O = i(O, R), O.return = P, O)
    }

    function c(P, O, R, q) {
        var W = R.type;
        return W === Zo ? y(P, O, R.props.children, q, R.key) : O !== null && (O.elementType === W || typeof W == "object" && W !== null && W.$$typeof === Bs && qm(W) === O.type) ? (q = i(O, R.props), q.ref = pu(P, O, R), q.return = P, q) : (q = Bf(R.type, R.key, R.props, null, P.mode, q), q.ref = pu(P, O, R), q.return = P, q)
    }

    function d(P, O, R, q) {
        return O === null || O.tag !== 4 || O.stateNode.containerInfo !== R.containerInfo || O.stateNode.implementation !== R.implementation ? (O = a0(R, P.mode, q), O.return = P, O) : (O = i(O, R.children || []), O.return = P, O)
    }

    function y(P, O, R, q, W) {
        return O === null || O.tag !== 7 ? (O = So(R, P.mode, q, W), O.return = P, O) : (O = i(O, R), O.return = P, O)
    }

    function I(P, O, R) {
        if (typeof O == "string" && O !== "" || typeof O == "number") return O = o0("" + O, P.mode, R), O.return = P, O;
        if (typeof O == "object" && O !== null) {
            switch (O.$$typeof) {
                case jl:
                    return R = Bf(O.type, O.key, O.props, null, P.mode, R), R.ref = pu(P, null, O), R.return = P, R;
                case Ko:
                    return O = a0(O, P.mode, R), O.return = P, O;
                case Bs:
                    var q = O._init;
                    return I(P, q(O._payload), R)
            }
            if (Bu(O) || uu(O)) return O = So(O, P.mode, R, null), O.return = P, O;
            Zl(P, O)
        }
        return null
    }

    function N(P, O, R, q) {
        var W = O !== null ? O.key : null;
        if (typeof R == "string" && R !== "" || typeof R == "number") return W !== null ? null : a(P, O, "" + R, q);
        if (typeof R == "object" && R !== null) {
            switch (R.$$typeof) {
                case jl:
                    return R.key === W ? c(P, O, R, q) : null;
                case Ko:
                    return R.key === W ? d(P, O, R, q) : null;
                case Bs:
                    return W = R._init, N(P, O, W(R._payload), q)
            }
            if (Bu(R) || uu(R)) return W !== null ? null : y(P, O, R, q, null);
            Zl(P, R)
        }
        return null
    }

    function E(P, O, R, q, W) {
        if (typeof q == "string" && q !== "" || typeof q == "number") return P = P.get(R) || null, a(O, P, "" + q, W);
        if (typeof q == "object" && q !== null) {
            switch (q.$$typeof) {
                case jl:
                    return P = P.get(q.key === null ? R : q.key) || null, c(O, P, q, W);
                case Ko:
                    return P = P.get(q.key === null ? R : q.key) || null, d(O, P, q, W);
                case Bs:
                    var Y = q._init;
                    return E(P, O, R, Y(q._payload), W)
            }
            if (Bu(q) || uu(q)) return P = P.get(R) || null, y(O, P, q, W, null);
            Zl(O, q)
        }
        return null
    }

    function T(P, O, R, q) {
        for (var W = null, Y = null, G = O, J = O = 0, pe = null; G !== null && J < R.length; J++) {
            G.index > J ? (pe = G, G = null) : pe = G.sibling;
            var we = N(P, G, R[J], q);
            if (we === null) {
                G === null && (G = pe);
                break
            }
            t && G && we.alternate === null && e(P, G), O = s(we, O, J), Y === null ? W = we : Y.sibling = we, Y = we, G = pe
        }
        if (J === R.length) return r(P, G), pr && ho(P, J), W;
        if (G === null) {
            for (; J < R.length; J++) G = I(P, R[J], q), G !== null && (O = s(G, O, J), Y === null ? W = G : Y.sibling = G, Y = G);
            return pr && ho(P, J), W
        }
        for (G = n(P, G); J < R.length; J++) pe = E(G, P, J, R[J], q), pe !== null && (t && pe.alternate !== null && G.delete(pe.key === null ? J : pe.key), O = s(pe, O, J), Y === null ? W = pe : Y.sibling = pe, Y = pe);
        return t && G.forEach(function(H) {
            return e(P, H)
        }), pr && ho(P, J), W
    }

    function j(P, O, R, q) {
        var W = uu(R);
        if (typeof W != "function") throw Error(be(150));
        if (R = W.call(R), R == null) throw Error(be(151));
        for (var Y = W = null, G = O, J = O = 0, pe = null, we = R.next(); G !== null && !we.done; J++, we = R.next()) {
            G.index > J ? (pe = G, G = null) : pe = G.sibling;
            var H = N(P, G, we.value, q);
            if (H === null) {
                G === null && (G = pe);
                break
            }
            t && G && H.alternate === null && e(P, G), O = s(H, O, J), Y === null ? W = H : Y.sibling = H, Y = H, G = pe
        }
        if (we.done) return r(P, G), pr && ho(P, J), W;
        if (G === null) {
            for (; !we.done; J++, we = R.next()) we = I(P, we.value, q), we !== null && (O = s(we, O, J), Y === null ? W = we : Y.sibling = we, Y = we);
            return pr && ho(P, J), W
        }
        for (G = n(P, G); !we.done; J++, we = R.next()) we = E(G, P, J, we.value, q), we !== null && (t && we.alternate !== null && G.delete(we.key === null ? J : we.key), O = s(we, O, J), Y === null ? W = we : Y.sibling = we, Y = we);
        return t && G.forEach(function(w) {
            return e(P, w)
        }), pr && ho(P, J), W
    }

    function V(P, O, R, q) {
        if (typeof R == "object" && R !== null && R.type === Zo && R.key === null && (R = R.props.children), typeof R == "object" && R !== null) {
            switch (R.$$typeof) {
                case jl:
                    e: {
                        for (var W = R.key, Y = O; Y !== null;) {
                            if (Y.key === W) {
                                if (W = R.type, W === Zo) {
                                    if (Y.tag === 7) {
                                        r(P, Y.sibling), O = i(Y, R.props.children), O.return = P, P = O;
                                        break e
                                    }
                                } else if (Y.elementType === W || typeof W == "object" && W !== null && W.$$typeof === Bs && qm(W) === Y.type) {
                                    r(P, Y.sibling), O = i(Y, R.props), O.ref = pu(P, Y, R), O.return = P, P = O;
                                    break e
                                }
                                r(P, Y);
                                break
                            } else e(P, Y);
                            Y = Y.sibling
                        }
                        R.type === Zo ? (O = So(R.props.children, P.mode, q, R.key), O.return = P, P = O) : (q = Bf(R.type, R.key, R.props, null, P.mode, q), q.ref = pu(P, O, R), q.return = P, P = q)
                    }
                    return o(P);
                case Ko:
                    e: {
                        for (Y = R.key; O !== null;) {
                            if (O.key === Y)
                                if (O.tag === 4 && O.stateNode.containerInfo === R.containerInfo && O.stateNode.implementation === R.implementation) {
                                    r(P, O.sibling), O = i(O, R.children || []), O.return = P, P = O;
                                    break e
                                } else {
                                    r(P, O);
                                    break
                                }
                            else e(P, O);
                            O = O.sibling
                        }
                        O = a0(R, P.mode, q),
                        O.return = P,
                        P = O
                    }
                    return o(P);
                case Bs:
                    return Y = R._init, V(P, O, Y(R._payload), q)
            }
            if (Bu(R)) return T(P, O, R, q);
            if (uu(R)) return j(P, O, R, q);
            Zl(P, R)
        }
        return typeof R == "string" && R !== "" || typeof R == "number" ? (R = "" + R, O !== null && O.tag === 6 ? (r(P, O.sibling), O = i(O, R), O.return = P, P = O) : (r(P, O), O = o0(R, P.mode, q), O.return = P, P = O), o(P)) : r(P, O)
    }
    return V
}
var Aa = nw(!0),
    iw = nw(!1),
    bl = {},
    Fi = so(bl),
    ul = so(bl),
    ll = so(bl);

function wo(t) {
    if (t === bl) throw Error(be(174));
    return t
}

function Hp(t, e) {
    switch (lr(ll, e), lr(ul, t), lr(Fi, bl), t = e.nodeType, t) {
        case 9:
        case 11:
            e = (e = e.documentElement) ? e.namespaceURI : nd(null, "");
            break;
        default:
            t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = nd(e, t)
    }
    hr(Fi), lr(Fi, e)
}

function Sa() {
    hr(Fi), hr(ul), hr(ll)
}

function sw(t) {
    wo(ll.current);
    var e = wo(Fi.current),
        r = nd(e, t.type);
    e !== r && (lr(ul, t), lr(Fi, r))
}

function Qp(t) {
    ul.current === t && (hr(Fi), hr(ul))
}
var gr = so(0);

function ic(t) {
    for (var e = t; e !== null;) {
        if (e.tag === 13) {
            var r = e.memoizedState;
            if (r !== null && (r = r.dehydrated, r === null || r.data === "$?" || r.data === "$!")) return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if ((e.flags & 128) !== 0) return e
        } else if (e.child !== null) {
            e.child.return = e, e = e.child;
            continue
        }
        if (e === t) break;
        for (; e.sibling === null;) {
            if (e.return === null || e.return === t) return null;
            e = e.return
        }
        e.sibling.return = e.return, e = e.sibling
    }
    return null
}
var t0 = [];

function qp() {
    for (var t = 0; t < t0.length; t++) t0[t]._workInProgressVersionPrimary = null;
    t0.length = 0
}
var Ef = Ss.ReactCurrentDispatcher,
    r0 = Ss.ReactCurrentBatchConfig,
    Bo = 0,
    wr = null,
    Or = null,
    zr = null,
    sc = !1,
    Hu = !1,
    fl = 0,
    gb = 0;

function on() {
    throw Error(be(321))
}

function Wp(t, e) {
    if (e === null) return !1;
    for (var r = 0; r < e.length && r < t.length; r++)
        if (!_i(t[r], e[r])) return !1;
    return !0
}

function Vp(t, e, r, n, i, s) {
    if (Bo = s, wr = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Ef.current = t === null || t.memoizedState === null ? bb : Ab, t = r(n, i), Hu) {
        s = 0;
        do {
            if (Hu = !1, fl = 0, 25 <= s) throw Error(be(301));
            s += 1, zr = Or = null, e.updateQueue = null, Ef.current = Sb, t = r(n, i)
        } while (Hu)
    }
    if (Ef.current = oc, e = Or !== null && Or.next !== null, Bo = 0, zr = Or = wr = null, sc = !1, e) throw Error(be(300));
    return t
}

function Gp() {
    var t = fl !== 0;
    return fl = 0, t
}

function Ti() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return zr === null ? wr.memoizedState = zr = t : zr = zr.next = t, zr
}

function ai() {
    if (Or === null) {
        var t = wr.alternate;
        t = t !== null ? t.memoizedState : null
    } else t = Or.next;
    var e = zr === null ? wr.memoizedState : zr.next;
    if (e !== null) zr = e, Or = t;
    else {
        if (t === null) throw Error(be(310));
        Or = t, t = {
            memoizedState: Or.memoizedState,
            baseState: Or.baseState,
            baseQueue: Or.baseQueue,
            queue: Or.queue,
            next: null
        }, zr === null ? wr.memoizedState = zr = t : zr = zr.next = t
    }
    return zr
}

function cl(t, e) {
    return typeof e == "function" ? e(t) : e
}

function n0(t) {
    var e = ai(),
        r = e.queue;
    if (r === null) throw Error(be(311));
    r.lastRenderedReducer = t;
    var n = Or,
        i = n.baseQueue,
        s = r.pending;
    if (s !== null) {
        if (i !== null) {
            var o = i.next;
            i.next = s.next, s.next = o
        }
        n.baseQueue = i = s, r.pending = null
    }
    if (i !== null) {
        s = i.next, n = n.baseState;
        var a = o = null,
            c = null,
            d = s;
        do {
            var y = d.lane;
            if ((Bo & y) === y) c !== null && (c = c.next = {
                lane: 0,
                action: d.action,
                hasEagerState: d.hasEagerState,
                eagerState: d.eagerState,
                next: null
            }), n = d.hasEagerState ? d.eagerState : t(n, d.action);
            else {
                var I = {
                    lane: y,
                    action: d.action,
                    hasEagerState: d.hasEagerState,
                    eagerState: d.eagerState,
                    next: null
                };
                c === null ? (a = c = I, o = n) : c = c.next = I, wr.lanes |= y, ko |= y
            }
            d = d.next
        } while (d !== null && d !== s);
        c === null ? o = n : c.next = a, _i(n, e.memoizedState) || (En = !0), e.memoizedState = n, e.baseState = o, e.baseQueue = c, r.lastRenderedState = n
    }
    if (t = r.interleaved, t !== null) {
        i = t;
        do s = i.lane, wr.lanes |= s, ko |= s, i = i.next; while (i !== t)
    } else i === null && (r.lanes = 0);
    return [e.memoizedState, r.dispatch]
}

function i0(t) {
    var e = ai(),
        r = e.queue;
    if (r === null) throw Error(be(311));
    r.lastRenderedReducer = t;
    var n = r.dispatch,
        i = r.pending,
        s = e.memoizedState;
    if (i !== null) {
        r.pending = null;
        var o = i = i.next;
        do s = t(s, o.action), o = o.next; while (o !== i);
        _i(s, e.memoizedState) || (En = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), r.lastRenderedState = s
    }
    return [s, n]
}

function ow() {}

function aw(t, e) {
    var r = wr,
        n = ai(),
        i = e(),
        s = !_i(n.memoizedState, i);
    if (s && (n.memoizedState = i, En = !0), n = n.queue, Yp(fw.bind(null, r, n, t), [t]), n.getSnapshot !== e || s || zr !== null && zr.memoizedState.tag & 1) {
        if (r.flags |= 2048, hl(9, lw.bind(null, r, n, i, e), void 0, null), Lr === null) throw Error(be(349));
        (Bo & 30) !== 0 || uw(r, e, i)
    }
    return i
}

function uw(t, e, r) {
    t.flags |= 16384, t = {
        getSnapshot: e,
        value: r
    }, e = wr.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, wr.updateQueue = e, e.stores = [t]) : (r = e.stores, r === null ? e.stores = [t] : r.push(t))
}

function lw(t, e, r, n) {
    e.value = r, e.getSnapshot = n, cw(e) && ii(t, 1, -1)
}

function fw(t, e, r) {
    return r(function() {
        cw(e) && ii(t, 1, -1)
    })
}

function cw(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var r = e();
        return !_i(t, r)
    } catch {
        return !0
    }
}

function Wm(t) {
    var e = Ti();
    return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: cl,
        lastRenderedState: t
    }, e.queue = t, t = t.dispatch = xb.bind(null, wr, t), [e.memoizedState, t]
}

function hl(t, e, r, n) {
    return t = {
        tag: t,
        create: e,
        destroy: r,
        deps: n,
        next: null
    }, e = wr.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, wr.updateQueue = e, e.lastEffect = t.next = t) : (r = e.lastEffect, r === null ? e.lastEffect = t.next = t : (n = r.next, r.next = t, t.next = n, e.lastEffect = t)), t
}

function hw() {
    return ai().memoizedState
}

function _f(t, e, r, n) {
    var i = Ti();
    wr.flags |= t, i.memoizedState = hl(1 | e, r, void 0, n === void 0 ? null : n)
}

function zc(t, e, r, n) {
    var i = ai();
    n = n === void 0 ? null : n;
    var s = void 0;
    if (Or !== null) {
        var o = Or.memoizedState;
        if (s = o.destroy, n !== null && Wp(n, o.deps)) {
            i.memoizedState = hl(e, r, s, n);
            return
        }
    }
    wr.flags |= t, i.memoizedState = hl(1 | e, r, s, n)
}

function Vm(t, e) {
    return _f(8390656, 8, t, e)
}

function Yp(t, e) {
    return zc(2048, 8, t, e)
}

function dw(t, e) {
    return zc(4, 2, t, e)
}

function pw(t, e) {
    return zc(4, 4, t, e)
}

function mw(t, e) {
    if (typeof e == "function") return t = t(), e(t),
        function() {
            e(null)
        };
    if (e != null) return t = t(), e.current = t,
        function() {
            e.current = null
        }
}

function vw(t, e, r) {
    return r = r != null ? r.concat([t]) : null, zc(4, 4, mw.bind(null, e, t), r)
}

function Kp() {}

function gw(t, e) {
    var r = ai();
    e = e === void 0 ? null : e;
    var n = r.memoizedState;
    return n !== null && e !== null && Wp(e, n[1]) ? n[0] : (r.memoizedState = [t, e], t)
}

function yw(t, e) {
    var r = ai();
    e = e === void 0 ? null : e;
    var n = r.memoizedState;
    return n !== null && e !== null && Wp(e, n[1]) ? n[0] : (t = t(), r.memoizedState = [t, e], t)
}

function ww(t, e, r) {
    return (Bo & 21) === 0 ? (t.baseState && (t.baseState = !1, En = !0), t.memoizedState = r) : (_i(r, e) || (r = Ey(), wr.lanes |= r, ko |= r, t.baseState = !0), e)
}

function yb(t, e) {
    var r = sr;
    sr = r !== 0 && 4 > r ? r : 4, t(!0);
    var n = r0.transition;
    r0.transition = {};
    try {
        t(!1), e()
    } finally {
        sr = r, r0.transition = n
    }
}

function xw() {
    return ai().memoizedState
}

function wb(t, e, r) {
    var n = Zs(t);
    r = {
        lane: n,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    }, bw(t) ? Aw(e, r) : (Sw(t, e, r), r = wn(), t = ii(t, n, r), t !== null && Mw(t, e, n))
}

function xb(t, e, r) {
    var n = Zs(t),
        i = {
            lane: n,
            action: r,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
    if (bw(t)) Aw(e, i);
    else {
        Sw(t, e, i);
        var s = t.alternate;
        if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
            var o = e.lastRenderedState,
                a = s(o, r);
            if (i.hasEagerState = !0, i.eagerState = a, _i(a, o)) return
        } catch {} finally {}
        r = wn(), t = ii(t, n, r), t !== null && Mw(t, e, n)
    }
}

function bw(t) {
    var e = t.alternate;
    return t === wr || e !== null && e === wr
}

function Aw(t, e) {
    Hu = sc = !0;
    var r = t.pending;
    r === null ? e.next = e : (e.next = r.next, r.next = e), t.pending = e
}

function Sw(t, e, r) {
    jw(t) ? (t = e.interleaved, t === null ? (r.next = r, Ai === null ? Ai = [e] : Ai.push(e)) : (r.next = t.next, t.next = r), e.interleaved = r) : (t = e.pending, t === null ? r.next = r : (r.next = t.next, t.next = r), e.pending = r)
}

function Mw(t, e, r) {
    if ((r & 4194240) !== 0) {
        var n = e.lanes;
        n &= t.pendingLanes, r |= n, e.lanes = r, Cp(t, r)
    }
}
var oc = {
        readContext: oi,
        useCallback: on,
        useContext: on,
        useEffect: on,
        useImperativeHandle: on,
        useInsertionEffect: on,
        useLayoutEffect: on,
        useMemo: on,
        useReducer: on,
        useRef: on,
        useState: on,
        useDebugValue: on,
        useDeferredValue: on,
        useTransition: on,
        useMutableSource: on,
        useSyncExternalStore: on,
        useId: on,
        unstable_isNewReconciler: !1
    },
    bb = {
        readContext: oi,
        useCallback: function(t, e) {
            return Ti().memoizedState = [t, e === void 0 ? null : e], t
        },
        useContext: oi,
        useEffect: Vm,
        useImperativeHandle: function(t, e, r) {
            return r = r != null ? r.concat([t]) : null, _f(4194308, 4, mw.bind(null, e, t), r)
        },
        useLayoutEffect: function(t, e) {
            return _f(4194308, 4, t, e)
        },
        useInsertionEffect: function(t, e) {
            return _f(4, 2, t, e)
        },
        useMemo: function(t, e) {
            var r = Ti();
            return e = e === void 0 ? null : e, t = t(), r.memoizedState = [t, e], t
        },
        useReducer: function(t, e, r) {
            var n = Ti();
            return e = r !== void 0 ? r(e) : e, n.memoizedState = n.baseState = e, t = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: t,
                lastRenderedState: e
            }, n.queue = t, t = t.dispatch = wb.bind(null, wr, t), [n.memoizedState, t]
        },
        useRef: function(t) {
            var e = Ti();
            return t = {
                current: t
            }, e.memoizedState = t
        },
        useState: Wm,
        useDebugValue: Kp,
        useDeferredValue: function(t) {
            return Ti().memoizedState = t
        },
        useTransition: function() {
            var t = Wm(!1),
                e = t[0];
            return t = yb.bind(null, t[1]), Ti().memoizedState = t, [e, t]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(t, e, r) {
            var n = wr,
                i = Ti();
            if (pr) {
                if (r === void 0) throw Error(be(407));
                r = r()
            } else {
                if (r = e(), Lr === null) throw Error(be(349));
                (Bo & 30) !== 0 || uw(n, e, r)
            }
            i.memoizedState = r;
            var s = {
                value: r,
                getSnapshot: e
            };
            return i.queue = s, Vm(fw.bind(null, n, s, t), [t]), n.flags |= 2048, hl(9, lw.bind(null, n, s, r, e), void 0, null), r
        },
        useId: function() {
            var t = Ti(),
                e = Lr.identifierPrefix;
            if (pr) {
                var r = fs,
                    n = ls;
                r = (n & ~(1 << 32 - Mi(n) - 1)).toString(32) + r, e = ":" + e + "R" + r, r = fl++, 0 < r && (e += "H" + r.toString(32)), e += ":"
            } else r = gb++, e = ":" + e + "r" + r.toString(32) + ":";
            return t.memoizedState = e
        },
        unstable_isNewReconciler: !1
    },
    Ab = {
        readContext: oi,
        useCallback: gw,
        useContext: oi,
        useEffect: Yp,
        useImperativeHandle: vw,
        useInsertionEffect: dw,
        useLayoutEffect: pw,
        useMemo: yw,
        useReducer: n0,
        useRef: hw,
        useState: function() {
            return n0(cl)
        },
        useDebugValue: Kp,
        useDeferredValue: function(t) {
            var e = ai();
            return ww(e, Or.memoizedState, t)
        },
        useTransition: function() {
            var t = n0(cl)[0],
                e = ai().memoizedState;
            return [t, e]
        },
        useMutableSource: ow,
        useSyncExternalStore: aw,
        useId: xw,
        unstable_isNewReconciler: !1
    },
    Sb = {
        readContext: oi,
        useCallback: gw,
        useContext: oi,
        useEffect: Yp,
        useImperativeHandle: vw,
        useInsertionEffect: dw,
        useLayoutEffect: pw,
        useMemo: yw,
        useReducer: i0,
        useRef: hw,
        useState: function() {
            return i0(cl)
        },
        useDebugValue: Kp,
        useDeferredValue: function(t) {
            var e = ai();
            return Or === null ? e.memoizedState = t : ww(e, Or.memoizedState, t)
        },
        useTransition: function() {
            var t = i0(cl)[0],
                e = ai().memoizedState;
            return [t, e]
        },
        useMutableSource: ow,
        useSyncExternalStore: aw,
        useId: xw,
        unstable_isNewReconciler: !1
    };

function Zp(t, e) {
    try {
        var r = "",
            n = e;
        do r += Z6(n), n = n.return; while (n);
        var i = r
    } catch (s) {
        i = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: t,
        source: e,
        stack: i
    }
}

function _d(t, e) {
    try {
        console.error(e.value)
    } catch (r) {
        setTimeout(function() {
            throw r
        })
    }
}
var Mb = typeof WeakMap == "function" ? WeakMap : Map;

function Ew(t, e, r) {
    r = ds(-1, r), r.tag = 3, r.payload = {
        element: null
    };
    var n = e.value;
    return r.callback = function() {
        uc || (uc = !0, Dd = n), _d(t, e)
    }, r
}

function _w(t, e, r) {
    r = ds(-1, r), r.tag = 3;
    var n = t.type.getDerivedStateFromError;
    if (typeof n == "function") {
        var i = e.value;
        r.payload = function() {
            return n(i)
        }, r.callback = function() {
            _d(t, e)
        }
    }
    var s = t.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (r.callback = function() {
        _d(t, e), typeof n != "function" && (Ks === null ? Ks = new Set([this]) : Ks.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }), r
}

function Gm(t, e, r) {
    var n = t.pingCache;
    if (n === null) {
        n = t.pingCache = new Mb;
        var i = new Set;
        n.set(e, i)
    } else i = n.get(e), i === void 0 && (i = new Set, n.set(e, i));
    i.has(r) || (i.add(r), t = Lb.bind(null, t, e, r), e.then(t, t))
}

function Ym(t) {
    do {
        var e;
        if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t;
        t = t.return
    } while (t !== null);
    return null
}

function Km(t, e, r, n, i) {
    return (t.mode & 1) === 0 ? (t === e ? t.flags |= 65536 : (t.flags |= 128, r.flags |= 131072, r.flags &= -52805, r.tag === 1 && (r.alternate === null ? r.tag = 17 : (e = ds(-1, 1), e.tag = 2, Ys(r, e))), r.lanes |= 1), t) : (t.flags |= 65536, t.lanes = i, t)
}
var Iw, Id, Cw, Bw;
Iw = function(t, e) {
    for (var r = e.child; r !== null;) {
        if (r.tag === 5 || r.tag === 6) t.appendChild(r.stateNode);
        else if (r.tag !== 4 && r.child !== null) {
            r.child.return = r, r = r.child;
            continue
        }
        if (r === e) break;
        for (; r.sibling === null;) {
            if (r.return === null || r.return === e) return;
            r = r.return
        }
        r.sibling.return = r.return, r = r.sibling
    }
};
Id = function() {};
Cw = function(t, e, r, n) {
    var i = t.memoizedProps;
    if (i !== n) {
        t = e.stateNode, wo(Fi.current);
        var s = null;
        switch (r) {
            case "input":
                i = X0(t, i), n = X0(t, n), s = [];
                break;
            case "select":
                i = xr({}, i, {
                    value: void 0
                }), n = xr({}, n, {
                    value: void 0
                }), s = [];
                break;
            case "textarea":
                i = rd(t, i), n = rd(t, n), s = [];
                break;
            default:
                typeof i.onClick != "function" && typeof n.onClick == "function" && (t.onclick = Kf)
        }
        id(r, n);
        var o;
        r = null;
        for (d in i)
            if (!n.hasOwnProperty(d) && i.hasOwnProperty(d) && i[d] != null)
                if (d === "style") {
                    var a = i[d];
                    for (o in a) a.hasOwnProperty(o) && (r || (r = {}), r[o] = "")
                } else d !== "dangerouslySetInnerHTML" && d !== "children" && d !== "suppressContentEditableWarning" && d !== "suppressHydrationWarning" && d !== "autoFocus" && (Zu.hasOwnProperty(d) ? s || (s = []) : (s = s || []).push(d, null));
        for (d in n) {
            var c = n[d];
            if (a = i != null ? i[d] : void 0, n.hasOwnProperty(d) && c !== a && (c != null || a != null))
                if (d === "style")
                    if (a) {
                        for (o in a) !a.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (r || (r = {}), r[o] = "");
                        for (o in c) c.hasOwnProperty(o) && a[o] !== c[o] && (r || (r = {}), r[o] = c[o])
                    } else r || (s || (s = []), s.push(d, r)), r = c;
            else d === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, a = a ? a.__html : void 0, c != null && a !== c && (s = s || []).push(d, c)) : d === "children" ? typeof c != "string" && typeof c != "number" || (s = s || []).push(d, "" + c) : d !== "suppressContentEditableWarning" && d !== "suppressHydrationWarning" && (Zu.hasOwnProperty(d) ? (c != null && d === "onScroll" && cr("scroll", t), s || a === c || (s = [])) : (s = s || []).push(d, c))
        }
        r && (s = s || []).push("style", r);
        var d = s;
        (e.updateQueue = d) && (e.flags |= 4)
    }
};
Bw = function(t, e, r, n) {
    r !== n && (e.flags |= 4)
};

function mu(t, e) {
    if (!pr) switch (t.tailMode) {
        case "hidden":
            e = t.tail;
            for (var r = null; e !== null;) e.alternate !== null && (r = e), e = e.sibling;
            r === null ? t.tail = null : r.sibling = null;
            break;
        case "collapsed":
            r = t.tail;
            for (var n = null; r !== null;) r.alternate !== null && (n = r), r = r.sibling;
            n === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : n.sibling = null
    }
}

function an(t) {
    var e = t.alternate !== null && t.alternate.child === t.child,
        r = 0,
        n = 0;
    if (e)
        for (var i = t.child; i !== null;) r |= i.lanes | i.childLanes, n |= i.subtreeFlags & 14680064, n |= i.flags & 14680064, i.return = t, i = i.sibling;
    else
        for (i = t.child; i !== null;) r |= i.lanes | i.childLanes, n |= i.subtreeFlags, n |= i.flags, i.return = t, i = i.sibling;
    return t.subtreeFlags |= n, t.childLanes = r, e
}

function Eb(t, e, r) {
    var n = e.pendingProps;
    switch (jp(e), e.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return an(e), null;
        case 1:
            return Cn(e.type) && Zf(), an(e), null;
        case 3:
            return n = e.stateNode, Sa(), hr(In), hr(mn), qp(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (t === null || t.child === null) && (du(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && (e.flags & 256) === 0 || (e.flags |= 1024, bi !== null && (Fd(bi), bi = null))), Id(t, e), an(e), null;
        case 5:
            Qp(e);
            var i = wo(ll.current);
            if (r = e.type, t !== null && e.stateNode != null) Cw(t, e, r, n, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
            else {
                if (!n) {
                    if (e.stateNode === null) throw Error(be(166));
                    return an(e), null
                }
                if (t = wo(Fi.current), du(e)) {
                    n = e.stateNode, r = e.type;
                    var s = e.memoizedProps;
                    switch (n[Di] = e, n[al] = s, t = (e.mode & 1) !== 0, r) {
                        case "dialog":
                            cr("cancel", n), cr("close", n);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            cr("load", n);
                            break;
                        case "video":
                        case "audio":
                            for (i = 0; i < Nu.length; i++) cr(Nu[i], n);
                            break;
                        case "source":
                            cr("error", n);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            cr("error", n), cr("load", n);
                            break;
                        case "details":
                            cr("toggle", n);
                            break;
                        case "input":
                            fm(n, s), cr("invalid", n);
                            break;
                        case "select":
                            n._wrapperState = {
                                wasMultiple: !!s.multiple
                            }, cr("invalid", n);
                            break;
                        case "textarea":
                            hm(n, s), cr("invalid", n)
                    }
                    id(r, s), i = null;
                    for (var o in s)
                        if (s.hasOwnProperty(o)) {
                            var a = s[o];
                            o === "children" ? typeof a == "string" ? n.textContent !== a && (s.suppressHydrationWarning !== !0 && Kl(n.textContent, a, t), i = ["children", a]) : typeof a == "number" && n.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Kl(n.textContent, a, t), i = ["children", "" + a]) : Zu.hasOwnProperty(o) && a != null && o === "onScroll" && cr("scroll", n)
                        }
                    switch (r) {
                        case "input":
                            $l(n), cm(n, s, !0);
                            break;
                        case "textarea":
                            $l(n), dm(n);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof s.onClick == "function" && (n.onclick = Kf)
                    }
                    n = i, e.updateQueue = n, n !== null && (e.flags |= 4)
                } else {
                    o = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = fy(r)), t === "http://www.w3.org/1999/xhtml" ? r === "script" ? (t = o.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof n.is == "string" ? t = o.createElement(r, {
                        is: n.is
                    }) : (t = o.createElement(r), r === "select" && (o = t, n.multiple ? o.multiple = !0 : n.size && (o.size = n.size))) : t = o.createElementNS(t, r), t[Di] = e, t[al] = n, Iw(t, e, !1, !1), e.stateNode = t;
                    e: {
                        switch (o = sd(r, n), r) {
                            case "dialog":
                                cr("cancel", t), cr("close", t), i = n;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                cr("load", t), i = n;
                                break;
                            case "video":
                            case "audio":
                                for (i = 0; i < Nu.length; i++) cr(Nu[i], t);
                                i = n;
                                break;
                            case "source":
                                cr("error", t), i = n;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                cr("error", t), cr("load", t), i = n;
                                break;
                            case "details":
                                cr("toggle", t), i = n;
                                break;
                            case "input":
                                fm(t, n), i = X0(t, n), cr("invalid", t);
                                break;
                            case "option":
                                i = n;
                                break;
                            case "select":
                                t._wrapperState = {
                                    wasMultiple: !!n.multiple
                                }, i = xr({}, n, {
                                    value: void 0
                                }), cr("invalid", t);
                                break;
                            case "textarea":
                                hm(t, n), i = rd(t, n), cr("invalid", t);
                                break;
                            default:
                                i = n
                        }
                        id(r, i),
                        a = i;
                        for (s in a)
                            if (a.hasOwnProperty(s)) {
                                var c = a[s];
                                s === "style" ? dy(t, c) : s === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, c != null && cy(t, c)) : s === "children" ? typeof c == "string" ? (r !== "textarea" || c !== "") && Ju(t, c) : typeof c == "number" && Ju(t, "" + c) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Zu.hasOwnProperty(s) ? c != null && s === "onScroll" && cr("scroll", t) : c != null && Ap(t, s, c, o))
                            }
                        switch (r) {
                            case "input":
                                $l(t), cm(t, n, !1);
                                break;
                            case "textarea":
                                $l(t), dm(t);
                                break;
                            case "option":
                                n.value != null && t.setAttribute("value", "" + Xs(n.value));
                                break;
                            case "select":
                                t.multiple = !!n.multiple, s = n.value, s != null ? fa(t, !!n.multiple, s, !1) : n.defaultValue != null && fa(t, !!n.multiple, n.defaultValue, !0);
                                break;
                            default:
                                typeof i.onClick == "function" && (t.onclick = Kf)
                        }
                        switch (r) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                n = !!n.autoFocus;
                                break e;
                            case "img":
                                n = !0;
                                break e;
                            default:
                                n = !1
                        }
                    }
                    n && (e.flags |= 4)
                }
                e.ref !== null && (e.flags |= 512, e.flags |= 2097152)
            }
            return an(e), null;
        case 6:
            if (t && e.stateNode != null) Bw(t, e, t.memoizedProps, n);
            else {
                if (typeof n != "string" && e.stateNode === null) throw Error(be(166));
                if (r = wo(ll.current), wo(Fi.current), du(e)) {
                    if (n = e.stateNode, r = e.memoizedProps, n[Di] = e, (s = n.nodeValue !== r) && (t = Fn, t !== null)) switch (t.tag) {
                        case 3:
                            Kl(n.nodeValue, r, (t.mode & 1) !== 0);
                            break;
                        case 5:
                            t.memoizedProps.suppressHydrationWarning !== !0 && Kl(n.nodeValue, r, (t.mode & 1) !== 0)
                    }
                    s && (e.flags |= 4)
                } else n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n), n[Di] = e, e.stateNode = n
            }
            return an(e), null;
        case 13:
            if (hr(gr), n = e.memoizedState, pr && Sn !== null && (e.mode & 1) !== 0 && (e.flags & 128) === 0) {
                for (n = Sn; n;) n = us(n.nextSibling);
                return ba(), e.flags |= 98560, e
            }
            if (n !== null && n.dehydrated !== null) {
                if (n = du(e), t === null) {
                    if (!n) throw Error(be(318));
                    if (n = e.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(be(317));
                    n[Di] = e
                } else ba(), (e.flags & 128) === 0 && (e.memoizedState = null), e.flags |= 4;
                return an(e), null
            }
            return bi !== null && (Fd(bi), bi = null), (e.flags & 128) !== 0 ? (e.lanes = r, e) : (n = n !== null, r = !1, t === null ? du(e) : r = t.memoizedState !== null, n !== r && n && (e.child.flags |= 8192, (e.mode & 1) !== 0 && (t === null || (gr.current & 1) !== 0 ? Dr === 0 && (Dr = 3) : n1())), e.updateQueue !== null && (e.flags |= 4), an(e), null);
        case 4:
            return Sa(), Id(t, e), t === null && sl(e.stateNode.containerInfo), an(e), null;
        case 10:
            return Fp(e.type._context), an(e), null;
        case 17:
            return Cn(e.type) && Zf(), an(e), null;
        case 19:
            if (hr(gr), s = e.memoizedState, s === null) return an(e), null;
            if (n = (e.flags & 128) !== 0, o = s.rendering, o === null)
                if (n) mu(s, !1);
                else {
                    if (Dr !== 0 || t !== null && (t.flags & 128) !== 0)
                        for (t = e.child; t !== null;) {
                            if (o = ic(t), o !== null) {
                                for (e.flags |= 128, mu(s, !1), n = o.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), e.subtreeFlags = 0, n = r, r = e.child; r !== null;) s = r, t = n, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, t = o.dependencies, s.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }), r = r.sibling;
                                return lr(gr, gr.current & 1 | 2), e.child
                            }
                            t = t.sibling
                        }
                    s.tail !== null && Cr() > Ma && (e.flags |= 128, n = !0, mu(s, !1), e.lanes = 4194304)
                }
            else {
                if (!n)
                    if (t = ic(o), t !== null) {
                        if (e.flags |= 128, n = !0, r = t.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), mu(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !pr) return an(e), null
                    } else 2 * Cr() - s.renderingStartTime > Ma && r !== 1073741824 && (e.flags |= 128, n = !0, mu(s, !1), e.lanes = 4194304);
                s.isBackwards ? (o.sibling = e.child, e.child = o) : (r = s.last, r !== null ? r.sibling = o : e.child = o, s.last = o)
            }
            return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = Cr(), e.sibling = null, r = gr.current, lr(gr, n ? r & 1 | 2 : r & 1), e) : (an(e), null);
        case 22:
        case 23:
            return r1(), n = e.memoizedState !== null, t !== null && t.memoizedState !== null !== n && (e.flags |= 8192), n && (e.mode & 1) !== 0 ? (Dn & 1073741824) !== 0 && (an(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : an(e), null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(be(156, e.tag))
}
var _b = Ss.ReactCurrentOwner,
    En = !1;

function vn(t, e, r, n) {
    e.child = t === null ? iw(e, null, r, n) : Aa(e, t.child, r, n)
}

function Zm(t, e, r, n, i) {
    r = r.render;
    var s = e.ref;
    return pa(e, i), n = Vp(t, e, r, n, s, i), r = Gp(), t !== null && !En ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, vs(t, e, i)) : (pr && r && zp(e), e.flags |= 1, vn(t, e, n, i), e.child)
}

function Jm(t, e, r, n, i) {
    if (t === null) {
        var s = r.type;
        return typeof s == "function" && !i1(s) && s.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (e.tag = 15, e.type = s, kw(t, e, s, n, i)) : (t = Bf(r.type, null, n, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t)
    }
    if (s = t.child, (t.lanes & i) === 0) {
        var o = s.memoizedProps;
        if (r = r.compare, r = r !== null ? r : il, r(o, n) && t.ref === e.ref) return vs(t, e, i)
    }
    return e.flags |= 1, t = to(s, n), t.ref = e.ref, t.return = e, e.child = t
}

function kw(t, e, r, n, i) {
    if (t !== null) {
        var s = t.memoizedProps;
        if (il(s, n) && t.ref === e.ref)
            if (En = !1, e.pendingProps = n = s, (t.lanes & i) !== 0)(t.flags & 131072) !== 0 && (En = !0);
            else return e.lanes = t.lanes, vs(t, e, i)
    }
    return Cd(t, e, r, n, i)
}

function Nw(t, e, r) {
    var n = e.pendingProps,
        i = n.children,
        s = t !== null ? t.memoizedState : null;
    if (n.mode === "hidden")
        if ((e.mode & 1) === 0) e.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, lr(aa, Dn), Dn |= r;
        else if ((r & 1073741824) !== 0) e.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
    }, n = s !== null ? s.baseLanes : r, lr(aa, Dn), Dn |= n;
    else return t = s !== null ? s.baseLanes | r : r, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }, e.updateQueue = null, lr(aa, Dn), Dn |= t, null;
    else s !== null ? (n = s.baseLanes | r, e.memoizedState = null) : n = r, lr(aa, Dn), Dn |= n;
    return vn(t, e, i, r), e.child
}

function Tw(t, e) {
    var r = e.ref;
    (t === null && r !== null || t !== null && t.ref !== r) && (e.flags |= 512, e.flags |= 2097152)
}

function Cd(t, e, r, n, i) {
    var s = Cn(r) ? Io : mn.current;
    return s = xa(e, s), pa(e, i), r = Vp(t, e, r, n, s, i), n = Gp(), t !== null && !En ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, vs(t, e, i)) : (pr && n && zp(e), e.flags |= 1, vn(t, e, r, i), e.child)
}

function Xm(t, e, r, n, i) {
    if (Cn(r)) {
        var s = !0;
        Jf(e)
    } else s = !1;
    if (pa(e, i), e.stateNode === null) t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2), ew(e, r, n), Sd(e, r, n, i), n = !0;
    else if (t === null) {
        var o = e.stateNode,
            a = e.memoizedProps;
        o.props = a;
        var c = o.context,
            d = r.contextType;
        typeof d == "object" && d !== null ? d = oi(d) : (d = Cn(r) ? Io : mn.current, d = xa(e, d));
        var y = r.getDerivedStateFromProps,
            I = typeof y == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        I || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== n || c !== d) && $m(e, o, n, d), ks = !1;
        var N = e.memoizedState;
        o.state = N, tc(e, n, o, i), c = e.memoizedState, a !== n || N !== c || In.current || ks ? (typeof y == "function" && (Ad(e, r, y, n), c = e.memoizedState), (a = ks || jm(e, r, a, n, N, c, d)) ? (I || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = n, e.memoizedState = c), o.props = n, o.state = c, o.context = d, n = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), n = !1)
    } else {
        o = e.stateNode, Jy(t, e), a = e.memoizedProps, d = e.type === e.elementType ? a : yi(e.type, a), o.props = d, I = e.pendingProps, N = o.context, c = r.contextType, typeof c == "object" && c !== null ? c = oi(c) : (c = Cn(r) ? Io : mn.current, c = xa(e, c));
        var E = r.getDerivedStateFromProps;
        (y = typeof E == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== I || N !== c) && $m(e, o, n, c), ks = !1, N = e.memoizedState, o.state = N, tc(e, n, o, i);
        var T = e.memoizedState;
        a !== I || N !== T || In.current || ks ? (typeof E == "function" && (Ad(e, r, E, n), T = e.memoizedState), (d = ks || jm(e, r, d, n, N, T, c) || !1) ? (y || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(n, T, c), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(n, T, c)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && N === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && N === t.memoizedState || (e.flags |= 1024), e.memoizedProps = n, e.memoizedState = T), o.props = n, o.state = T, o.context = c, n = d) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && N === t.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && N === t.memoizedState || (e.flags |= 1024), n = !1)
    }
    return Bd(t, e, r, n, s, i)
}

function Bd(t, e, r, n, i, s) {
    Tw(t, e);
    var o = (e.flags & 128) !== 0;
    if (!n && !o) return i && Fm(e, r, !1), vs(t, e, s);
    n = e.stateNode, _b.current = e;
    var a = o && typeof r.getDerivedStateFromError != "function" ? null : n.render();
    return e.flags |= 1, t !== null && o ? (e.child = Aa(e, t.child, null, s), e.child = Aa(e, null, a, s)) : vn(t, e, a, s), e.memoizedState = n.state, i && Fm(e, r, !0), e.child
}

function Ow(t) {
    var e = t.stateNode;
    e.pendingContext ? Lm(t, e.pendingContext, e.pendingContext !== e.context) : e.context && Lm(t, e.context, !1), Hp(t, e.containerInfo)
}

function ev(t, e, r, n, i) {
    return ba(), $p(i), e.flags |= 256, vn(t, e, r, n), e.child
}
var Jl = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};

function Xl(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}

function tv(t, e) {
    return {
        baseLanes: t.baseLanes | e,
        cachePool: null,
        transitions: t.transitions
    }
}

function Rw(t, e, r) {
    var n = e.pendingProps,
        i = gr.current,
        s = !1,
        o = (e.flags & 128) !== 0,
        a;
    if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), lr(gr, i & 1), t === null) return Ed(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? ((e.mode & 1) === 0 ? e.lanes = 1 : t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824, null) : (i = n.children, t = n.fallback, s ? (n = e.mode, s = e.child, i = {
        mode: "hidden",
        children: i
    }, (n & 1) === 0 && s !== null ? (s.childLanes = 0, s.pendingProps = i) : s = cc(i, n, 0, null), t = So(t, n, r, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = Xl(r), e.memoizedState = Jl, t) : kd(e, i));
    if (i = t.memoizedState, i !== null) {
        if (a = i.dehydrated, a !== null) {
            if (o) return e.flags & 256 ? (e.flags &= -257, ef(t, e, r, Error(be(422)))) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = n.fallback, i = e.mode, n = cc({
                mode: "visible",
                children: n.children
            }, i, 0, null), s = So(s, i, r, null), s.flags |= 2, n.return = e, s.return = e, n.sibling = s, e.child = n, (e.mode & 1) !== 0 && Aa(e, t.child, null, r), e.child.memoizedState = Xl(r), e.memoizedState = Jl, s);
            if ((e.mode & 1) === 0) e = ef(t, e, r, null);
            else if (a.data === "$!") e = ef(t, e, r, Error(be(419)));
            else if (n = (r & t.childLanes) !== 0, En || n) {
                if (n = Lr, n !== null) {
                    switch (r & -r) {
                        case 4:
                            s = 2;
                            break;
                        case 16:
                            s = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            s = 32;
                            break;
                        case 536870912:
                            s = 268435456;
                            break;
                        default:
                            s = 0
                    }
                    n = (s & (n.suspendedLanes | r)) !== 0 ? 0 : s, n !== 0 && n !== i.retryLane && (i.retryLane = n, ii(t, n, -1))
                }
                n1(), e = ef(t, e, r, Error(be(421)))
            } else a.data === "$?" ? (e.flags |= 128, e.child = t.child, e = Fb.bind(null, t), a._reactRetry = e, e = null) : (r = i.treeContext, Sn = us(a.nextSibling), Fn = e, pr = !0, bi = null, r !== null && (Zn[Jn++] = ls, Zn[Jn++] = fs, Zn[Jn++] = Co, ls = r.id, fs = r.overflow, Co = e), e = kd(e, e.pendingProps.children), e.flags |= 4096);
            return e
        }
        return s ? (n = nv(t, e, n.children, n.fallback, r), s = e.child, i = t.child.memoizedState, s.memoizedState = i === null ? Xl(r) : tv(i, r), s.childLanes = t.childLanes & ~r, e.memoizedState = Jl, n) : (r = rv(t, e, n.children, r), e.memoizedState = null, r)
    }
    return s ? (n = nv(t, e, n.children, n.fallback, r), s = e.child, i = t.child.memoizedState, s.memoizedState = i === null ? Xl(r) : tv(i, r), s.childLanes = t.childLanes & ~r, e.memoizedState = Jl, n) : (r = rv(t, e, n.children, r), e.memoizedState = null, r)
}

function kd(t, e) {
    return e = cc({
        mode: "visible",
        children: e
    }, t.mode, 0, null), e.return = t, t.child = e
}

function rv(t, e, r, n) {
    var i = t.child;
    return t = i.sibling, r = to(i, {
        mode: "visible",
        children: r
    }), (e.mode & 1) === 0 && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r
}

function nv(t, e, r, n, i) {
    var s = e.mode;
    t = t.child;
    var o = t.sibling,
        a = {
            mode: "hidden",
            children: r
        };
    return (s & 1) === 0 && e.child !== t ? (r = e.child, r.childLanes = 0, r.pendingProps = a, e.deletions = null) : (r = to(t, a), r.subtreeFlags = t.subtreeFlags & 14680064), o !== null ? n = to(o, n) : (n = So(n, s, i, null), n.flags |= 2), n.return = e, r.return = e, r.sibling = n, e.child = r, n
}

function ef(t, e, r, n) {
    return n !== null && $p(n), Aa(e, t.child, null, r), t = kd(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t
}

function iv(t, e, r) {
    t.lanes |= e;
    var n = t.alternate;
    n !== null && (n.lanes |= e), bd(t.return, e, r)
}

function s0(t, e, r, n, i) {
    var s = t.memoizedState;
    s === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: n,
        tail: r,
        tailMode: i
    } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = n, s.tail = r, s.tailMode = i)
}

function Dw(t, e, r) {
    var n = e.pendingProps,
        i = n.revealOrder,
        s = n.tail;
    if (vn(t, e, n.children, r), n = gr.current, (n & 2) !== 0) n = n & 1 | 2, e.flags |= 128;
    else {
        if (t !== null && (t.flags & 128) !== 0) e: for (t = e.child; t !== null;) {
            if (t.tag === 13) t.memoizedState !== null && iv(t, r, e);
            else if (t.tag === 19) iv(t, r, e);
            else if (t.child !== null) {
                t.child.return = t, t = t.child;
                continue
            }
            if (t === e) break e;
            for (; t.sibling === null;) {
                if (t.return === null || t.return === e) break e;
                t = t.return
            }
            t.sibling.return = t.return, t = t.sibling
        }
        n &= 1
    }
    if (lr(gr, n), (e.mode & 1) === 0) e.memoizedState = null;
    else switch (i) {
        case "forwards":
            for (r = e.child, i = null; r !== null;) t = r.alternate, t !== null && ic(t) === null && (i = r), r = r.sibling;
            r = i, r === null ? (i = e.child, e.child = null) : (i = r.sibling, r.sibling = null), s0(e, !1, i, r, s);
            break;
        case "backwards":
            for (r = null, i = e.child, e.child = null; i !== null;) {
                if (t = i.alternate, t !== null && ic(t) === null) {
                    e.child = i;
                    break
                }
                t = i.sibling, i.sibling = r, r = i, i = t
            }
            s0(e, !0, r, null, s);
            break;
        case "together":
            s0(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
    }
    return e.child
}

function vs(t, e, r) {
    if (t !== null && (e.dependencies = t.dependencies), ko |= e.lanes, (r & e.childLanes) === 0) return null;
    if (t !== null && e.child !== t.child) throw Error(be(153));
    if (e.child !== null) {
        for (t = e.child, r = to(t, t.pendingProps), e.child = r, r.return = e; t.sibling !== null;) t = t.sibling, r = r.sibling = to(t, t.pendingProps), r.return = e;
        r.sibling = null
    }
    return e.child
}

function Ib(t, e, r) {
    switch (e.tag) {
        case 3:
            Ow(e), ba();
            break;
        case 5:
            sw(e);
            break;
        case 1:
            Cn(e.type) && Jf(e);
            break;
        case 4:
            Hp(e, e.stateNode.containerInfo);
            break;
        case 10:
            var n = e.type._context,
                i = e.memoizedProps.value;
            lr(Xf, n._currentValue), n._currentValue = i;
            break;
        case 13:
            if (n = e.memoizedState, n !== null) return n.dehydrated !== null ? (lr(gr, gr.current & 1), e.flags |= 128, null) : (r & e.child.childLanes) !== 0 ? Rw(t, e, r) : (lr(gr, gr.current & 1), t = vs(t, e, r), t !== null ? t.sibling : null);
            lr(gr, gr.current & 1);
            break;
        case 19:
            if (n = (r & e.childLanes) !== 0, (t.flags & 128) !== 0) {
                if (n) return Dw(t, e, r);
                e.flags |= 128
            }
            if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), lr(gr, gr.current), n) break;
            return null;
        case 22:
        case 23:
            return e.lanes = 0, Nw(t, e, r)
    }
    return vs(t, e, r)
}

function Cb(t, e) {
    switch (jp(e), e.tag) {
        case 1:
            return Cn(e.type) && Zf(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
        case 3:
            return Sa(), hr(In), hr(mn), qp(), t = e.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (e.flags = t & -65537 | 128, e) : null;
        case 5:
            return Qp(e), null;
        case 13:
            if (hr(gr), t = e.memoizedState, t !== null && t.dehydrated !== null) {
                if (e.alternate === null) throw Error(be(340));
                ba()
            }
            return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
        case 19:
            return hr(gr), null;
        case 4:
            return Sa(), null;
        case 10:
            return Fp(e.type._context), null;
        case 22:
        case 23:
            return r1(), null;
        case 24:
            return null;
        default:
            return null
    }
}
var tf = !1,
    dn = !1,
    Bb = typeof WeakSet == "function" ? WeakSet : Set,
    $e = null;

function oa(t, e) {
    var r = t.ref;
    if (r !== null)
        if (typeof r == "function") try {
            r(null)
        } catch (n) {
            Er(t, e, n)
        } else r.current = null
}

function Nd(t, e, r) {
    try {
        r()
    } catch (n) {
        Er(t, e, n)
    }
}
var sv = !1;

function kb(t, e) {
    if (md = Vf, t = jy(), Dp(t)) {
        if ("selectionStart" in t) var r = {
            start: t.selectionStart,
            end: t.selectionEnd
        };
        else e: {
            r = (r = t.ownerDocument) && r.defaultView || window;
            var n = r.getSelection && r.getSelection();
            if (n && n.rangeCount !== 0) {
                r = n.anchorNode;
                var i = n.anchorOffset,
                    s = n.focusNode;
                n = n.focusOffset;
                try {
                    r.nodeType, s.nodeType
                } catch {
                    r = null;
                    break e
                }
                var o = 0,
                    a = -1,
                    c = -1,
                    d = 0,
                    y = 0,
                    I = t,
                    N = null;
                t: for (;;) {
                    for (var E; I !== r || i !== 0 && I.nodeType !== 3 || (a = o + i), I !== s || n !== 0 && I.nodeType !== 3 || (c = o + n), I.nodeType === 3 && (o += I.nodeValue.length), (E = I.firstChild) !== null;) N = I, I = E;
                    for (;;) {
                        if (I === t) break t;
                        if (N === r && ++d === i && (a = o), N === s && ++y === n && (c = o), (E = I.nextSibling) !== null) break;
                        I = N, N = I.parentNode
                    }
                    I = E
                }
                r = a === -1 || c === -1 ? null : {
                    start: a,
                    end: c
                }
            } else r = null
        }
        r = r || {
            start: 0,
            end: 0
        }
    } else r = null;
    for (vd = {
            focusedElem: t,
            selectionRange: r
        }, Vf = !1, $e = e; $e !== null;)
        if (e = $e, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, $e = t;
        else
            for (; $e !== null;) {
                e = $e;
                try {
                    var T = e.alternate;
                    if ((e.flags & 1024) !== 0) switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (T !== null) {
                                var j = T.memoizedProps,
                                    V = T.memoizedState,
                                    P = e.stateNode,
                                    O = P.getSnapshotBeforeUpdate(e.elementType === e.type ? j : yi(e.type, j), V);
                                P.__reactInternalSnapshotBeforeUpdate = O
                            }
                            break;
                        case 3:
                            var R = e.stateNode.containerInfo;
                            if (R.nodeType === 1) R.textContent = "";
                            else if (R.nodeType === 9) {
                                var q = R.body;
                                q != null && (q.textContent = "")
                            }
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(be(163))
                    }
                } catch (W) {
                    Er(e, e.return, W)
                }
                if (t = e.sibling, t !== null) {
                    t.return = e.return, $e = t;
                    break
                }
                $e = e.return
            }
    return T = sv, sv = !1, T
}

function Qu(t, e, r) {
    var n = e.updateQueue;
    if (n = n !== null ? n.lastEffect : null, n !== null) {
        var i = n = n.next;
        do {
            if ((i.tag & t) === t) {
                var s = i.destroy;
                i.destroy = void 0, s !== void 0 && Nd(e, r, s)
            }
            i = i.next
        } while (i !== n)
    }
}

function jc(t, e) {
    if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
        var r = e = e.next;
        do {
            if ((r.tag & t) === t) {
                var n = r.create;
                r.destroy = n()
            }
            r = r.next
        } while (r !== e)
    }
}

function Td(t) {
    var e = t.ref;
    if (e !== null) {
        var r = t.stateNode;
        switch (t.tag) {
            case 5:
                t = r;
                break;
            default:
                t = r
        }
        typeof e == "function" ? e(t) : e.current = t
    }
}

function Pw(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null, Pw(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[Di], delete e[al], delete e[wd], delete e[db], delete e[pb])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null
}

function Lw(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}

function ov(t) {
    e: for (;;) {
        for (; t.sibling === null;) {
            if (t.return === null || Lw(t.return)) return null;
            t = t.return
        }
        for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) {
            if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
            t.child.return = t, t = t.child
        }
        if (!(t.flags & 2)) return t.stateNode
    }
}

function Od(t, e, r) {
    var n = t.tag;
    if (n === 5 || n === 6) t = t.stateNode, e ? r.nodeType === 8 ? r.parentNode.insertBefore(t, e) : r.insertBefore(t, e) : (r.nodeType === 8 ? (e = r.parentNode, e.insertBefore(t, r)) : (e = r, e.appendChild(t)), r = r._reactRootContainer, r != null || e.onclick !== null || (e.onclick = Kf));
    else if (n !== 4 && (t = t.child, t !== null))
        for (Od(t, e, r), t = t.sibling; t !== null;) Od(t, e, r), t = t.sibling
}

function Rd(t, e, r) {
    var n = t.tag;
    if (n === 5 || n === 6) t = t.stateNode, e ? r.insertBefore(t, e) : r.appendChild(t);
    else if (n !== 4 && (t = t.child, t !== null))
        for (Rd(t, e, r), t = t.sibling; t !== null;) Rd(t, e, r), t = t.sibling
}
var Vr = null,
    xi = !1;

function Ms(t, e, r) {
    for (r = r.child; r !== null;) Fw(t, e, r), r = r.sibling
}

function Fw(t, e, r) {
    if (Li && typeof Li.onCommitFiberUnmount == "function") try {
        Li.onCommitFiberUnmount(Oc, r)
    } catch {}
    switch (r.tag) {
        case 5:
            dn || oa(r, e);
        case 6:
            var n = Vr,
                i = xi;
            Vr = null, Ms(t, e, r), Vr = n, xi = i, Vr !== null && (xi ? (t = Vr, r = r.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(r) : t.removeChild(r)) : Vr.removeChild(r.stateNode));
            break;
        case 18:
            Vr !== null && (xi ? (t = Vr, r = r.stateNode, t.nodeType === 8 ? Xh(t.parentNode, r) : t.nodeType === 1 && Xh(t, r), rl(t)) : Xh(Vr, r.stateNode));
            break;
        case 4:
            n = Vr, i = xi, Vr = r.stateNode.containerInfo, xi = !0, Ms(t, e, r), Vr = n, xi = i;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!dn && (n = r.updateQueue, n !== null && (n = n.lastEffect, n !== null))) {
                i = n = n.next;
                do {
                    var s = i,
                        o = s.destroy;
                    s = s.tag, o !== void 0 && ((s & 2) !== 0 || (s & 4) !== 0) && Nd(r, e, o), i = i.next
                } while (i !== n)
            }
            Ms(t, e, r);
            break;
        case 1:
            if (!dn && (oa(r, e), n = r.stateNode, typeof n.componentWillUnmount == "function")) try {
                n.props = r.memoizedProps, n.state = r.memoizedState, n.componentWillUnmount()
            } catch (a) {
                Er(r, e, a)
            }
            Ms(t, e, r);
            break;
        case 21:
            Ms(t, e, r);
            break;
        case 22:
            r.mode & 1 ? (dn = (n = dn) || r.memoizedState !== null, Ms(t, e, r), dn = n) : Ms(t, e, r);
            break;
        default:
            Ms(t, e, r)
    }
}

function av(t) {
    var e = t.updateQueue;
    if (e !== null) {
        t.updateQueue = null;
        var r = t.stateNode;
        r === null && (r = t.stateNode = new Bb), e.forEach(function(n) {
            var i = Ub.bind(null, t, n);
            r.has(n) || (r.add(n), n.then(i, i))
        })
    }
}

function hi(t, e) {
    var r = e.deletions;
    if (r !== null)
        for (var n = 0; n < r.length; n++) {
            var i = r[n];
            try {
                var s = t,
                    o = e,
                    a = o;
                e: for (; a !== null;) {
                    switch (a.tag) {
                        case 5:
                            Vr = a.stateNode, xi = !1;
                            break e;
                        case 3:
                            Vr = a.stateNode.containerInfo, xi = !0;
                            break e;
                        case 4:
                            Vr = a.stateNode.containerInfo, xi = !0;
                            break e
                    }
                    a = a.return
                }
                if (Vr === null) throw Error(be(160));
                Fw(s, o, i), Vr = null, xi = !1;
                var c = i.alternate;
                c !== null && (c.return = null), i.return = null
            } catch (d) {
                Er(i, e, d)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null;) Uw(e, t), e = e.sibling
}

function Uw(t, e) {
    var r = t.alternate,
        n = t.flags;
    switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (hi(e, t), Ni(t), n & 4) {
                try {
                    Qu(3, t, t.return), jc(3, t)
                } catch (T) {
                    Er(t, t.return, T)
                }
                try {
                    Qu(5, t, t.return)
                } catch (T) {
                    Er(t, t.return, T)
                }
            }
            break;
        case 1:
            hi(e, t), Ni(t), n & 512 && r !== null && oa(r, r.return);
            break;
        case 5:
            if (hi(e, t), Ni(t), n & 512 && r !== null && oa(r, r.return), t.flags & 32) {
                var i = t.stateNode;
                try {
                    Ju(i, "")
                } catch (T) {
                    Er(t, t.return, T)
                }
            }
            if (n & 4 && (i = t.stateNode, i != null)) {
                var s = t.memoizedProps,
                    o = r !== null ? r.memoizedProps : s,
                    a = t.type,
                    c = t.updateQueue;
                if (t.updateQueue = null, c !== null) try {
                    a === "input" && s.type === "radio" && s.name != null && uy(i, s), sd(a, o);
                    var d = sd(a, s);
                    for (o = 0; o < c.length; o += 2) {
                        var y = c[o],
                            I = c[o + 1];
                        y === "style" ? dy(i, I) : y === "dangerouslySetInnerHTML" ? cy(i, I) : y === "children" ? Ju(i, I) : Ap(i, y, I, d)
                    }
                    switch (a) {
                        case "input":
                            ed(i, s);
                            break;
                        case "textarea":
                            ly(i, s);
                            break;
                        case "select":
                            var N = i._wrapperState.wasMultiple;
                            i._wrapperState.wasMultiple = !!s.multiple;
                            var E = s.value;
                            E != null ? fa(i, !!s.multiple, E, !1) : N !== !!s.multiple && (s.defaultValue != null ? fa(i, !!s.multiple, s.defaultValue, !0) : fa(i, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    i[al] = s
                } catch (T) {
                    Er(t, t.return, T)
                }
            }
            break;
        case 6:
            if (hi(e, t), Ni(t), n & 4) {
                if (t.stateNode === null) throw Error(be(162));
                d = t.stateNode, y = t.memoizedProps;
                try {
                    d.nodeValue = y
                } catch (T) {
                    Er(t, t.return, T)
                }
            }
            break;
        case 3:
            if (hi(e, t), Ni(t), n & 4 && r !== null && r.memoizedState.isDehydrated) try {
                rl(e.containerInfo)
            } catch (T) {
                Er(t, t.return, T)
            }
            break;
        case 4:
            hi(e, t), Ni(t);
            break;
        case 13:
            hi(e, t), Ni(t), d = t.child, d.flags & 8192 && d.memoizedState !== null && (d.alternate === null || d.alternate.memoizedState === null) && (e1 = Cr()), n & 4 && av(t);
            break;
        case 22:
            if (d = r !== null && r.memoizedState !== null, t.mode & 1 ? (dn = (y = dn) || d, hi(e, t), dn = y) : hi(e, t), Ni(t), n & 8192) {
                y = t.memoizedState !== null;
                e: for (I = null, N = t;;) {
                    if (N.tag === 5) {
                        if (I === null) {
                            I = N;
                            try {
                                i = N.stateNode, y ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = N.stateNode, c = N.memoizedProps.style, o = c != null && c.hasOwnProperty("display") ? c.display : null, a.style.display = hy("display", o))
                            } catch (T) {
                                Er(t, t.return, T)
                            }
                        }
                    } else if (N.tag === 6) {
                        if (I === null) try {
                            N.stateNode.nodeValue = y ? "" : N.memoizedProps
                        } catch (T) {
                            Er(t, t.return, T)
                        }
                    } else if ((N.tag !== 22 && N.tag !== 23 || N.memoizedState === null || N === t) && N.child !== null) {
                        N.child.return = N, N = N.child;
                        continue
                    }
                    if (N === t) break e;
                    for (; N.sibling === null;) {
                        if (N.return === null || N.return === t) break e;
                        I === N && (I = null), N = N.return
                    }
                    I === N && (I = null), N.sibling.return = N.return, N = N.sibling
                }
                if (y && !d && (t.mode & 1) !== 0)
                    for ($e = t, t = t.child; t !== null;) {
                        for (d = $e = t; $e !== null;) {
                            switch (y = $e, I = y.child, y.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    Qu(4, y, y.return);
                                    break;
                                case 1:
                                    if (oa(y, y.return), s = y.stateNode, typeof s.componentWillUnmount == "function") {
                                        N = y, E = y.return;
                                        try {
                                            i = N, s.props = i.memoizedProps, s.state = i.memoizedState, s.componentWillUnmount()
                                        } catch (T) {
                                            Er(N, E, T)
                                        }
                                    }
                                    break;
                                case 5:
                                    oa(y, y.return);
                                    break;
                                case 22:
                                    if (y.memoizedState !== null) {
                                        lv(d);
                                        continue
                                    }
                            }
                            I !== null ? (I.return = y, $e = I) : lv(d)
                        }
                        t = t.sibling
                    }
            }
            break;
        case 19:
            hi(e, t), Ni(t), n & 4 && av(t);
            break;
        case 21:
            break;
        default:
            hi(e, t), Ni(t)
    }
}

function Ni(t) {
    var e = t.flags;
    if (e & 2) {
        try {
            e: {
                for (var r = t.return; r !== null;) {
                    if (Lw(r)) {
                        var n = r;
                        break e
                    }
                    r = r.return
                }
                throw Error(be(160))
            }
            switch (n.tag) {
                case 5:
                    var i = n.stateNode;
                    n.flags & 32 && (Ju(i, ""), n.flags &= -33);
                    var s = ov(t);
                    Rd(t, s, i);
                    break;
                case 3:
                case 4:
                    var o = n.stateNode.containerInfo,
                        a = ov(t);
                    Od(t, a, o);
                    break;
                default:
                    throw Error(be(161))
            }
        }
        catch (c) {
            Er(t, t.return, c)
        }
        t.flags &= -3
    }
    e & 4096 && (t.flags &= -4097)
}

function Nb(t, e, r) {
    $e = t, zw(t)
}

function zw(t, e, r) {
    for (var n = (t.mode & 1) !== 0; $e !== null;) {
        var i = $e,
            s = i.child;
        if (i.tag === 22 && n) {
            var o = i.memoizedState !== null || tf;
            if (!o) {
                var a = i.alternate,
                    c = a !== null && a.memoizedState !== null || dn;
                a = tf;
                var d = dn;
                if (tf = o, (dn = c) && !d)
                    for ($e = i; $e !== null;) o = $e, c = o.child, o.tag === 22 && o.memoizedState !== null ? fv(i) : c !== null ? (c.return = o, $e = c) : fv(i);
                for (; s !== null;) $e = s, zw(s), s = s.sibling;
                $e = i, tf = a, dn = d
            }
            uv(t)
        } else(i.subtreeFlags & 8772) !== 0 && s !== null ? (s.return = i, $e = s) : uv(t)
    }
}

function uv(t) {
    for (; $e !== null;) {
        var e = $e;
        if ((e.flags & 8772) !== 0) {
            var r = e.alternate;
            try {
                if ((e.flags & 8772) !== 0) switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        dn || jc(5, e);
                        break;
                    case 1:
                        var n = e.stateNode;
                        if (e.flags & 4 && !dn)
                            if (r === null) n.componentDidMount();
                            else {
                                var i = e.elementType === e.type ? r.memoizedProps : yi(e.type, r.memoizedProps);
                                n.componentDidUpdate(i, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && zm(e, s, n);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (r = null, e.child !== null) switch (e.child.tag) {
                                case 5:
                                    r = e.child.stateNode;
                                    break;
                                case 1:
                                    r = e.child.stateNode
                            }
                            zm(e, o, r)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (r === null && e.flags & 4) {
                            r = a;
                            var c = e.memoizedProps;
                            switch (e.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    c.autoFocus && r.focus();
                                    break;
                                case "img":
                                    c.src && (r.src = c.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var d = e.alternate;
                            if (d !== null) {
                                var y = d.memoizedState;
                                if (y !== null) {
                                    var I = y.dehydrated;
                                    I !== null && rl(I)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                        break;
                    default:
                        throw Error(be(163))
                }
                dn || e.flags & 512 && Td(e)
            } catch (N) {
                Er(e, e.return, N)
            }
        }
        if (e === t) {
            $e = null;
            break
        }
        if (r = e.sibling, r !== null) {
            r.return = e.return, $e = r;
            break
        }
        $e = e.return
    }
}

function lv(t) {
    for (; $e !== null;) {
        var e = $e;
        if (e === t) {
            $e = null;
            break
        }
        var r = e.sibling;
        if (r !== null) {
            r.return = e.return, $e = r;
            break
        }
        $e = e.return
    }
}

function fv(t) {
    for (; $e !== null;) {
        var e = $e;
        try {
            switch (e.tag) {
                case 0:
                case 11:
                case 15:
                    var r = e.return;
                    try {
                        jc(4, e)
                    } catch (c) {
                        Er(e, r, c)
                    }
                    break;
                case 1:
                    var n = e.stateNode;
                    if (typeof n.componentDidMount == "function") {
                        var i = e.return;
                        try {
                            n.componentDidMount()
                        } catch (c) {
                            Er(e, i, c)
                        }
                    }
                    var s = e.return;
                    try {
                        Td(e)
                    } catch (c) {
                        Er(e, s, c)
                    }
                    break;
                case 5:
                    var o = e.return;
                    try {
                        Td(e)
                    } catch (c) {
                        Er(e, o, c)
                    }
            }
        } catch (c) {
            Er(e, e.return, c)
        }
        if (e === t) {
            $e = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return, $e = a;
            break
        }
        $e = e.return
    }
}
var Tb = Math.ceil,
    ac = Ss.ReactCurrentDispatcher,
    Jp = Ss.ReactCurrentOwner,
    ni = Ss.ReactCurrentBatchConfig,
    Vt = 0,
    Lr = null,
    kr = null,
    Zr = 0,
    Dn = 0,
    aa = so(0),
    Dr = 0,
    dl = null,
    ko = 0,
    $c = 0,
    Xp = 0,
    qu = null,
    An = null,
    e1 = 0,
    Ma = 1 / 0,
    ss = null,
    uc = !1,
    Dd = null,
    Ks = null,
    rf = !1,
    zs = null,
    lc = 0,
    Wu = 0,
    Pd = null,
    If = -1,
    Cf = 0;

function wn() {
    return (Vt & 6) !== 0 ? Cr() : If !== -1 ? If : If = Cr()
}

function Zs(t) {
    return (t.mode & 1) === 0 ? 1 : (Vt & 2) !== 0 && Zr !== 0 ? Zr & -Zr : vb.transition !== null ? (Cf === 0 && (Cf = Ey()), Cf) : (t = sr, t !== 0 || (t = window.event, t = t === void 0 ? 16 : Ty(t.type)), t)
}

function ii(t, e, r) {
    if (50 < Wu) throw Wu = 0, Pd = null, Error(be(185));
    var n = Hc(t, e);
    return n === null ? null : (yl(n, e, r), ((Vt & 2) === 0 || n !== Lr) && (n === Lr && ((Vt & 2) === 0 && ($c |= e), Dr === 4 && Ps(n, Zr)), Bn(n, r), e === 1 && Vt === 0 && (t.mode & 1) === 0 && (Ma = Cr() + 500, Fc && oo())), n)
}

function Hc(t, e) {
    t.lanes |= e;
    var r = t.alternate;
    for (r !== null && (r.lanes |= e), r = t, t = t.return; t !== null;) t.childLanes |= e, r = t.alternate, r !== null && (r.childLanes |= e), r = t, t = t.return;
    return r.tag === 3 ? r.stateNode : null
}

function jw(t) {
    return (Lr !== null || Ai !== null) && (t.mode & 1) !== 0 && (Vt & 2) === 0
}

function Bn(t, e) {
    var r = t.callbackNode;
    v4(t, e);
    var n = Wf(t, t === Lr ? Zr : 0);
    if (n === 0) r !== null && vm(r), t.callbackNode = null, t.callbackPriority = 0;
    else if (e = n & -n, t.callbackPriority !== e) {
        if (r != null && vm(r), e === 1) t.tag === 0 ? mb(cv.bind(null, t)) : Zy(cv.bind(null, t)), cb(function() {
            Vt === 0 && oo()
        }), r = null;
        else {
            switch (_y(n)) {
                case 1:
                    r = Ip;
                    break;
                case 4:
                    r = Sy;
                    break;
                case 16:
                    r = qf;
                    break;
                case 536870912:
                    r = My;
                    break;
                default:
                    r = qf
            }
            r = Yw(r, $w.bind(null, t))
        }
        t.callbackPriority = e, t.callbackNode = r
    }
}

function $w(t, e) {
    if (If = -1, Cf = 0, (Vt & 6) !== 0) throw Error(be(327));
    var r = t.callbackNode;
    if (ma() && t.callbackNode !== r) return null;
    var n = Wf(t, t === Lr ? Zr : 0);
    if (n === 0) return null;
    if ((n & 30) !== 0 || (n & t.expiredLanes) !== 0 || e) e = fc(t, n);
    else {
        e = n;
        var i = Vt;
        Vt |= 2;
        var s = Qw();
        (Lr !== t || Zr !== e) && (ss = null, Ma = Cr() + 500, Ao(t, e));
        do try {
            Db();
            break
        } catch (a) {
            Hw(t, a)
        }
        while (1);
        Lp(), ac.current = s, Vt = i, kr !== null ? e = 0 : (Lr = null, Zr = 0, e = Dr)
    }
    if (e !== 0) {
        if (e === 2 && (i = fd(t), i !== 0 && (n = i, e = Ld(t, i))), e === 1) throw r = dl, Ao(t, 0), Ps(t, n), Bn(t, Cr()), r;
        if (e === 6) Ps(t, n);
        else {
            if (i = t.current.alternate, (n & 30) === 0 && !Ob(i) && (e = fc(t, n), e === 2 && (s = fd(t), s !== 0 && (n = s, e = Ld(t, s))), e === 1)) throw r = dl, Ao(t, 0), Ps(t, n), Bn(t, Cr()), r;
            switch (t.finishedWork = i, t.finishedLanes = n, e) {
                case 0:
                case 1:
                    throw Error(be(345));
                case 2:
                    po(t, An, ss);
                    break;
                case 3:
                    if (Ps(t, n), (n & 130023424) === n && (e = e1 + 500 - Cr(), 10 < e)) {
                        if (Wf(t, 0) !== 0) break;
                        if (i = t.suspendedLanes, (i & n) !== n) {
                            wn(), t.pingedLanes |= t.suspendedLanes & i;
                            break
                        }
                        t.timeoutHandle = yd(po.bind(null, t, An, ss), e);
                        break
                    }
                    po(t, An, ss);
                    break;
                case 4:
                    if (Ps(t, n), (n & 4194240) === n) break;
                    for (e = t.eventTimes, i = -1; 0 < n;) {
                        var o = 31 - Mi(n);
                        s = 1 << o, o = e[o], o > i && (i = o), n &= ~s
                    }
                    if (n = i, n = Cr() - n, n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * Tb(n / 1960)) - n, 10 < n) {
                        t.timeoutHandle = yd(po.bind(null, t, An, ss), n);
                        break
                    }
                    po(t, An, ss);
                    break;
                case 5:
                    po(t, An, ss);
                    break;
                default:
                    throw Error(be(329))
            }
        }
    }
    return Bn(t, Cr()), t.callbackNode === r ? $w.bind(null, t) : null
}

function Ld(t, e) {
    var r = qu;
    return t.current.memoizedState.isDehydrated && (Ao(t, e).flags |= 256), t = fc(t, e), t !== 2 && (e = An, An = r, e !== null && Fd(e)), t
}

function Fd(t) {
    An === null ? An = t : An.push.apply(An, t)
}

function Ob(t) {
    for (var e = t;;) {
        if (e.flags & 16384) {
            var r = e.updateQueue;
            if (r !== null && (r = r.stores, r !== null))
                for (var n = 0; n < r.length; n++) {
                    var i = r[n],
                        s = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!_i(s(), i)) return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (r = e.child, e.subtreeFlags & 16384 && r !== null) r.return = e, e = r;
        else {
            if (e === t) break;
            for (; e.sibling === null;) {
                if (e.return === null || e.return === t) return !0;
                e = e.return
            }
            e.sibling.return = e.return, e = e.sibling
        }
    }
    return !0
}

function Ps(t, e) {
    for (e &= ~Xp, e &= ~$c, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) {
        var r = 31 - Mi(e),
            n = 1 << r;
        t[r] = -1, e &= ~n
    }
}

function cv(t) {
    if ((Vt & 6) !== 0) throw Error(be(327));
    ma();
    var e = Wf(t, 0);
    if ((e & 1) === 0) return Bn(t, Cr()), null;
    var r = fc(t, e);
    if (t.tag !== 0 && r === 2) {
        var n = fd(t);
        n !== 0 && (e = n, r = Ld(t, n))
    }
    if (r === 1) throw r = dl, Ao(t, 0), Ps(t, e), Bn(t, Cr()), r;
    if (r === 6) throw Error(be(345));
    return t.finishedWork = t.current.alternate, t.finishedLanes = e, po(t, An, ss), Bn(t, Cr()), null
}

function t1(t, e) {
    var r = Vt;
    Vt |= 1;
    try {
        return t(e)
    } finally {
        Vt = r, Vt === 0 && (Ma = Cr() + 500, Fc && oo())
    }
}

function No(t) {
    zs !== null && zs.tag === 0 && (Vt & 6) === 0 && ma();
    var e = Vt;
    Vt |= 1;
    var r = ni.transition,
        n = sr;
    try {
        if (ni.transition = null, sr = 1, t) return t()
    } finally {
        sr = n, ni.transition = r, Vt = e, (Vt & 6) === 0 && oo()
    }
}

function r1() {
    Dn = aa.current, hr(aa)
}

function Ao(t, e) {
    t.finishedWork = null, t.finishedLanes = 0;
    var r = t.timeoutHandle;
    if (r !== -1 && (t.timeoutHandle = -1, fb(r)), kr !== null)
        for (r = kr.return; r !== null;) {
            var n = r;
            switch (jp(n), n.tag) {
                case 1:
                    n = n.type.childContextTypes, n != null && Zf();
                    break;
                case 3:
                    Sa(), hr(In), hr(mn), qp();
                    break;
                case 5:
                    Qp(n);
                    break;
                case 4:
                    Sa();
                    break;
                case 13:
                    hr(gr);
                    break;
                case 19:
                    hr(gr);
                    break;
                case 10:
                    Fp(n.type._context);
                    break;
                case 22:
                case 23:
                    r1()
            }
            r = r.return
        }
    if (Lr = t, kr = t = to(t.current, null), Zr = Dn = e, Dr = 0, dl = null, Xp = $c = ko = 0, An = qu = null, Ai !== null) {
        for (e = 0; e < Ai.length; e++)
            if (r = Ai[e], n = r.interleaved, n !== null) {
                r.interleaved = null;
                var i = n.next,
                    s = r.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = i, n.next = o
                }
                r.pending = n
            }
        Ai = null
    }
    return t
}

function Hw(t, e) {
    do {
        var r = kr;
        try {
            if (Lp(), Ef.current = oc, sc) {
                for (var n = wr.memoizedState; n !== null;) {
                    var i = n.queue;
                    i !== null && (i.pending = null), n = n.next
                }
                sc = !1
            }
            if (Bo = 0, zr = Or = wr = null, Hu = !1, fl = 0, Jp.current = null, r === null || r.return === null) {
                Dr = 1, dl = e, kr = null;
                break
            }
            e: {
                var s = t,
                    o = r.return,
                    a = r,
                    c = e;
                if (e = Zr, a.flags |= 32768, c !== null && typeof c == "object" && typeof c.then == "function") {
                    var d = c,
                        y = a,
                        I = y.tag;
                    if ((y.mode & 1) === 0 && (I === 0 || I === 11 || I === 15)) {
                        var N = y.alternate;
                        N ? (y.updateQueue = N.updateQueue, y.memoizedState = N.memoizedState, y.lanes = N.lanes) : (y.updateQueue = null, y.memoizedState = null)
                    }
                    var E = Ym(o);
                    if (E !== null) {
                        E.flags &= -257, Km(E, o, a, s, e), E.mode & 1 && Gm(s, d, e), e = E, c = d;
                        var T = e.updateQueue;
                        if (T === null) {
                            var j = new Set;
                            j.add(c), e.updateQueue = j
                        } else T.add(c);
                        break e
                    } else {
                        if ((e & 1) === 0) {
                            Gm(s, d, e), n1();
                            break e
                        }
                        c = Error(be(426))
                    }
                } else if (pr && a.mode & 1) {
                    var V = Ym(o);
                    if (V !== null) {
                        (V.flags & 65536) === 0 && (V.flags |= 256), Km(V, o, a, s, e), $p(c);
                        break e
                    }
                }
                s = c,
                Dr !== 4 && (Dr = 2),
                qu === null ? qu = [s] : qu.push(s),
                c = Zp(c, a),
                a = o;do {
                    switch (a.tag) {
                        case 3:
                            a.flags |= 65536, e &= -e, a.lanes |= e;
                            var P = Ew(a, c, e);
                            Um(a, P);
                            break e;
                        case 1:
                            s = c;
                            var O = a.type,
                                R = a.stateNode;
                            if ((a.flags & 128) === 0 && (typeof O.getDerivedStateFromError == "function" || R !== null && typeof R.componentDidCatch == "function" && (Ks === null || !Ks.has(R)))) {
                                a.flags |= 65536, e &= -e, a.lanes |= e;
                                var q = _w(a, s, e);
                                Um(a, q);
                                break e
                            }
                    }
                    a = a.return
                } while (a !== null)
            }
            Ww(r)
        } catch (W) {
            e = W, kr === r && r !== null && (kr = r = r.return);
            continue
        }
        break
    } while (1)
}

function Qw() {
    var t = ac.current;
    return ac.current = oc, t === null ? oc : t
}

function n1() {
    (Dr === 0 || Dr === 3 || Dr === 2) && (Dr = 4), Lr === null || (ko & 268435455) === 0 && ($c & 268435455) === 0 || Ps(Lr, Zr)
}

function fc(t, e) {
    var r = Vt;
    Vt |= 2;
    var n = Qw();
    (Lr !== t || Zr !== e) && (ss = null, Ao(t, e));
    do try {
        Rb();
        break
    } catch (i) {
        Hw(t, i)
    }
    while (1);
    if (Lp(), Vt = r, ac.current = n, kr !== null) throw Error(be(261));
    return Lr = null, Zr = 0, Dr
}

function Rb() {
    for (; kr !== null;) qw(kr)
}

function Db() {
    for (; kr !== null && !a4();) qw(kr)
}

function qw(t) {
    var e = Gw(t.alternate, t, Dn);
    t.memoizedProps = t.pendingProps, e === null ? Ww(t) : kr = e, Jp.current = null
}

function Ww(t) {
    var e = t;
    do {
        var r = e.alternate;
        if (t = e.return, (e.flags & 32768) === 0) {
            if (r = Eb(r, e, Dn), r !== null) {
                kr = r;
                return
            }
        } else {
            if (r = Cb(r, e), r !== null) {
                r.flags &= 32767, kr = r;
                return
            }
            if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
            else {
                Dr = 6, kr = null;
                return
            }
        }
        if (e = e.sibling, e !== null) {
            kr = e;
            return
        }
        kr = e = t
    } while (e !== null);
    Dr === 0 && (Dr = 5)
}

function po(t, e, r) {
    var n = sr,
        i = ni.transition;
    try {
        ni.transition = null, sr = 1, Pb(t, e, r, n)
    } finally {
        ni.transition = i, sr = n
    }
    return null
}

function Pb(t, e, r, n) {
    do ma(); while (zs !== null);
    if ((Vt & 6) !== 0) throw Error(be(327));
    r = t.finishedWork;
    var i = t.finishedLanes;
    if (r === null) return null;
    if (t.finishedWork = null, t.finishedLanes = 0, r === t.current) throw Error(be(177));
    t.callbackNode = null, t.callbackPriority = 0;
    var s = r.lanes | r.childLanes;
    if (g4(t, s), t === Lr && (kr = Lr = null, Zr = 0), (r.subtreeFlags & 2064) === 0 && (r.flags & 2064) === 0 || rf || (rf = !0, Yw(qf, function() {
            return ma(), null
        })), s = (r.flags & 15990) !== 0, (r.subtreeFlags & 15990) !== 0 || s) {
        s = ni.transition, ni.transition = null;
        var o = sr;
        sr = 1;
        var a = Vt;
        Vt |= 4, Jp.current = null, kb(t, r), Uw(r, t), nb(vd), Vf = !!md, vd = md = null, t.current = r, Nb(r), u4(), Vt = a, sr = o, ni.transition = s
    } else t.current = r;
    if (rf && (rf = !1, zs = t, lc = i), s = t.pendingLanes, s === 0 && (Ks = null), c4(r.stateNode), Bn(t, Cr()), e !== null)
        for (n = t.onRecoverableError, r = 0; r < e.length; r++) n(e[r]);
    if (uc) throw uc = !1, t = Dd, Dd = null, t;
    return (lc & 1) !== 0 && t.tag !== 0 && ma(), s = t.pendingLanes, (s & 1) !== 0 ? t === Pd ? Wu++ : (Wu = 0, Pd = t) : Wu = 0, oo(), null
}

function ma() {
    if (zs !== null) {
        var t = _y(lc),
            e = ni.transition,
            r = sr;
        try {
            if (ni.transition = null, sr = 16 > t ? 16 : t, zs === null) var n = !1;
            else {
                if (t = zs, zs = null, lc = 0, (Vt & 6) !== 0) throw Error(be(331));
                var i = Vt;
                for (Vt |= 4, $e = t.current; $e !== null;) {
                    var s = $e,
                        o = s.child;
                    if (($e.flags & 16) !== 0) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var c = 0; c < a.length; c++) {
                                var d = a[c];
                                for ($e = d; $e !== null;) {
                                    var y = $e;
                                    switch (y.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Qu(8, y, s)
                                    }
                                    var I = y.child;
                                    if (I !== null) I.return = y, $e = I;
                                    else
                                        for (; $e !== null;) {
                                            y = $e;
                                            var N = y.sibling,
                                                E = y.return;
                                            if (Pw(y), y === d) {
                                                $e = null;
                                                break
                                            }
                                            if (N !== null) {
                                                N.return = E, $e = N;
                                                break
                                            }
                                            $e = E
                                        }
                                }
                            }
                            var T = s.alternate;
                            if (T !== null) {
                                var j = T.child;
                                if (j !== null) {
                                    T.child = null;
                                    do {
                                        var V = j.sibling;
                                        j.sibling = null, j = V
                                    } while (j !== null)
                                }
                            }
                            $e = s
                        }
                    }
                    if ((s.subtreeFlags & 2064) !== 0 && o !== null) o.return = s, $e = o;
                    else e: for (; $e !== null;) {
                        if (s = $e, (s.flags & 2048) !== 0) switch (s.tag) {
                            case 0:
                            case 11:
                            case 15:
                                Qu(9, s, s.return)
                        }
                        var P = s.sibling;
                        if (P !== null) {
                            P.return = s.return, $e = P;
                            break e
                        }
                        $e = s.return
                    }
                }
                var O = t.current;
                for ($e = O; $e !== null;) {
                    o = $e;
                    var R = o.child;
                    if ((o.subtreeFlags & 2064) !== 0 && R !== null) R.return = o, $e = R;
                    else e: for (o = O; $e !== null;) {
                        if (a = $e, (a.flags & 2048) !== 0) try {
                            switch (a.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    jc(9, a)
                            }
                        } catch (W) {
                            Er(a, a.return, W)
                        }
                        if (a === o) {
                            $e = null;
                            break e
                        }
                        var q = a.sibling;
                        if (q !== null) {
                            q.return = a.return, $e = q;
                            break e
                        }
                        $e = a.return
                    }
                }
                if (Vt = i, oo(), Li && typeof Li.onPostCommitFiberRoot == "function") try {
                    Li.onPostCommitFiberRoot(Oc, t)
                } catch {}
                n = !0
            }
            return n
        } finally {
            sr = r, ni.transition = e
        }
    }
    return !1
}

function hv(t, e, r) {
    e = Zp(r, e), e = Ew(t, e, 1), Ys(t, e), e = wn(), t = Hc(t, 1), t !== null && (yl(t, 1, e), Bn(t, e))
}

function Er(t, e, r) {
    if (t.tag === 3) hv(t, t, r);
    else
        for (; e !== null;) {
            if (e.tag === 3) {
                hv(e, t, r);
                break
            } else if (e.tag === 1) {
                var n = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (Ks === null || !Ks.has(n))) {
                    t = Zp(r, t), t = _w(e, t, 1), Ys(e, t), t = wn(), e = Hc(e, 1), e !== null && (yl(e, 1, t), Bn(e, t));
                    break
                }
            }
            e = e.return
        }
}

function Lb(t, e, r) {
    var n = t.pingCache;
    n !== null && n.delete(e), e = wn(), t.pingedLanes |= t.suspendedLanes & r, Lr === t && (Zr & r) === r && (Dr === 4 || Dr === 3 && (Zr & 130023424) === Zr && 500 > Cr() - e1 ? Ao(t, 0) : Xp |= r), Bn(t, e)
}

function Vw(t, e) {
    e === 0 && ((t.mode & 1) === 0 ? e = 1 : (e = ql, ql <<= 1, (ql & 130023424) === 0 && (ql = 4194304)));
    var r = wn();
    t = Hc(t, e), t !== null && (yl(t, e, r), Bn(t, r))
}

function Fb(t) {
    var e = t.memoizedState,
        r = 0;
    e !== null && (r = e.retryLane), Vw(t, r)
}

function Ub(t, e) {
    var r = 0;
    switch (t.tag) {
        case 13:
            var n = t.stateNode,
                i = t.memoizedState;
            i !== null && (r = i.retryLane);
            break;
        case 19:
            n = t.stateNode;
            break;
        default:
            throw Error(be(314))
    }
    n !== null && n.delete(e), Vw(t, r)
}
var Gw;
Gw = function(t, e, r) {
    if (t !== null)
        if (t.memoizedProps !== e.pendingProps || In.current) En = !0;
        else {
            if ((t.lanes & r) === 0 && (e.flags & 128) === 0) return En = !1, Ib(t, e, r);
            En = (t.flags & 131072) !== 0
        }
    else En = !1, pr && (e.flags & 1048576) !== 0 && tw(e, nc, e.index);
    switch (e.lanes = 0, e.tag) {
        case 2:
            var n = e.type;
            t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2), t = e.pendingProps;
            var i = xa(e, mn.current);
            pa(e, r), i = Vp(null, e, n, t, i, r);
            var s = Gp();
            return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Cn(n) ? (s = !0, Jf(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, Up(e), i.updater = Uc, e.stateNode = i, i._reactInternals = e, Sd(e, n, t, r), e = Bd(null, e, n, !0, s, r)) : (e.tag = 0, pr && s && zp(e), vn(null, e, i, r), e = e.child), e;
        case 16:
            n = e.elementType;
            e: {
                switch (t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2), t = e.pendingProps, i = n._init, n = i(n._payload), e.type = n, i = e.tag = jb(n), t = yi(n, t), i) {
                    case 0:
                        e = Cd(null, e, n, t, r);
                        break e;
                    case 1:
                        e = Xm(null, e, n, t, r);
                        break e;
                    case 11:
                        e = Zm(null, e, n, t, r);
                        break e;
                    case 14:
                        e = Jm(null, e, n, yi(n.type, t), r);
                        break e
                }
                throw Error(be(306, n, ""))
            }
            return e;
        case 0:
            return n = e.type, i = e.pendingProps, i = e.elementType === n ? i : yi(n, i), Cd(t, e, n, i, r);
        case 1:
            return n = e.type, i = e.pendingProps, i = e.elementType === n ? i : yi(n, i), Xm(t, e, n, i, r);
        case 3:
            e: {
                if (Ow(e), t === null) throw Error(be(387));n = e.pendingProps,
                s = e.memoizedState,
                i = s.element,
                Jy(t, e),
                tc(e, n, null, r);
                var o = e.memoizedState;
                if (n = o.element, s.isDehydrated)
                    if (s = {
                            element: n,
                            isDehydrated: !1,
                            cache: o.cache,
                            pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                            transitions: o.transitions
                        }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
                        i = Error(be(423)), e = ev(t, e, n, r, i);
                        break e
                    } else if (n !== i) {
                    i = Error(be(424)), e = ev(t, e, n, r, i);
                    break e
                } else
                    for (Sn = us(e.stateNode.containerInfo.firstChild), Fn = e, pr = !0, bi = null, r = iw(e, null, n, r), e.child = r; r;) r.flags = r.flags & -3 | 4096, r = r.sibling;
                else {
                    if (ba(), n === i) {
                        e = vs(t, e, r);
                        break e
                    }
                    vn(t, e, n, r)
                }
                e = e.child
            }
            return e;
        case 5:
            return sw(e), t === null && Ed(e), n = e.type, i = e.pendingProps, s = t !== null ? t.memoizedProps : null, o = i.children, gd(n, i) ? o = null : s !== null && gd(n, s) && (e.flags |= 32), Tw(t, e), vn(t, e, o, r), e.child;
        case 6:
            return t === null && Ed(e), null;
        case 13:
            return Rw(t, e, r);
        case 4:
            return Hp(e, e.stateNode.containerInfo), n = e.pendingProps, t === null ? e.child = Aa(e, null, n, r) : vn(t, e, n, r), e.child;
        case 11:
            return n = e.type, i = e.pendingProps, i = e.elementType === n ? i : yi(n, i), Zm(t, e, n, i, r);
        case 7:
            return vn(t, e, e.pendingProps, r), e.child;
        case 8:
            return vn(t, e, e.pendingProps.children, r), e.child;
        case 12:
            return vn(t, e, e.pendingProps.children, r), e.child;
        case 10:
            e: {
                if (n = e.type._context, i = e.pendingProps, s = e.memoizedProps, o = i.value, lr(Xf, n._currentValue), n._currentValue = o, s !== null)
                    if (_i(s.value, o)) {
                        if (s.children === i.children && !In.current) {
                            e = vs(t, e, r);
                            break e
                        }
                    } else
                        for (s = e.child, s !== null && (s.return = e); s !== null;) {
                            var a = s.dependencies;
                            if (a !== null) {
                                o = s.child;
                                for (var c = a.firstContext; c !== null;) {
                                    if (c.context === n) {
                                        if (s.tag === 1) {
                                            c = ds(-1, r & -r), c.tag = 2;
                                            var d = s.updateQueue;
                                            if (d !== null) {
                                                d = d.shared;
                                                var y = d.pending;
                                                y === null ? c.next = c : (c.next = y.next, y.next = c), d.pending = c
                                            }
                                        }
                                        s.lanes |= r, c = s.alternate, c !== null && (c.lanes |= r), bd(s.return, r, e), a.lanes |= r;
                                        break
                                    }
                                    c = c.next
                                }
                            } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
                            else if (s.tag === 18) {
                                if (o = s.return, o === null) throw Error(be(341));
                                o.lanes |= r, a = o.alternate, a !== null && (a.lanes |= r), bd(o, r, e), o = s.sibling
                            } else o = s.child;
                            if (o !== null) o.return = s;
                            else
                                for (o = s; o !== null;) {
                                    if (o === e) {
                                        o = null;
                                        break
                                    }
                                    if (s = o.sibling, s !== null) {
                                        s.return = o.return, o = s;
                                        break
                                    }
                                    o = o.return
                                }
                            s = o
                        }
                vn(t, e, i.children, r),
                e = e.child
            }
            return e;
        case 9:
            return i = e.type, n = e.pendingProps.children, pa(e, r), i = oi(i), n = n(i), e.flags |= 1, vn(t, e, n, r), e.child;
        case 14:
            return n = e.type, i = yi(n, e.pendingProps), i = yi(n.type, i), Jm(t, e, n, i, r);
        case 15:
            return kw(t, e, e.type, e.pendingProps, r);
        case 17:
            return n = e.type, i = e.pendingProps, i = e.elementType === n ? i : yi(n, i), t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2), e.tag = 1, Cn(n) ? (t = !0, Jf(e)) : t = !1, pa(e, r), ew(e, n, i), Sd(e, n, i, r), Bd(null, e, n, !0, t, r);
        case 19:
            return Dw(t, e, r);
        case 22:
            return Nw(t, e, r)
    }
    throw Error(be(156, e.tag))
};

function Yw(t, e) {
    return Ay(t, e)
}

function zb(t, e, r, n) {
    this.tag = t, this.key = r, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function ti(t, e, r, n) {
    return new zb(t, e, r, n)
}

function i1(t) {
    return t = t.prototype, !(!t || !t.isReactComponent)
}

function jb(t) {
    if (typeof t == "function") return i1(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof, t === Mp) return 11;
        if (t === Ep) return 14
    }
    return 2
}

function to(t, e) {
    var r = t.alternate;
    return r === null ? (r = ti(t.tag, e, t.key, t.mode), r.elementType = t.elementType, r.type = t.type, r.stateNode = t.stateNode, r.alternate = t, t.alternate = r) : (r.pendingProps = e, r.type = t.type, r.flags = 0, r.subtreeFlags = 0, r.deletions = null), r.flags = t.flags & 14680064, r.childLanes = t.childLanes, r.lanes = t.lanes, r.child = t.child, r.memoizedProps = t.memoizedProps, r.memoizedState = t.memoizedState, r.updateQueue = t.updateQueue, e = t.dependencies, r.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    }, r.sibling = t.sibling, r.index = t.index, r.ref = t.ref, r
}

function Bf(t, e, r, n, i, s) {
    var o = 2;
    if (n = t, typeof t == "function") i1(t) && (o = 1);
    else if (typeof t == "string") o = 5;
    else e: switch (t) {
        case Zo:
            return So(r.children, i, s, e);
        case Sp:
            o = 8, i |= 8;
            break;
        case Y0:
            return t = ti(12, r, e, i | 2), t.elementType = Y0, t.lanes = s, t;
        case K0:
            return t = ti(13, r, e, i), t.elementType = K0, t.lanes = s, t;
        case Z0:
            return t = ti(19, r, e, i), t.elementType = Z0, t.lanes = s, t;
        case sy:
            return cc(r, i, s, e);
        default:
            if (typeof t == "object" && t !== null) switch (t.$$typeof) {
                case ny:
                    o = 10;
                    break e;
                case iy:
                    o = 9;
                    break e;
                case Mp:
                    o = 11;
                    break e;
                case Ep:
                    o = 14;
                    break e;
                case Bs:
                    o = 16, n = null;
                    break e
            }
            throw Error(be(130, t == null ? t : typeof t, ""))
    }
    return e = ti(o, r, e, i), e.elementType = t, e.type = n, e.lanes = s, e
}

function So(t, e, r, n) {
    return t = ti(7, t, n, e), t.lanes = r, t
}

function cc(t, e, r, n) {
    return t = ti(22, t, n, e), t.elementType = sy, t.lanes = r, t.stateNode = {}, t
}

function o0(t, e, r) {
    return t = ti(6, t, null, e), t.lanes = r, t
}

function a0(t, e, r) {
    return e = ti(4, t.children !== null ? t.children : [], t.key, e), e.lanes = r, e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    }, e
}

function $b(t, e, r, n, i) {
    this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = $h(0), this.expirationTimes = $h(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = $h(0), this.identifierPrefix = n, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
}

function s1(t, e, r, n, i, s, o, a, c) {
    return t = new $b(t, e, r, a, c), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = ti(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = {
        element: n,
        isDehydrated: r,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    }, Up(s), t
}

function Hb(t, e, r) {
    var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Ko,
        key: n == null ? null : "" + n,
        children: t,
        containerInfo: e,
        implementation: r
    }
}

function Kw(t) {
    if (!t) return eo;
    t = t._reactInternals;
    e: {
        if (Do(t) !== t || t.tag !== 1) throw Error(be(170));
        var e = t;do {
            switch (e.tag) {
                case 3:
                    e = e.stateNode.context;
                    break e;
                case 1:
                    if (Cn(e.type)) {
                        e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            e = e.return
        } while (e !== null);
        throw Error(be(171))
    }
    if (t.tag === 1) {
        var r = t.type;
        if (Cn(r)) return Ky(t, r, e)
    }
    return e
}

function Zw(t, e, r, n, i, s, o, a, c) {
    return t = s1(r, n, !0, t, i, s, o, a, c), t.context = Kw(null), r = t.current, n = wn(), i = Zs(r), s = ds(n, i), s.callback = e != null ? e : null, Ys(r, s), t.current.lanes = i, yl(t, i, n), Bn(t, n), t
}

function Qc(t, e, r, n) {
    var i = e.current,
        s = wn(),
        o = Zs(i);
    return r = Kw(r), e.context === null ? e.context = r : e.pendingContext = r, e = ds(s, o), e.payload = {
        element: t
    }, n = n === void 0 ? null : n, n !== null && (e.callback = n), Ys(i, e), t = ii(i, o, s), t !== null && Mf(t, i, o), o
}

function hc(t) {
    if (t = t.current, !t.child) return null;
    switch (t.child.tag) {
        case 5:
            return t.child.stateNode;
        default:
            return t.child.stateNode
    }
}

function dv(t, e) {
    if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
        var r = t.retryLane;
        t.retryLane = r !== 0 && r < e ? r : e
    }
}

function o1(t, e) {
    dv(t, e), (t = t.alternate) && dv(t, e)
}

function Qb() {
    return null
}
var Jw = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
};

function a1(t) {
    this._internalRoot = t
}
qc.prototype.render = a1.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null) throw Error(be(409));
    Qc(t, e, null, null)
};
qc.prototype.unmount = a1.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        No(function() {
            Qc(null, t, null, null)
        }), e[ms] = null
    }
};

function qc(t) {
    this._internalRoot = t
}
qc.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var e = By();
        t = {
            blockedOn: null,
            target: t,
            priority: e
        };
        for (var r = 0; r < Ds.length && e !== 0 && e < Ds[r].priority; r++);
        Ds.splice(r, 0, t), r === 0 && Ny(t)
    }
};

function u1(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}

function Wc(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}

function pv() {}

function qb(t, e, r, n, i) {
    if (i) {
        if (typeof n == "function") {
            var s = n;
            n = function() {
                var d = hc(o);
                s.call(d)
            }
        }
        var o = Zw(e, n, t, 0, null, !1, !1, "", pv);
        return t._reactRootContainer = o, t[ms] = o.current, sl(t.nodeType === 8 ? t.parentNode : t), No(), o
    }
    for (; i = t.lastChild;) t.removeChild(i);
    if (typeof n == "function") {
        var a = n;
        n = function() {
            var d = hc(c);
            a.call(d)
        }
    }
    var c = s1(t, 0, !1, null, null, !1, !1, "", pv);
    return t._reactRootContainer = c, t[ms] = c.current, sl(t.nodeType === 8 ? t.parentNode : t), No(function() {
        Qc(e, c, r, n)
    }), c
}

function Vc(t, e, r, n, i) {
    var s = r._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof i == "function") {
            var a = i;
            i = function() {
                var c = hc(o);
                a.call(c)
            }
        }
        Qc(e, o, t, i)
    } else o = qb(r, e, t, i, n);
    return hc(o)
}
Iy = function(t) {
    switch (t.tag) {
        case 3:
            var e = t.stateNode;
            if (e.current.memoizedState.isDehydrated) {
                var r = ku(e.pendingLanes);
                r !== 0 && (Cp(e, r | 1), Bn(e, Cr()), (Vt & 6) === 0 && (Ma = Cr() + 500, oo()))
            }
            break;
        case 13:
            var n = wn();
            No(function() {
                return ii(t, 1, n)
            }), o1(t, 1)
    }
};
Bp = function(t) {
    if (t.tag === 13) {
        var e = wn();
        ii(t, 134217728, e), o1(t, 134217728)
    }
};
Cy = function(t) {
    if (t.tag === 13) {
        var e = wn(),
            r = Zs(t);
        ii(t, r, e), o1(t, r)
    }
};
By = function() {
    return sr
};
ky = function(t, e) {
    var r = sr;
    try {
        return sr = t, e()
    } finally {
        sr = r
    }
};
ad = function(t, e, r) {
    switch (e) {
        case "input":
            if (ed(t, r), e = r.name, r.type === "radio" && e != null) {
                for (r = t; r.parentNode;) r = r.parentNode;
                for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < r.length; e++) {
                    var n = r[e];
                    if (n !== t && n.form === t.form) {
                        var i = Lc(n);
                        if (!i) throw Error(be(90));
                        ay(n), ed(n, i)
                    }
                }
            }
            break;
        case "textarea":
            ly(t, r);
            break;
        case "select":
            e = r.value, e != null && fa(t, !!r.multiple, e, !1)
    }
};
vy = t1;
gy = No;
var Wb = {
        usingClientEntryPoint: !1,
        Events: [xl, ta, Lc, py, my, t1]
    },
    vu = {
        findFiberByHostInstance: yo,
        bundleType: 0,
        version: "18.1.0",
        rendererPackageName: "react-dom"
    },
    Vb = {
        bundleType: vu.bundleType,
        version: vu.version,
        rendererPackageName: vu.rendererPackageName,
        rendererConfig: vu.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: Ss.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(t) {
            return t = xy(t), t === null ? null : t.stateNode
        },
        findFiberByHostInstance: vu.findFiberByHostInstance || Qb,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.1.0-next-22edb9f77-20220426"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined") {
    var nf = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!nf.isDisabled && nf.supportsFiber) try {
        Oc = nf.inject(Vb), Li = nf
    } catch {}
}
$n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Wb;
$n.createPortal = function(t, e) {
    var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!u1(e)) throw Error(be(200));
    return Hb(t, e, null, r)
};
$n.createRoot = function(t, e) {
    if (!u1(t)) throw Error(be(299));
    var r = !1,
        n = "",
        i = Jw;
    return e != null && (e.unstable_strictMode === !0 && (r = !0), e.identifierPrefix !== void 0 && (n = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = s1(t, 1, !1, null, null, r, !1, n, i), t[ms] = e.current, sl(t.nodeType === 8 ? t.parentNode : t), new a1(e)
};
$n.findDOMNode = function(t) {
    if (t == null) return null;
    if (t.nodeType === 1) return t;
    var e = t._reactInternals;
    if (e === void 0) throw typeof t.render == "function" ? Error(be(188)) : (t = Object.keys(t).join(","), Error(be(268, t)));
    return t = xy(e), t = t === null ? null : t.stateNode, t
};
$n.flushSync = function(t) {
    return No(t)
};
$n.hydrate = function(t, e, r) {
    if (!Wc(e)) throw Error(be(200));
    return Vc(null, t, e, !0, r)
};
$n.hydrateRoot = function(t, e, r) {
    if (!u1(t)) throw Error(be(405));
    var n = r != null && r.hydratedSources || null,
        i = !1,
        s = "",
        o = Jw;
    if (r != null && (r.unstable_strictMode === !0 && (i = !0), r.identifierPrefix !== void 0 && (s = r.identifierPrefix), r.onRecoverableError !== void 0 && (o = r.onRecoverableError)), e = Zw(e, null, t, 1, r != null ? r : null, i, !1, s, o), t[ms] = e.current, sl(t), n)
        for (t = 0; t < n.length; t++) r = n[t], i = r._getVersion, i = i(r._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [r, i] : e.mutableSourceEagerHydrationData.push(r, i);
    return new qc(e)
};
$n.render = function(t, e, r) {
    if (!Wc(e)) throw Error(be(200));
    return Vc(null, t, e, !1, r)
};
$n.unmountComponentAtNode = function(t) {
    if (!Wc(t)) throw Error(be(40));
    return t._reactRootContainer ? (No(function() {
        Vc(null, null, t, !1, function() {
            t._reactRootContainer = null, t[ms] = null
        })
    }), !0) : !1
};
$n.unstable_batchedUpdates = t1;
$n.unstable_renderSubtreeIntoContainer = function(t, e, r, n) {
    if (!Wc(r)) throw Error(be(200));
    if (t == null || t._reactInternals === void 0) throw Error(be(38));
    return Vc(t, e, r, !1, n)
};
$n.version = "18.1.0-next-22edb9f77-20220426";

function Xw() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Xw)
    } catch (t) {
        console.error(t)
    }
}
Xw(), Tc.exports = $n;
var Gb = Tc.exports,
    mv = Tc.exports;
V0.createRoot = mv.createRoot, V0.hydrateRoot = mv.hydrateRoot;
var e2 = {
        exports: {}
    },
    Yb = {},
    Kb = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Yb
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Zb = mp(Kb);
(function(t) {
    (function(e) {
        var r = function(B) {
                var L, F = new Float64Array(16);
                if (B)
                    for (L = 0; L < B.length; L++) F[L] = B[L];
                return F
            },
            n = function() {
                throw new Error("no PRNG")
            },
            i = new Uint8Array(16),
            s = new Uint8Array(32);
        s[0] = 9;
        var o = r(),
            a = r([1]),
            c = r([56129, 1]),
            d = r([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
            y = r([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
            I = r([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
            N = r([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
            E = r([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

        function T(B, L, F, g) {
            B[L] = F >> 24 & 255, B[L + 1] = F >> 16 & 255, B[L + 2] = F >> 8 & 255, B[L + 3] = F & 255, B[L + 4] = g >> 24 & 255, B[L + 5] = g >> 16 & 255, B[L + 6] = g >> 8 & 255, B[L + 7] = g & 255
        }

        function j(B, L, F, g, U) {
            var Z, ee = 0;
            for (Z = 0; Z < U; Z++) ee |= B[L + Z] ^ F[g + Z];
            return (1 & ee - 1 >>> 8) - 1
        }

        function V(B, L, F, g) {
            return j(B, L, F, g, 16)
        }

        function P(B, L, F, g) {
            return j(B, L, F, g, 32)
        }

        function O(B, L, F, g) {
            for (var U = g[0] & 255 | (g[1] & 255) << 8 | (g[2] & 255) << 16 | (g[3] & 255) << 24, Z = F[0] & 255 | (F[1] & 255) << 8 | (F[2] & 255) << 16 | (F[3] & 255) << 24, ee = F[4] & 255 | (F[5] & 255) << 8 | (F[6] & 255) << 16 | (F[7] & 255) << 24, te = F[8] & 255 | (F[9] & 255) << 8 | (F[10] & 255) << 16 | (F[11] & 255) << 24, fe = F[12] & 255 | (F[13] & 255) << 8 | (F[14] & 255) << 16 | (F[15] & 255) << 24, Ae = g[4] & 255 | (g[5] & 255) << 8 | (g[6] & 255) << 16 | (g[7] & 255) << 24, ye = L[0] & 255 | (L[1] & 255) << 8 | (L[2] & 255) << 16 | (L[3] & 255) << 24, dt = L[4] & 255 | (L[5] & 255) << 8 | (L[6] & 255) << 16 | (L[7] & 255) << 24, Ne = L[8] & 255 | (L[9] & 255) << 8 | (L[10] & 255) << 16 | (L[11] & 255) << 24, Ge = L[12] & 255 | (L[13] & 255) << 8 | (L[14] & 255) << 16 | (L[15] & 255) << 24, Ke = g[8] & 255 | (g[9] & 255) << 8 | (g[10] & 255) << 16 | (g[11] & 255) << 24, Je = F[16] & 255 | (F[17] & 255) << 8 | (F[18] & 255) << 16 | (F[19] & 255) << 24, ut = F[20] & 255 | (F[21] & 255) << 8 | (F[22] & 255) << 16 | (F[23] & 255) << 24, tt = F[24] & 255 | (F[25] & 255) << 8 | (F[26] & 255) << 16 | (F[27] & 255) << 24, st = F[28] & 255 | (F[29] & 255) << 8 | (F[30] & 255) << 16 | (F[31] & 255) << 24, rt = g[12] & 255 | (g[13] & 255) << 8 | (g[14] & 255) << 16 | (g[15] & 255) << 24, Pe = U, He = Z, Oe = ee, Le = te, ze = fe, ke = Ae, ie = ye, se = dt, me = Ne, ce = Ge, de = Ke, xe = Je, at = ut, vt = tt, wt = st, gt = rt, K, Bt = 0; Bt < 20; Bt += 2) K = Pe + at | 0, ze ^= K << 7 | K >>> 32 - 7, K = ze + Pe | 0, me ^= K << 9 | K >>> 32 - 9, K = me + ze | 0, at ^= K << 13 | K >>> 32 - 13, K = at + me | 0, Pe ^= K << 18 | K >>> 32 - 18, K = ke + He | 0, ce ^= K << 7 | K >>> 32 - 7, K = ce + ke | 0, vt ^= K << 9 | K >>> 32 - 9, K = vt + ce | 0, He ^= K << 13 | K >>> 32 - 13, K = He + vt | 0, ke ^= K << 18 | K >>> 32 - 18, K = de + ie | 0, wt ^= K << 7 | K >>> 32 - 7, K = wt + de | 0, Oe ^= K << 9 | K >>> 32 - 9, K = Oe + wt | 0, ie ^= K << 13 | K >>> 32 - 13, K = ie + Oe | 0, de ^= K << 18 | K >>> 32 - 18, K = gt + xe | 0, Le ^= K << 7 | K >>> 32 - 7, K = Le + gt | 0, se ^= K << 9 | K >>> 32 - 9, K = se + Le | 0, xe ^= K << 13 | K >>> 32 - 13, K = xe + se | 0, gt ^= K << 18 | K >>> 32 - 18, K = Pe + Le | 0, He ^= K << 7 | K >>> 32 - 7, K = He + Pe | 0, Oe ^= K << 9 | K >>> 32 - 9, K = Oe + He | 0, Le ^= K << 13 | K >>> 32 - 13, K = Le + Oe | 0, Pe ^= K << 18 | K >>> 32 - 18, K = ke + ze | 0, ie ^= K << 7 | K >>> 32 - 7, K = ie + ke | 0, se ^= K << 9 | K >>> 32 - 9, K = se + ie | 0, ze ^= K << 13 | K >>> 32 - 13, K = ze + se | 0, ke ^= K << 18 | K >>> 32 - 18, K = de + ce | 0, xe ^= K << 7 | K >>> 32 - 7, K = xe + de | 0, me ^= K << 9 | K >>> 32 - 9, K = me + xe | 0, ce ^= K << 13 | K >>> 32 - 13, K = ce + me | 0, de ^= K << 18 | K >>> 32 - 18, K = gt + wt | 0, at ^= K << 7 | K >>> 32 - 7, K = at + gt | 0, vt ^= K << 9 | K >>> 32 - 9, K = vt + at | 0, wt ^= K << 13 | K >>> 32 - 13, K = wt + vt | 0, gt ^= K << 18 | K >>> 32 - 18;
            Pe = Pe + U | 0, He = He + Z | 0, Oe = Oe + ee | 0, Le = Le + te | 0, ze = ze + fe | 0, ke = ke + Ae | 0, ie = ie + ye | 0, se = se + dt | 0, me = me + Ne | 0, ce = ce + Ge | 0, de = de + Ke | 0, xe = xe + Je | 0, at = at + ut | 0, vt = vt + tt | 0, wt = wt + st | 0, gt = gt + rt | 0, B[0] = Pe >>> 0 & 255, B[1] = Pe >>> 8 & 255, B[2] = Pe >>> 16 & 255, B[3] = Pe >>> 24 & 255, B[4] = He >>> 0 & 255, B[5] = He >>> 8 & 255, B[6] = He >>> 16 & 255, B[7] = He >>> 24 & 255, B[8] = Oe >>> 0 & 255, B[9] = Oe >>> 8 & 255, B[10] = Oe >>> 16 & 255, B[11] = Oe >>> 24 & 255, B[12] = Le >>> 0 & 255, B[13] = Le >>> 8 & 255, B[14] = Le >>> 16 & 255, B[15] = Le >>> 24 & 255, B[16] = ze >>> 0 & 255, B[17] = ze >>> 8 & 255, B[18] = ze >>> 16 & 255, B[19] = ze >>> 24 & 255, B[20] = ke >>> 0 & 255, B[21] = ke >>> 8 & 255, B[22] = ke >>> 16 & 255, B[23] = ke >>> 24 & 255, B[24] = ie >>> 0 & 255, B[25] = ie >>> 8 & 255, B[26] = ie >>> 16 & 255, B[27] = ie >>> 24 & 255, B[28] = se >>> 0 & 255, B[29] = se >>> 8 & 255, B[30] = se >>> 16 & 255, B[31] = se >>> 24 & 255, B[32] = me >>> 0 & 255, B[33] = me >>> 8 & 255, B[34] = me >>> 16 & 255, B[35] = me >>> 24 & 255, B[36] = ce >>> 0 & 255, B[37] = ce >>> 8 & 255, B[38] = ce >>> 16 & 255, B[39] = ce >>> 24 & 255, B[40] = de >>> 0 & 255, B[41] = de >>> 8 & 255, B[42] = de >>> 16 & 255, B[43] = de >>> 24 & 255, B[44] = xe >>> 0 & 255, B[45] = xe >>> 8 & 255, B[46] = xe >>> 16 & 255, B[47] = xe >>> 24 & 255, B[48] = at >>> 0 & 255, B[49] = at >>> 8 & 255, B[50] = at >>> 16 & 255, B[51] = at >>> 24 & 255, B[52] = vt >>> 0 & 255, B[53] = vt >>> 8 & 255, B[54] = vt >>> 16 & 255, B[55] = vt >>> 24 & 255, B[56] = wt >>> 0 & 255, B[57] = wt >>> 8 & 255, B[58] = wt >>> 16 & 255, B[59] = wt >>> 24 & 255, B[60] = gt >>> 0 & 255, B[61] = gt >>> 8 & 255, B[62] = gt >>> 16 & 255, B[63] = gt >>> 24 & 255
        }

        function R(B, L, F, g) {
            for (var U = g[0] & 255 | (g[1] & 255) << 8 | (g[2] & 255) << 16 | (g[3] & 255) << 24, Z = F[0] & 255 | (F[1] & 255) << 8 | (F[2] & 255) << 16 | (F[3] & 255) << 24, ee = F[4] & 255 | (F[5] & 255) << 8 | (F[6] & 255) << 16 | (F[7] & 255) << 24, te = F[8] & 255 | (F[9] & 255) << 8 | (F[10] & 255) << 16 | (F[11] & 255) << 24, fe = F[12] & 255 | (F[13] & 255) << 8 | (F[14] & 255) << 16 | (F[15] & 255) << 24, Ae = g[4] & 255 | (g[5] & 255) << 8 | (g[6] & 255) << 16 | (g[7] & 255) << 24, ye = L[0] & 255 | (L[1] & 255) << 8 | (L[2] & 255) << 16 | (L[3] & 255) << 24, dt = L[4] & 255 | (L[5] & 255) << 8 | (L[6] & 255) << 16 | (L[7] & 255) << 24, Ne = L[8] & 255 | (L[9] & 255) << 8 | (L[10] & 255) << 16 | (L[11] & 255) << 24, Ge = L[12] & 255 | (L[13] & 255) << 8 | (L[14] & 255) << 16 | (L[15] & 255) << 24, Ke = g[8] & 255 | (g[9] & 255) << 8 | (g[10] & 255) << 16 | (g[11] & 255) << 24, Je = F[16] & 255 | (F[17] & 255) << 8 | (F[18] & 255) << 16 | (F[19] & 255) << 24, ut = F[20] & 255 | (F[21] & 255) << 8 | (F[22] & 255) << 16 | (F[23] & 255) << 24, tt = F[24] & 255 | (F[25] & 255) << 8 | (F[26] & 255) << 16 | (F[27] & 255) << 24, st = F[28] & 255 | (F[29] & 255) << 8 | (F[30] & 255) << 16 | (F[31] & 255) << 24, rt = g[12] & 255 | (g[13] & 255) << 8 | (g[14] & 255) << 16 | (g[15] & 255) << 24, Pe = U, He = Z, Oe = ee, Le = te, ze = fe, ke = Ae, ie = ye, se = dt, me = Ne, ce = Ge, de = Ke, xe = Je, at = ut, vt = tt, wt = st, gt = rt, K, Bt = 0; Bt < 20; Bt += 2) K = Pe + at | 0, ze ^= K << 7 | K >>> 32 - 7, K = ze + Pe | 0, me ^= K << 9 | K >>> 32 - 9, K = me + ze | 0, at ^= K << 13 | K >>> 32 - 13, K = at + me | 0, Pe ^= K << 18 | K >>> 32 - 18, K = ke + He | 0, ce ^= K << 7 | K >>> 32 - 7, K = ce + ke | 0, vt ^= K << 9 | K >>> 32 - 9, K = vt + ce | 0, He ^= K << 13 | K >>> 32 - 13, K = He + vt | 0, ke ^= K << 18 | K >>> 32 - 18, K = de + ie | 0, wt ^= K << 7 | K >>> 32 - 7, K = wt + de | 0, Oe ^= K << 9 | K >>> 32 - 9, K = Oe + wt | 0, ie ^= K << 13 | K >>> 32 - 13, K = ie + Oe | 0, de ^= K << 18 | K >>> 32 - 18, K = gt + xe | 0, Le ^= K << 7 | K >>> 32 - 7, K = Le + gt | 0, se ^= K << 9 | K >>> 32 - 9, K = se + Le | 0, xe ^= K << 13 | K >>> 32 - 13, K = xe + se | 0, gt ^= K << 18 | K >>> 32 - 18, K = Pe + Le | 0, He ^= K << 7 | K >>> 32 - 7, K = He + Pe | 0, Oe ^= K << 9 | K >>> 32 - 9, K = Oe + He | 0, Le ^= K << 13 | K >>> 32 - 13, K = Le + Oe | 0, Pe ^= K << 18 | K >>> 32 - 18, K = ke + ze | 0, ie ^= K << 7 | K >>> 32 - 7, K = ie + ke | 0, se ^= K << 9 | K >>> 32 - 9, K = se + ie | 0, ze ^= K << 13 | K >>> 32 - 13, K = ze + se | 0, ke ^= K << 18 | K >>> 32 - 18, K = de + ce | 0, xe ^= K << 7 | K >>> 32 - 7, K = xe + de | 0, me ^= K << 9 | K >>> 32 - 9, K = me + xe | 0, ce ^= K << 13 | K >>> 32 - 13, K = ce + me | 0, de ^= K << 18 | K >>> 32 - 18, K = gt + wt | 0, at ^= K << 7 | K >>> 32 - 7, K = at + gt | 0, vt ^= K << 9 | K >>> 32 - 9, K = vt + at | 0, wt ^= K << 13 | K >>> 32 - 13, K = wt + vt | 0, gt ^= K << 18 | K >>> 32 - 18;
            B[0] = Pe >>> 0 & 255, B[1] = Pe >>> 8 & 255, B[2] = Pe >>> 16 & 255, B[3] = Pe >>> 24 & 255, B[4] = ke >>> 0 & 255, B[5] = ke >>> 8 & 255, B[6] = ke >>> 16 & 255, B[7] = ke >>> 24 & 255, B[8] = de >>> 0 & 255, B[9] = de >>> 8 & 255, B[10] = de >>> 16 & 255, B[11] = de >>> 24 & 255, B[12] = gt >>> 0 & 255, B[13] = gt >>> 8 & 255, B[14] = gt >>> 16 & 255, B[15] = gt >>> 24 & 255, B[16] = ie >>> 0 & 255, B[17] = ie >>> 8 & 255, B[18] = ie >>> 16 & 255, B[19] = ie >>> 24 & 255, B[20] = se >>> 0 & 255, B[21] = se >>> 8 & 255, B[22] = se >>> 16 & 255, B[23] = se >>> 24 & 255, B[24] = me >>> 0 & 255, B[25] = me >>> 8 & 255, B[26] = me >>> 16 & 255, B[27] = me >>> 24 & 255, B[28] = ce >>> 0 & 255, B[29] = ce >>> 8 & 255, B[30] = ce >>> 16 & 255, B[31] = ce >>> 24 & 255
        }

        function q(B, L, F, g) {
            O(B, L, F, g)
        }

        function W(B, L, F, g) {
            R(B, L, F, g)
        }
        var Y = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);

        function G(B, L, F, g, U, Z, ee) {
            var te = new Uint8Array(16),
                fe = new Uint8Array(64),
                Ae, ye;
            for (ye = 0; ye < 16; ye++) te[ye] = 0;
            for (ye = 0; ye < 8; ye++) te[ye] = Z[ye];
            for (; U >= 64;) {
                for (q(fe, te, ee, Y), ye = 0; ye < 64; ye++) B[L + ye] = F[g + ye] ^ fe[ye];
                for (Ae = 1, ye = 8; ye < 16; ye++) Ae = Ae + (te[ye] & 255) | 0, te[ye] = Ae & 255, Ae >>>= 8;
                U -= 64, L += 64, g += 64
            }
            if (U > 0)
                for (q(fe, te, ee, Y), ye = 0; ye < U; ye++) B[L + ye] = F[g + ye] ^ fe[ye];
            return 0
        }

        function J(B, L, F, g, U) {
            var Z = new Uint8Array(16),
                ee = new Uint8Array(64),
                te, fe;
            for (fe = 0; fe < 16; fe++) Z[fe] = 0;
            for (fe = 0; fe < 8; fe++) Z[fe] = g[fe];
            for (; F >= 64;) {
                for (q(ee, Z, U, Y), fe = 0; fe < 64; fe++) B[L + fe] = ee[fe];
                for (te = 1, fe = 8; fe < 16; fe++) te = te + (Z[fe] & 255) | 0, Z[fe] = te & 255, te >>>= 8;
                F -= 64, L += 64
            }
            if (F > 0)
                for (q(ee, Z, U, Y), fe = 0; fe < F; fe++) B[L + fe] = ee[fe];
            return 0
        }

        function pe(B, L, F, g, U) {
            var Z = new Uint8Array(32);
            W(Z, g, U, Y);
            for (var ee = new Uint8Array(8), te = 0; te < 8; te++) ee[te] = g[te + 16];
            return J(B, L, F, ee, Z)
        }

        function we(B, L, F, g, U, Z, ee) {
            var te = new Uint8Array(32);
            W(te, Z, ee, Y);
            for (var fe = new Uint8Array(8), Ae = 0; Ae < 8; Ae++) fe[Ae] = Z[Ae + 16];
            return G(B, L, F, g, U, fe, te)
        }
        var H = function(B) {
            this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
            var L, F, g, U, Z, ee, te, fe;
            L = B[0] & 255 | (B[1] & 255) << 8, this.r[0] = L & 8191, F = B[2] & 255 | (B[3] & 255) << 8, this.r[1] = (L >>> 13 | F << 3) & 8191, g = B[4] & 255 | (B[5] & 255) << 8, this.r[2] = (F >>> 10 | g << 6) & 7939, U = B[6] & 255 | (B[7] & 255) << 8, this.r[3] = (g >>> 7 | U << 9) & 8191, Z = B[8] & 255 | (B[9] & 255) << 8, this.r[4] = (U >>> 4 | Z << 12) & 255, this.r[5] = Z >>> 1 & 8190, ee = B[10] & 255 | (B[11] & 255) << 8, this.r[6] = (Z >>> 14 | ee << 2) & 8191, te = B[12] & 255 | (B[13] & 255) << 8, this.r[7] = (ee >>> 11 | te << 5) & 8065, fe = B[14] & 255 | (B[15] & 255) << 8, this.r[8] = (te >>> 8 | fe << 8) & 8191, this.r[9] = fe >>> 5 & 127, this.pad[0] = B[16] & 255 | (B[17] & 255) << 8, this.pad[1] = B[18] & 255 | (B[19] & 255) << 8, this.pad[2] = B[20] & 255 | (B[21] & 255) << 8, this.pad[3] = B[22] & 255 | (B[23] & 255) << 8, this.pad[4] = B[24] & 255 | (B[25] & 255) << 8, this.pad[5] = B[26] & 255 | (B[27] & 255) << 8, this.pad[6] = B[28] & 255 | (B[29] & 255) << 8, this.pad[7] = B[30] & 255 | (B[31] & 255) << 8
        };
        H.prototype.blocks = function(B, L, F) {
            for (var g = this.fin ? 0 : 2048, U, Z, ee, te, fe, Ae, ye, dt, Ne, Ge, Ke, Je, ut, tt, st, rt, Pe, He, Oe, Le = this.h[0], ze = this.h[1], ke = this.h[2], ie = this.h[3], se = this.h[4], me = this.h[5], ce = this.h[6], de = this.h[7], xe = this.h[8], at = this.h[9], vt = this.r[0], wt = this.r[1], gt = this.r[2], K = this.r[3], Bt = this.r[4], Ht = this.r[5], Qt = this.r[6], Mt = this.r[7], zt = this.r[8], jt = this.r[9]; F >= 16;) U = B[L + 0] & 255 | (B[L + 1] & 255) << 8, Le += U & 8191, Z = B[L + 2] & 255 | (B[L + 3] & 255) << 8, ze += (U >>> 13 | Z << 3) & 8191, ee = B[L + 4] & 255 | (B[L + 5] & 255) << 8, ke += (Z >>> 10 | ee << 6) & 8191, te = B[L + 6] & 255 | (B[L + 7] & 255) << 8, ie += (ee >>> 7 | te << 9) & 8191, fe = B[L + 8] & 255 | (B[L + 9] & 255) << 8, se += (te >>> 4 | fe << 12) & 8191, me += fe >>> 1 & 8191, Ae = B[L + 10] & 255 | (B[L + 11] & 255) << 8, ce += (fe >>> 14 | Ae << 2) & 8191, ye = B[L + 12] & 255 | (B[L + 13] & 255) << 8, de += (Ae >>> 11 | ye << 5) & 8191, dt = B[L + 14] & 255 | (B[L + 15] & 255) << 8, xe += (ye >>> 8 | dt << 8) & 8191, at += dt >>> 5 | g, Ne = 0, Ge = Ne, Ge += Le * vt, Ge += ze * (5 * jt), Ge += ke * (5 * zt), Ge += ie * (5 * Mt), Ge += se * (5 * Qt), Ne = Ge >>> 13, Ge &= 8191, Ge += me * (5 * Ht), Ge += ce * (5 * Bt), Ge += de * (5 * K), Ge += xe * (5 * gt), Ge += at * (5 * wt), Ne += Ge >>> 13, Ge &= 8191, Ke = Ne, Ke += Le * wt, Ke += ze * vt, Ke += ke * (5 * jt), Ke += ie * (5 * zt), Ke += se * (5 * Mt), Ne = Ke >>> 13, Ke &= 8191, Ke += me * (5 * Qt), Ke += ce * (5 * Ht), Ke += de * (5 * Bt), Ke += xe * (5 * K), Ke += at * (5 * gt), Ne += Ke >>> 13, Ke &= 8191, Je = Ne, Je += Le * gt, Je += ze * wt, Je += ke * vt, Je += ie * (5 * jt), Je += se * (5 * zt), Ne = Je >>> 13, Je &= 8191, Je += me * (5 * Mt), Je += ce * (5 * Qt), Je += de * (5 * Ht), Je += xe * (5 * Bt), Je += at * (5 * K), Ne += Je >>> 13, Je &= 8191, ut = Ne, ut += Le * K, ut += ze * gt, ut += ke * wt, ut += ie * vt, ut += se * (5 * jt), Ne = ut >>> 13, ut &= 8191, ut += me * (5 * zt), ut += ce * (5 * Mt), ut += de * (5 * Qt), ut += xe * (5 * Ht), ut += at * (5 * Bt), Ne += ut >>> 13, ut &= 8191, tt = Ne, tt += Le * Bt, tt += ze * K, tt += ke * gt, tt += ie * wt, tt += se * vt, Ne = tt >>> 13, tt &= 8191, tt += me * (5 * jt), tt += ce * (5 * zt), tt += de * (5 * Mt), tt += xe * (5 * Qt), tt += at * (5 * Ht), Ne += tt >>> 13, tt &= 8191, st = Ne, st += Le * Ht, st += ze * Bt, st += ke * K, st += ie * gt, st += se * wt, Ne = st >>> 13, st &= 8191, st += me * vt, st += ce * (5 * jt), st += de * (5 * zt), st += xe * (5 * Mt), st += at * (5 * Qt), Ne += st >>> 13, st &= 8191, rt = Ne, rt += Le * Qt, rt += ze * Ht, rt += ke * Bt, rt += ie * K, rt += se * gt, Ne = rt >>> 13, rt &= 8191, rt += me * wt, rt += ce * vt, rt += de * (5 * jt), rt += xe * (5 * zt), rt += at * (5 * Mt), Ne += rt >>> 13, rt &= 8191, Pe = Ne, Pe += Le * Mt, Pe += ze * Qt, Pe += ke * Ht, Pe += ie * Bt, Pe += se * K, Ne = Pe >>> 13, Pe &= 8191, Pe += me * gt, Pe += ce * wt, Pe += de * vt, Pe += xe * (5 * jt), Pe += at * (5 * zt), Ne += Pe >>> 13, Pe &= 8191, He = Ne, He += Le * zt, He += ze * Mt, He += ke * Qt, He += ie * Ht, He += se * Bt, Ne = He >>> 13, He &= 8191, He += me * K, He += ce * gt, He += de * wt, He += xe * vt, He += at * (5 * jt), Ne += He >>> 13, He &= 8191, Oe = Ne, Oe += Le * jt, Oe += ze * zt, Oe += ke * Mt, Oe += ie * Qt, Oe += se * Ht, Ne = Oe >>> 13, Oe &= 8191, Oe += me * Bt, Oe += ce * K, Oe += de * gt, Oe += xe * wt, Oe += at * vt, Ne += Oe >>> 13, Oe &= 8191, Ne = (Ne << 2) + Ne | 0, Ne = Ne + Ge | 0, Ge = Ne & 8191, Ne = Ne >>> 13, Ke += Ne, Le = Ge, ze = Ke, ke = Je, ie = ut, se = tt, me = st, ce = rt, de = Pe, xe = He, at = Oe, L += 16, F -= 16;
            this.h[0] = Le, this.h[1] = ze, this.h[2] = ke, this.h[3] = ie, this.h[4] = se, this.h[5] = me, this.h[6] = ce, this.h[7] = de, this.h[8] = xe, this.h[9] = at
        }, H.prototype.finish = function(B, L) {
            var F = new Uint16Array(10),
                g, U, Z, ee;
            if (this.leftover) {
                for (ee = this.leftover, this.buffer[ee++] = 1; ee < 16; ee++) this.buffer[ee] = 0;
                this.fin = 1, this.blocks(this.buffer, 0, 16)
            }
            for (g = this.h[1] >>> 13, this.h[1] &= 8191, ee = 2; ee < 10; ee++) this.h[ee] += g, g = this.h[ee] >>> 13, this.h[ee] &= 8191;
            for (this.h[0] += g * 5, g = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += g, g = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += g, F[0] = this.h[0] + 5, g = F[0] >>> 13, F[0] &= 8191, ee = 1; ee < 10; ee++) F[ee] = this.h[ee] + g, g = F[ee] >>> 13, F[ee] &= 8191;
            for (F[9] -= 1 << 13, U = (g ^ 1) - 1, ee = 0; ee < 10; ee++) F[ee] &= U;
            for (U = ~U, ee = 0; ee < 10; ee++) this.h[ee] = this.h[ee] & U | F[ee];
            for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Z = this.h[0] + this.pad[0], this.h[0] = Z & 65535, ee = 1; ee < 8; ee++) Z = (this.h[ee] + this.pad[ee] | 0) + (Z >>> 16) | 0, this.h[ee] = Z & 65535;
            B[L + 0] = this.h[0] >>> 0 & 255, B[L + 1] = this.h[0] >>> 8 & 255, B[L + 2] = this.h[1] >>> 0 & 255, B[L + 3] = this.h[1] >>> 8 & 255, B[L + 4] = this.h[2] >>> 0 & 255, B[L + 5] = this.h[2] >>> 8 & 255, B[L + 6] = this.h[3] >>> 0 & 255, B[L + 7] = this.h[3] >>> 8 & 255, B[L + 8] = this.h[4] >>> 0 & 255, B[L + 9] = this.h[4] >>> 8 & 255, B[L + 10] = this.h[5] >>> 0 & 255, B[L + 11] = this.h[5] >>> 8 & 255, B[L + 12] = this.h[6] >>> 0 & 255, B[L + 13] = this.h[6] >>> 8 & 255, B[L + 14] = this.h[7] >>> 0 & 255, B[L + 15] = this.h[7] >>> 8 & 255
        }, H.prototype.update = function(B, L, F) {
            var g, U;
            if (this.leftover) {
                for (U = 16 - this.leftover, U > F && (U = F), g = 0; g < U; g++) this.buffer[this.leftover + g] = B[L + g];
                if (F -= U, L += U, this.leftover += U, this.leftover < 16) return;
                this.blocks(this.buffer, 0, 16), this.leftover = 0
            }
            if (F >= 16 && (U = F - F % 16, this.blocks(B, L, U), L += U, F -= U), F) {
                for (g = 0; g < F; g++) this.buffer[this.leftover + g] = B[L + g];
                this.leftover += F
            }
        };

        function w(B, L, F, g, U, Z) {
            var ee = new H(Z);
            return ee.update(F, g, U), ee.finish(B, L), 0
        }

        function p(B, L, F, g, U, Z) {
            var ee = new Uint8Array(16);
            return w(ee, 0, F, g, U, Z), V(B, L, ee, 0)
        }

        function f(B, L, F, g, U) {
            var Z;
            if (F < 32) return -1;
            for (we(B, 0, L, 0, F, g, U), w(B, 16, B, 32, F - 32, B), Z = 0; Z < 16; Z++) B[Z] = 0;
            return 0
        }

        function h(B, L, F, g, U) {
            var Z, ee = new Uint8Array(32);
            if (F < 32 || (pe(ee, 0, 32, g, U), p(L, 16, L, 32, F - 32, ee) !== 0)) return -1;
            for (we(B, 0, L, 0, F, g, U), Z = 0; Z < 32; Z++) B[Z] = 0;
            return 0
        }

        function b(B, L) {
            var F;
            for (F = 0; F < 16; F++) B[F] = L[F] | 0
        }

        function C(B) {
            var L, F, g = 1;
            for (L = 0; L < 16; L++) F = B[L] + g + 65535, g = Math.floor(F / 65536), B[L] = F - g * 65536;
            B[0] += g - 1 + 37 * (g - 1)
        }

        function _(B, L, F) {
            for (var g, U = ~(F - 1), Z = 0; Z < 16; Z++) g = U & (B[Z] ^ L[Z]), B[Z] ^= g, L[Z] ^= g
        }

        function M(B, L) {
            var F, g, U, Z = r(),
                ee = r();
            for (F = 0; F < 16; F++) ee[F] = L[F];
            for (C(ee), C(ee), C(ee), g = 0; g < 2; g++) {
                for (Z[0] = ee[0] - 65517, F = 1; F < 15; F++) Z[F] = ee[F] - 65535 - (Z[F - 1] >> 16 & 1), Z[F - 1] &= 65535;
                Z[15] = ee[15] - 32767 - (Z[14] >> 16 & 1), U = Z[15] >> 16 & 1, Z[14] &= 65535, _(ee, Z, 1 - U)
            }
            for (F = 0; F < 16; F++) B[2 * F] = ee[F] & 255, B[2 * F + 1] = ee[F] >> 8
        }

        function m(B, L) {
            var F = new Uint8Array(32),
                g = new Uint8Array(32);
            return M(F, B), M(g, L), P(F, 0, g, 0)
        }

        function A(B) {
            var L = new Uint8Array(32);
            return M(L, B), L[0] & 1
        }

        function x(B, L) {
            var F;
            for (F = 0; F < 16; F++) B[F] = L[2 * F] + (L[2 * F + 1] << 8);
            B[15] &= 32767
        }

        function z(B, L, F) {
            for (var g = 0; g < 16; g++) B[g] = L[g] + F[g]
        }

        function oe(B, L, F) {
            for (var g = 0; g < 16; g++) B[g] = L[g] - F[g]
        }

        function k(B, L, F) {
            var g, U, Z = 0,
                ee = 0,
                te = 0,
                fe = 0,
                Ae = 0,
                ye = 0,
                dt = 0,
                Ne = 0,
                Ge = 0,
                Ke = 0,
                Je = 0,
                ut = 0,
                tt = 0,
                st = 0,
                rt = 0,
                Pe = 0,
                He = 0,
                Oe = 0,
                Le = 0,
                ze = 0,
                ke = 0,
                ie = 0,
                se = 0,
                me = 0,
                ce = 0,
                de = 0,
                xe = 0,
                at = 0,
                vt = 0,
                wt = 0,
                gt = 0,
                K = F[0],
                Bt = F[1],
                Ht = F[2],
                Qt = F[3],
                Mt = F[4],
                zt = F[5],
                jt = F[6],
                Ir = F[7],
                nr = F[8],
                br = F[9],
                Ar = F[10],
                Sr = F[11],
                Nr = F[12],
                rn = F[13],
                nn = F[14],
                sn = F[15];
            g = L[0], Z += g * K, ee += g * Bt, te += g * Ht, fe += g * Qt, Ae += g * Mt, ye += g * zt, dt += g * jt, Ne += g * Ir, Ge += g * nr, Ke += g * br, Je += g * Ar, ut += g * Sr, tt += g * Nr, st += g * rn, rt += g * nn, Pe += g * sn, g = L[1], ee += g * K, te += g * Bt, fe += g * Ht, Ae += g * Qt, ye += g * Mt, dt += g * zt, Ne += g * jt, Ge += g * Ir, Ke += g * nr, Je += g * br, ut += g * Ar, tt += g * Sr, st += g * Nr, rt += g * rn, Pe += g * nn, He += g * sn, g = L[2], te += g * K, fe += g * Bt, Ae += g * Ht, ye += g * Qt, dt += g * Mt, Ne += g * zt, Ge += g * jt, Ke += g * Ir, Je += g * nr, ut += g * br, tt += g * Ar, st += g * Sr, rt += g * Nr, Pe += g * rn, He += g * nn, Oe += g * sn, g = L[3], fe += g * K, Ae += g * Bt, ye += g * Ht, dt += g * Qt, Ne += g * Mt, Ge += g * zt, Ke += g * jt, Je += g * Ir, ut += g * nr, tt += g * br, st += g * Ar, rt += g * Sr, Pe += g * Nr, He += g * rn, Oe += g * nn, Le += g * sn, g = L[4], Ae += g * K, ye += g * Bt, dt += g * Ht, Ne += g * Qt, Ge += g * Mt, Ke += g * zt, Je += g * jt, ut += g * Ir, tt += g * nr, st += g * br, rt += g * Ar, Pe += g * Sr, He += g * Nr, Oe += g * rn, Le += g * nn, ze += g * sn, g = L[5], ye += g * K, dt += g * Bt, Ne += g * Ht, Ge += g * Qt, Ke += g * Mt, Je += g * zt, ut += g * jt, tt += g * Ir, st += g * nr, rt += g * br, Pe += g * Ar, He += g * Sr, Oe += g * Nr, Le += g * rn, ze += g * nn, ke += g * sn, g = L[6], dt += g * K, Ne += g * Bt, Ge += g * Ht, Ke += g * Qt, Je += g * Mt, ut += g * zt, tt += g * jt, st += g * Ir, rt += g * nr, Pe += g * br, He += g * Ar, Oe += g * Sr, Le += g * Nr, ze += g * rn, ke += g * nn, ie += g * sn, g = L[7], Ne += g * K, Ge += g * Bt, Ke += g * Ht, Je += g * Qt, ut += g * Mt, tt += g * zt, st += g * jt, rt += g * Ir, Pe += g * nr, He += g * br, Oe += g * Ar, Le += g * Sr, ze += g * Nr, ke += g * rn, ie += g * nn, se += g * sn, g = L[8], Ge += g * K, Ke += g * Bt, Je += g * Ht, ut += g * Qt, tt += g * Mt, st += g * zt, rt += g * jt, Pe += g * Ir, He += g * nr, Oe += g * br, Le += g * Ar, ze += g * Sr, ke += g * Nr, ie += g * rn, se += g * nn, me += g * sn, g = L[9], Ke += g * K, Je += g * Bt, ut += g * Ht, tt += g * Qt, st += g * Mt, rt += g * zt, Pe += g * jt, He += g * Ir, Oe += g * nr, Le += g * br, ze += g * Ar, ke += g * Sr, ie += g * Nr, se += g * rn, me += g * nn, ce += g * sn, g = L[10], Je += g * K, ut += g * Bt, tt += g * Ht, st += g * Qt, rt += g * Mt, Pe += g * zt, He += g * jt, Oe += g * Ir, Le += g * nr, ze += g * br, ke += g * Ar, ie += g * Sr, se += g * Nr, me += g * rn, ce += g * nn, de += g * sn, g = L[11], ut += g * K, tt += g * Bt, st += g * Ht, rt += g * Qt, Pe += g * Mt, He += g * zt, Oe += g * jt, Le += g * Ir, ze += g * nr, ke += g * br, ie += g * Ar, se += g * Sr, me += g * Nr, ce += g * rn, de += g * nn, xe += g * sn, g = L[12], tt += g * K, st += g * Bt, rt += g * Ht, Pe += g * Qt, He += g * Mt, Oe += g * zt, Le += g * jt, ze += g * Ir, ke += g * nr, ie += g * br, se += g * Ar, me += g * Sr, ce += g * Nr, de += g * rn, xe += g * nn, at += g * sn, g = L[13], st += g * K, rt += g * Bt, Pe += g * Ht, He += g * Qt, Oe += g * Mt, Le += g * zt, ze += g * jt, ke += g * Ir, ie += g * nr, se += g * br, me += g * Ar, ce += g * Sr, de += g * Nr, xe += g * rn, at += g * nn, vt += g * sn, g = L[14], rt += g * K, Pe += g * Bt, He += g * Ht, Oe += g * Qt, Le += g * Mt, ze += g * zt, ke += g * jt, ie += g * Ir, se += g * nr, me += g * br, ce += g * Ar, de += g * Sr, xe += g * Nr, at += g * rn, vt += g * nn, wt += g * sn, g = L[15], Pe += g * K, He += g * Bt, Oe += g * Ht, Le += g * Qt, ze += g * Mt, ke += g * zt, ie += g * jt, se += g * Ir, me += g * nr, ce += g * br, de += g * Ar, xe += g * Sr, at += g * Nr, vt += g * rn, wt += g * nn, gt += g * sn, Z += 38 * He, ee += 38 * Oe, te += 38 * Le, fe += 38 * ze, Ae += 38 * ke, ye += 38 * ie, dt += 38 * se, Ne += 38 * me, Ge += 38 * ce, Ke += 38 * de, Je += 38 * xe, ut += 38 * at, tt += 38 * vt, st += 38 * wt, rt += 38 * gt, U = 1, g = Z + U + 65535, U = Math.floor(g / 65536), Z = g - U * 65536, g = ee + U + 65535, U = Math.floor(g / 65536), ee = g - U * 65536, g = te + U + 65535, U = Math.floor(g / 65536), te = g - U * 65536, g = fe + U + 65535, U = Math.floor(g / 65536), fe = g - U * 65536, g = Ae + U + 65535, U = Math.floor(g / 65536), Ae = g - U * 65536, g = ye + U + 65535, U = Math.floor(g / 65536), ye = g - U * 65536, g = dt + U + 65535, U = Math.floor(g / 65536), dt = g - U * 65536, g = Ne + U + 65535, U = Math.floor(g / 65536), Ne = g - U * 65536, g = Ge + U + 65535, U = Math.floor(g / 65536), Ge = g - U * 65536, g = Ke + U + 65535, U = Math.floor(g / 65536), Ke = g - U * 65536, g = Je + U + 65535, U = Math.floor(g / 65536), Je = g - U * 65536, g = ut + U + 65535, U = Math.floor(g / 65536), ut = g - U * 65536, g = tt + U + 65535, U = Math.floor(g / 65536), tt = g - U * 65536, g = st + U + 65535, U = Math.floor(g / 65536), st = g - U * 65536, g = rt + U + 65535, U = Math.floor(g / 65536), rt = g - U * 65536, g = Pe + U + 65535, U = Math.floor(g / 65536), Pe = g - U * 65536, Z += U - 1 + 37 * (U - 1), U = 1, g = Z + U + 65535, U = Math.floor(g / 65536), Z = g - U * 65536, g = ee + U + 65535, U = Math.floor(g / 65536), ee = g - U * 65536, g = te + U + 65535, U = Math.floor(g / 65536), te = g - U * 65536, g = fe + U + 65535, U = Math.floor(g / 65536), fe = g - U * 65536, g = Ae + U + 65535, U = Math.floor(g / 65536), Ae = g - U * 65536, g = ye + U + 65535, U = Math.floor(g / 65536), ye = g - U * 65536, g = dt + U + 65535, U = Math.floor(g / 65536), dt = g - U * 65536, g = Ne + U + 65535, U = Math.floor(g / 65536), Ne = g - U * 65536, g = Ge + U + 65535, U = Math.floor(g / 65536), Ge = g - U * 65536, g = Ke + U + 65535, U = Math.floor(g / 65536), Ke = g - U * 65536, g = Je + U + 65535, U = Math.floor(g / 65536), Je = g - U * 65536, g = ut + U + 65535, U = Math.floor(g / 65536), ut = g - U * 65536, g = tt + U + 65535, U = Math.floor(g / 65536), tt = g - U * 65536, g = st + U + 65535, U = Math.floor(g / 65536), st = g - U * 65536, g = rt + U + 65535, U = Math.floor(g / 65536), rt = g - U * 65536, g = Pe + U + 65535, U = Math.floor(g / 65536), Pe = g - U * 65536, Z += U - 1 + 37 * (U - 1), B[0] = Z, B[1] = ee, B[2] = te, B[3] = fe, B[4] = Ae, B[5] = ye, B[6] = dt, B[7] = Ne, B[8] = Ge, B[9] = Ke, B[10] = Je, B[11] = ut, B[12] = tt, B[13] = st, B[14] = rt, B[15] = Pe
        }

        function X(B, L) {
            k(B, L, L)
        }

        function re(B, L) {
            var F = r(),
                g;
            for (g = 0; g < 16; g++) F[g] = L[g];
            for (g = 253; g >= 0; g--) X(F, F), g !== 2 && g !== 4 && k(F, F, L);
            for (g = 0; g < 16; g++) B[g] = F[g]
        }

        function ae(B, L) {
            var F = r(),
                g;
            for (g = 0; g < 16; g++) F[g] = L[g];
            for (g = 250; g >= 0; g--) X(F, F), g !== 1 && k(F, F, L);
            for (g = 0; g < 16; g++) B[g] = F[g]
        }

        function le(B, L, F) {
            var g = new Uint8Array(32),
                U = new Float64Array(80),
                Z, ee, te = r(),
                fe = r(),
                Ae = r(),
                ye = r(),
                dt = r(),
                Ne = r();
            for (ee = 0; ee < 31; ee++) g[ee] = L[ee];
            for (g[31] = L[31] & 127 | 64, g[0] &= 248, x(U, F), ee = 0; ee < 16; ee++) fe[ee] = U[ee], ye[ee] = te[ee] = Ae[ee] = 0;
            for (te[0] = ye[0] = 1, ee = 254; ee >= 0; --ee) Z = g[ee >>> 3] >>> (ee & 7) & 1, _(te, fe, Z), _(Ae, ye, Z), z(dt, te, Ae), oe(te, te, Ae), z(Ae, fe, ye), oe(fe, fe, ye), X(ye, dt), X(Ne, te), k(te, Ae, te), k(Ae, fe, dt), z(dt, te, Ae), oe(te, te, Ae), X(fe, te), oe(Ae, ye, Ne), k(te, Ae, c), z(te, te, ye), k(Ae, Ae, te), k(te, ye, Ne), k(ye, fe, U), X(fe, dt), _(te, fe, Z), _(Ae, ye, Z);
            for (ee = 0; ee < 16; ee++) U[ee + 16] = te[ee], U[ee + 32] = Ae[ee], U[ee + 48] = fe[ee], U[ee + 64] = ye[ee];
            var Ge = U.subarray(32),
                Ke = U.subarray(16);
            return re(Ge, Ge), k(Ke, Ke, Ge), M(B, Ke), 0
        }

        function Me(B, L) {
            return le(B, L, s)
        }

        function Re(B, L) {
            return n(L, 32), Me(B, L)
        }

        function ve(B, L, F) {
            var g = new Uint8Array(32);
            return le(g, F, L), W(B, i, g, Y)
        }
        var We = f,
            Ie = h;

        function Ue(B, L, F, g, U, Z) {
            var ee = new Uint8Array(32);
            return ve(ee, U, Z), We(B, L, F, g, ee)
        }

        function Ut(B, L, F, g, U, Z) {
            var ee = new Uint8Array(32);
            return ve(ee, U, Z), Ie(B, L, F, g, ee)
        }
        var It = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

        function it(B, L, F, g) {
            for (var U = new Int32Array(16), Z = new Int32Array(16), ee, te, fe, Ae, ye, dt, Ne, Ge, Ke, Je, ut, tt, st, rt, Pe, He, Oe, Le, ze, ke, ie, se, me, ce, de, xe, at = B[0], vt = B[1], wt = B[2], gt = B[3], K = B[4], Bt = B[5], Ht = B[6], Qt = B[7], Mt = L[0], zt = L[1], jt = L[2], Ir = L[3], nr = L[4], br = L[5], Ar = L[6], Sr = L[7], Nr = 0; g >= 128;) {
                for (ze = 0; ze < 16; ze++) ke = 8 * ze + Nr, U[ze] = F[ke + 0] << 24 | F[ke + 1] << 16 | F[ke + 2] << 8 | F[ke + 3], Z[ze] = F[ke + 4] << 24 | F[ke + 5] << 16 | F[ke + 6] << 8 | F[ke + 7];
                for (ze = 0; ze < 80; ze++)
                    if (ee = at, te = vt, fe = wt, Ae = gt, ye = K, dt = Bt, Ne = Ht, Ge = Qt, Ke = Mt, Je = zt, ut = jt, tt = Ir, st = nr, rt = br, Pe = Ar, He = Sr, ie = Qt, se = Sr, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = (K >>> 14 | nr << 32 - 14) ^ (K >>> 18 | nr << 32 - 18) ^ (nr >>> 41 - 32 | K << 32 - (41 - 32)), se = (nr >>> 14 | K << 32 - 14) ^ (nr >>> 18 | K << 32 - 18) ^ (K >>> 41 - 32 | nr << 32 - (41 - 32)), me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ie = K & Bt ^ ~K & Ht, se = nr & br ^ ~nr & Ar, me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ie = It[ze * 2], se = It[ze * 2 + 1], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ie = U[ze % 16], se = Z[ze % 16], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, Oe = de & 65535 | xe << 16, Le = me & 65535 | ce << 16, ie = Oe, se = Le, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = (at >>> 28 | Mt << 32 - 28) ^ (Mt >>> 34 - 32 | at << 32 - (34 - 32)) ^ (Mt >>> 39 - 32 | at << 32 - (39 - 32)), se = (Mt >>> 28 | at << 32 - 28) ^ (at >>> 34 - 32 | Mt << 32 - (34 - 32)) ^ (at >>> 39 - 32 | Mt << 32 - (39 - 32)), me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ie = at & vt ^ at & wt ^ vt & wt, se = Mt & zt ^ Mt & jt ^ zt & jt, me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, Ge = de & 65535 | xe << 16, He = me & 65535 | ce << 16, ie = Ae, se = tt, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = Oe, se = Le, me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, Ae = de & 65535 | xe << 16, tt = me & 65535 | ce << 16, vt = ee, wt = te, gt = fe, K = Ae, Bt = ye, Ht = dt, Qt = Ne, at = Ge, zt = Ke, jt = Je, Ir = ut, nr = tt, br = st, Ar = rt, Sr = Pe, Mt = He, ze % 16 === 15)
                        for (ke = 0; ke < 16; ke++) ie = U[ke], se = Z[ke], me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = U[(ke + 9) % 16], se = Z[(ke + 9) % 16], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, Oe = U[(ke + 1) % 16], Le = Z[(ke + 1) % 16], ie = (Oe >>> 1 | Le << 32 - 1) ^ (Oe >>> 8 | Le << 32 - 8) ^ Oe >>> 7, se = (Le >>> 1 | Oe << 32 - 1) ^ (Le >>> 8 | Oe << 32 - 8) ^ (Le >>> 7 | Oe << 32 - 7), me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, Oe = U[(ke + 14) % 16], Le = Z[(ke + 14) % 16], ie = (Oe >>> 19 | Le << 32 - 19) ^ (Le >>> 61 - 32 | Oe << 32 - (61 - 32)) ^ Oe >>> 6, se = (Le >>> 19 | Oe << 32 - 19) ^ (Oe >>> 61 - 32 | Le << 32 - (61 - 32)) ^ (Le >>> 6 | Oe << 32 - 6), me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, U[ke] = de & 65535 | xe << 16, Z[ke] = me & 65535 | ce << 16;
                ie = at, se = Mt, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = B[0], se = L[0], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, B[0] = at = de & 65535 | xe << 16, L[0] = Mt = me & 65535 | ce << 16, ie = vt, se = zt, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = B[1], se = L[1], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, B[1] = vt = de & 65535 | xe << 16, L[1] = zt = me & 65535 | ce << 16, ie = wt, se = jt, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = B[2], se = L[2], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, B[2] = wt = de & 65535 | xe << 16, L[2] = jt = me & 65535 | ce << 16, ie = gt, se = Ir, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = B[3], se = L[3], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, B[3] = gt = de & 65535 | xe << 16, L[3] = Ir = me & 65535 | ce << 16, ie = K, se = nr, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = B[4], se = L[4], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, B[4] = K = de & 65535 | xe << 16, L[4] = nr = me & 65535 | ce << 16, ie = Bt, se = br, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = B[5], se = L[5], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, B[5] = Bt = de & 65535 | xe << 16, L[5] = br = me & 65535 | ce << 16, ie = Ht, se = Ar, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = B[6], se = L[6], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, B[6] = Ht = de & 65535 | xe << 16, L[6] = Ar = me & 65535 | ce << 16, ie = Qt, se = Sr, me = se & 65535, ce = se >>> 16, de = ie & 65535, xe = ie >>> 16, ie = B[7], se = L[7], me += se & 65535, ce += se >>> 16, de += ie & 65535, xe += ie >>> 16, ce += me >>> 16, de += ce >>> 16, xe += de >>> 16, B[7] = Qt = de & 65535 | xe << 16, L[7] = Sr = me & 65535 | ce << 16, Nr += 128, g -= 128
            }
            return g
        }

        function At(B, L, F) {
            var g = new Int32Array(8),
                U = new Int32Array(8),
                Z = new Uint8Array(256),
                ee, te = F;
            for (g[0] = 1779033703, g[1] = 3144134277, g[2] = 1013904242, g[3] = 2773480762, g[4] = 1359893119, g[5] = 2600822924, g[6] = 528734635, g[7] = 1541459225, U[0] = 4089235720, U[1] = 2227873595, U[2] = 4271175723, U[3] = 1595750129, U[4] = 2917565137, U[5] = 725511199, U[6] = 4215389547, U[7] = 327033209, it(g, U, L, F), F %= 128, ee = 0; ee < F; ee++) Z[ee] = L[te - F + ee];
            for (Z[F] = 128, F = 256 - 128 * (F < 112 ? 1 : 0), Z[F - 9] = 0, T(Z, F - 8, te / 536870912 | 0, te << 3), it(g, U, Z, F), ee = 0; ee < 8; ee++) T(B, 8 * ee, g[ee], U[ee]);
            return 0
        }

        function Ct(B, L) {
            var F = r(),
                g = r(),
                U = r(),
                Z = r(),
                ee = r(),
                te = r(),
                fe = r(),
                Ae = r(),
                ye = r();
            oe(F, B[1], B[0]), oe(ye, L[1], L[0]), k(F, F, ye), z(g, B[0], B[1]), z(ye, L[0], L[1]), k(g, g, ye), k(U, B[3], L[3]), k(U, U, y), k(Z, B[2], L[2]), z(Z, Z, Z), oe(ee, g, F), oe(te, Z, U), z(fe, Z, U), z(Ae, g, F), k(B[0], ee, te), k(B[1], Ae, fe), k(B[2], fe, te), k(B[3], ee, Ae)
        }

        function Ye(B, L, F) {
            var g;
            for (g = 0; g < 4; g++) _(B[g], L[g], F)
        }

        function Xe(B, L) {
            var F = r(),
                g = r(),
                U = r();
            re(U, L[2]), k(F, L[0], U), k(g, L[1], U), M(B, g), B[31] ^= A(F) << 7
        }

        function St(B, L, F) {
            var g, U;
            for (b(B[0], o), b(B[1], a), b(B[2], a), b(B[3], o), U = 255; U >= 0; --U) g = F[U / 8 | 0] >> (U & 7) & 1, Ye(B, L, g), Ct(L, B), Ct(B, B), Ye(B, L, g)
        }

        function Ze(B, L) {
            var F = [r(), r(), r(), r()];
            b(F[0], I), b(F[1], N), b(F[2], a), k(F[3], I, N), St(B, F, L)
        }

        function ft(B, L, F) {
            var g = new Uint8Array(64),
                U = [r(), r(), r(), r()],
                Z;
            for (F || n(L, 32), At(g, L, 32), g[0] &= 248, g[31] &= 127, g[31] |= 64, Ze(U, g), Xe(B, U), Z = 0; Z < 32; Z++) L[Z + 32] = B[Z];
            return 0
        }
        var Ot = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

        function v(B, L) {
            var F, g, U, Z;
            for (g = 63; g >= 32; --g) {
                for (F = 0, U = g - 32, Z = g - 12; U < Z; ++U) L[U] += F - 16 * L[g] * Ot[U - (g - 32)], F = Math.floor((L[U] + 128) / 256), L[U] -= F * 256;
                L[U] += F, L[g] = 0
            }
            for (F = 0, U = 0; U < 32; U++) L[U] += F - (L[31] >> 4) * Ot[U], F = L[U] >> 8, L[U] &= 255;
            for (U = 0; U < 32; U++) L[U] -= F * Ot[U];
            for (g = 0; g < 32; g++) L[g + 1] += L[g] >> 8, B[g] = L[g] & 255
        }

        function u(B) {
            var L = new Float64Array(64),
                F;
            for (F = 0; F < 64; F++) L[F] = B[F];
            for (F = 0; F < 64; F++) B[F] = 0;
            v(B, L)
        }

        function l(B, L, F, g) {
            var U = new Uint8Array(64),
                Z = new Uint8Array(64),
                ee = new Uint8Array(64),
                te, fe, Ae = new Float64Array(64),
                ye = [r(), r(), r(), r()];
            At(U, g, 32), U[0] &= 248, U[31] &= 127, U[31] |= 64;
            var dt = F + 64;
            for (te = 0; te < F; te++) B[64 + te] = L[te];
            for (te = 0; te < 32; te++) B[32 + te] = U[32 + te];
            for (At(ee, B.subarray(32), F + 32), u(ee), Ze(ye, ee), Xe(B, ye), te = 32; te < 64; te++) B[te] = g[te];
            for (At(Z, B, F + 64), u(Z), te = 0; te < 64; te++) Ae[te] = 0;
            for (te = 0; te < 32; te++) Ae[te] = ee[te];
            for (te = 0; te < 32; te++)
                for (fe = 0; fe < 32; fe++) Ae[te + fe] += Z[te] * U[fe];
            return v(B.subarray(32), Ae), dt
        }

        function S(B, L) {
            var F = r(),
                g = r(),
                U = r(),
                Z = r(),
                ee = r(),
                te = r(),
                fe = r();
            return b(B[2], a), x(B[1], L), X(U, B[1]), k(Z, U, d), oe(U, U, B[2]), z(Z, B[2], Z), X(ee, Z), X(te, ee), k(fe, te, ee), k(F, fe, U), k(F, F, Z), ae(F, F), k(F, F, U), k(F, F, Z), k(F, F, Z), k(B[0], F, Z), X(g, B[0]), k(g, g, Z), m(g, U) && k(B[0], B[0], E), X(g, B[0]), k(g, g, Z), m(g, U) ? -1 : (A(B[0]) === L[31] >> 7 && oe(B[0], o, B[0]), k(B[3], B[0], B[1]), 0)
        }

        function D(B, L, F, g) {
            var U, Z = new Uint8Array(32),
                ee = new Uint8Array(64),
                te = [r(), r(), r(), r()],
                fe = [r(), r(), r(), r()];
            if (F < 64 || S(fe, g)) return -1;
            for (U = 0; U < F; U++) B[U] = L[U];
            for (U = 0; U < 32; U++) B[U + 32] = g[U];
            if (At(ee, B, F), u(ee), St(te, fe, ee), Ze(fe, L.subarray(32)), Ct(te, fe), Xe(Z, te), F -= 64, P(L, 0, Z, 0)) {
                for (U = 0; U < F; U++) B[U] = 0;
                return -1
            }
            for (U = 0; U < F; U++) B[U] = L[U + 64];
            return F
        }
        var $ = 32,
            Q = 24,
            he = 32,
            Be = 16,
            ge = 32,
            Te = 32,
            Se = 32,
            ot = 32,
            Gt = 32,
            Zt = Q,
            ht = he,
            tr = Be,
            Nt = 64,
            et = 32,
            Lt = 64,
            Yt = 32,
            ct = 64;
        e.lowlevel = {
            crypto_core_hsalsa20: W,
            crypto_stream_xor: we,
            crypto_stream: pe,
            crypto_stream_salsa20_xor: G,
            crypto_stream_salsa20: J,
            crypto_onetimeauth: w,
            crypto_onetimeauth_verify: p,
            crypto_verify_16: V,
            crypto_verify_32: P,
            crypto_secretbox: f,
            crypto_secretbox_open: h,
            crypto_scalarmult: le,
            crypto_scalarmult_base: Me,
            crypto_box_beforenm: ve,
            crypto_box_afternm: We,
            crypto_box: Ue,
            crypto_box_open: Ut,
            crypto_box_keypair: Re,
            crypto_hash: At,
            crypto_sign: l,
            crypto_sign_keypair: ft,
            crypto_sign_open: D,
            crypto_secretbox_KEYBYTES: $,
            crypto_secretbox_NONCEBYTES: Q,
            crypto_secretbox_ZEROBYTES: he,
            crypto_secretbox_BOXZEROBYTES: Be,
            crypto_scalarmult_BYTES: ge,
            crypto_scalarmult_SCALARBYTES: Te,
            crypto_box_PUBLICKEYBYTES: Se,
            crypto_box_SECRETKEYBYTES: ot,
            crypto_box_BEFORENMBYTES: Gt,
            crypto_box_NONCEBYTES: Zt,
            crypto_box_ZEROBYTES: ht,
            crypto_box_BOXZEROBYTES: tr,
            crypto_sign_BYTES: Nt,
            crypto_sign_PUBLICKEYBYTES: et,
            crypto_sign_SECRETKEYBYTES: Lt,
            crypto_sign_SEEDBYTES: Yt,
            crypto_hash_BYTES: ct,
            gf: r,
            D: d,
            L: Ot,
            pack25519: M,
            unpack25519: x,
            M: k,
            A: z,
            S: X,
            Z: oe,
            pow2523: ae,
            add: Ct,
            set25519: b,
            modL: v,
            scalarmult: St,
            scalarbase: Ze
        };

        function Jt(B, L) {
            if (B.length !== $) throw new Error("bad key size");
            if (L.length !== Q) throw new Error("bad nonce size")
        }

        function rr(B, L) {
            if (B.length !== Se) throw new Error("bad public key size");
            if (L.length !== ot) throw new Error("bad secret key size")
        }

        function Ve() {
            for (var B = 0; B < arguments.length; B++)
                if (!(arguments[B] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array")
        }

        function Xt(B) {
            for (var L = 0; L < B.length; L++) B[L] = 0
        }
        e.randomBytes = function(B) {
                var L = new Uint8Array(B);
                return n(L, B), L
            }, e.secretbox = function(B, L, F) {
                Ve(B, L, F), Jt(F, L);
                for (var g = new Uint8Array(he + B.length), U = new Uint8Array(g.length), Z = 0; Z < B.length; Z++) g[Z + he] = B[Z];
                return f(U, g, g.length, L, F), U.subarray(Be)
            }, e.secretbox.open = function(B, L, F) {
                Ve(B, L, F), Jt(F, L);
                for (var g = new Uint8Array(Be + B.length), U = new Uint8Array(g.length), Z = 0; Z < B.length; Z++) g[Z + Be] = B[Z];
                return g.length < 32 || h(U, g, g.length, L, F) !== 0 ? null : U.subarray(he)
            }, e.secretbox.keyLength = $, e.secretbox.nonceLength = Q, e.secretbox.overheadLength = Be, e.scalarMult = function(B, L) {
                if (Ve(B, L), B.length !== Te) throw new Error("bad n size");
                if (L.length !== ge) throw new Error("bad p size");
                var F = new Uint8Array(ge);
                return le(F, B, L), F
            }, e.scalarMult.base = function(B) {
                if (Ve(B), B.length !== Te) throw new Error("bad n size");
                var L = new Uint8Array(ge);
                return Me(L, B), L
            }, e.scalarMult.scalarLength = Te, e.scalarMult.groupElementLength = ge, e.box = function(B, L, F, g) {
                var U = e.box.before(F, g);
                return e.secretbox(B, L, U)
            }, e.box.before = function(B, L) {
                Ve(B, L), rr(B, L);
                var F = new Uint8Array(Gt);
                return ve(F, B, L), F
            }, e.box.after = e.secretbox, e.box.open = function(B, L, F, g) {
                var U = e.box.before(F, g);
                return e.secretbox.open(B, L, U)
            }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
                var B = new Uint8Array(Se),
                    L = new Uint8Array(ot);
                return Re(B, L), {
                    publicKey: B,
                    secretKey: L
                }
            }, e.box.keyPair.fromSecretKey = function(B) {
                if (Ve(B), B.length !== ot) throw new Error("bad secret key size");
                var L = new Uint8Array(Se);
                return Me(L, B), {
                    publicKey: L,
                    secretKey: new Uint8Array(B)
                }
            }, e.box.publicKeyLength = Se, e.box.secretKeyLength = ot, e.box.sharedKeyLength = Gt, e.box.nonceLength = Zt, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(B, L) {
                if (Ve(B, L), L.length !== Lt) throw new Error("bad secret key size");
                var F = new Uint8Array(Nt + B.length);
                return l(F, B, B.length, L), F
            }, e.sign.open = function(B, L) {
                if (Ve(B, L), L.length !== et) throw new Error("bad public key size");
                var F = new Uint8Array(B.length),
                    g = D(F, B, B.length, L);
                if (g < 0) return null;
                for (var U = new Uint8Array(g), Z = 0; Z < U.length; Z++) U[Z] = F[Z];
                return U
            }, e.sign.detached = function(B, L) {
                for (var F = e.sign(B, L), g = new Uint8Array(Nt), U = 0; U < g.length; U++) g[U] = F[U];
                return g
            }, e.sign.detached.verify = function(B, L, F) {
                if (Ve(B, L, F), L.length !== Nt) throw new Error("bad signature size");
                if (F.length !== et) throw new Error("bad public key size");
                var g = new Uint8Array(Nt + B.length),
                    U = new Uint8Array(Nt + B.length),
                    Z;
                for (Z = 0; Z < Nt; Z++) g[Z] = L[Z];
                for (Z = 0; Z < B.length; Z++) g[Z + Nt] = B[Z];
                return D(U, g, g.length, F) >= 0
            }, e.sign.keyPair = function() {
                var B = new Uint8Array(et),
                    L = new Uint8Array(Lt);
                return ft(B, L), {
                    publicKey: B,
                    secretKey: L
                }
            }, e.sign.keyPair.fromSecretKey = function(B) {
                if (Ve(B), B.length !== Lt) throw new Error("bad secret key size");
                for (var L = new Uint8Array(et), F = 0; F < L.length; F++) L[F] = B[32 + F];
                return {
                    publicKey: L,
                    secretKey: new Uint8Array(B)
                }
            }, e.sign.keyPair.fromSeed = function(B) {
                if (Ve(B), B.length !== Yt) throw new Error("bad seed size");
                for (var L = new Uint8Array(et), F = new Uint8Array(Lt), g = 0; g < 32; g++) F[g] = B[g];
                return ft(L, F, !0), {
                    publicKey: L,
                    secretKey: F
                }
            }, e.sign.publicKeyLength = et, e.sign.secretKeyLength = Lt, e.sign.seedLength = Yt, e.sign.signatureLength = Nt, e.hash = function(B) {
                Ve(B);
                var L = new Uint8Array(ct);
                return At(L, B, B.length), L
            }, e.hash.hashLength = ct, e.verify = function(B, L) {
                return Ve(B, L), B.length === 0 || L.length === 0 || B.length !== L.length ? !1 : j(B, 0, L, 0, B.length) === 0
            }, e.setPRNG = function(B) {
                n = B
            },
            function() {
                var B = typeof self != "undefined" ? self.crypto || self.msCrypto : null;
                if (B && B.getRandomValues) {
                    var L = 65536;
                    e.setPRNG(function(F, g) {
                        var U, Z = new Uint8Array(g);
                        for (U = 0; U < g; U += L) B.getRandomValues(Z.subarray(U, U + Math.min(g - U, L)));
                        for (U = 0; U < g; U++) F[U] = Z[U];
                        Xt(Z)
                    })
                } else typeof N6 != "undefined" && (B = Zb, B && B.randomBytes && e.setPRNG(function(F, g) {
                    var U, Z = B.randomBytes(g);
                    for (U = 0; U < g; U++) F[U] = Z[U];
                    Xt(Z)
                }))
            }()
    })(t.exports ? t.exports : self.nacl = self.nacl || {})
})(e2);
var Ud = e2.exports,
    Et = {},
    Al = {};
Al.byteLength = eA;
Al.toByteArray = rA;
Al.fromByteArray = sA;
var Pi = [],
    Gn = [],
    Jb = typeof Uint8Array != "undefined" ? Uint8Array : Array,
    u0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var qo = 0, Xb = u0.length; qo < Xb; ++qo) Pi[qo] = u0[qo], Gn[u0.charCodeAt(qo)] = qo;
Gn["-".charCodeAt(0)] = 62;
Gn["_".charCodeAt(0)] = 63;

function t2(t) {
    var e = t.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = t.indexOf("=");
    r === -1 && (r = e);
    var n = r === e ? 0 : 4 - r % 4;
    return [r, n]
}

function eA(t) {
    var e = t2(t),
        r = e[0],
        n = e[1];
    return (r + n) * 3 / 4 - n
}

function tA(t, e, r) {
    return (e + r) * 3 / 4 - r
}

function rA(t) {
    var e, r = t2(t),
        n = r[0],
        i = r[1],
        s = new Jb(tA(t, n, i)),
        o = 0,
        a = i > 0 ? n - 4 : n,
        c;
    for (c = 0; c < a; c += 4) e = Gn[t.charCodeAt(c)] << 18 | Gn[t.charCodeAt(c + 1)] << 12 | Gn[t.charCodeAt(c + 2)] << 6 | Gn[t.charCodeAt(c + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
    return i === 2 && (e = Gn[t.charCodeAt(c)] << 2 | Gn[t.charCodeAt(c + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = Gn[t.charCodeAt(c)] << 10 | Gn[t.charCodeAt(c + 1)] << 4 | Gn[t.charCodeAt(c + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s
}

function nA(t) {
    return Pi[t >> 18 & 63] + Pi[t >> 12 & 63] + Pi[t >> 6 & 63] + Pi[t & 63]
}

function iA(t, e, r) {
    for (var n, i = [], s = e; s < r; s += 3) n = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (t[s + 2] & 255), i.push(nA(n));
    return i.join("")
}

function sA(t) {
    for (var e, r = t.length, n = r % 3, i = [], s = 16383, o = 0, a = r - n; o < a; o += s) i.push(iA(t, o, o + s > a ? a : o + s));
    return n === 1 ? (e = t[r - 1], i.push(Pi[e >> 2] + Pi[e << 4 & 63] + "==")) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i.push(Pi[e >> 10] + Pi[e >> 4 & 63] + Pi[e << 2 & 63] + "=")), i.join("")
}
var Gc = {}; /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Gc.read = function(t, e, r, n, i) {
    var s, o, a = i * 8 - n - 1,
        c = (1 << a) - 1,
        d = c >> 1,
        y = -7,
        I = r ? i - 1 : 0,
        N = r ? -1 : 1,
        E = t[e + I];
    for (I += N, s = E & (1 << -y) - 1, E >>= -y, y += a; y > 0; s = s * 256 + t[e + I], I += N, y -= 8);
    for (o = s & (1 << -y) - 1, s >>= -y, y += n; y > 0; o = o * 256 + t[e + I], I += N, y -= 8);
    if (s === 0) s = 1 - d;
    else {
        if (s === c) return o ? NaN : (E ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, n), s = s - d
    }
    return (E ? -1 : 1) * o * Math.pow(2, s - n)
};
Gc.write = function(t, e, r, n, i, s) {
    var o, a, c, d = s * 8 - i - 1,
        y = (1 << d) - 1,
        I = y >> 1,
        N = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        E = n ? 0 : s - 1,
        T = n ? 1 : -1,
        j = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = y) : (o = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), o + I >= 1 ? e += N / c : e += N * Math.pow(2, 1 - I), e * c >= 2 && (o++, c /= 2), o + I >= y ? (a = 0, o = y) : o + I >= 1 ? (a = (e * c - 1) * Math.pow(2, i), o = o + I) : (a = e * Math.pow(2, I - 1) * Math.pow(2, i), o = 0)); i >= 8; t[r + E] = a & 255, E += T, a /= 256, i -= 8);
    for (o = o << i | a, d += i; d > 0; t[r + E] = o & 255, E += T, o /= 256, d -= 8);
    t[r + E - T] |= j * 128
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
    const e = Al,
        r = Gc,
        n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = a, t.SlowBuffer = O, t.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = s(), !a.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

    function s() {
        try {
            const v = new Uint8Array(1),
                u = {
                    foo: function() {
                        return 42
                    }
                };
            return Object.setPrototypeOf(u, Uint8Array.prototype), Object.setPrototypeOf(v, u), v.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (!!a.isBuffer(this)) return this.buffer
        }
    }), Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (!!a.isBuffer(this)) return this.byteOffset
        }
    });

    function o(v) {
        if (v > i) throw new RangeError('The value "' + v + '" is invalid for option "size"');
        const u = new Uint8Array(v);
        return Object.setPrototypeOf(u, a.prototype), u
    }

    function a(v, u, l) {
        if (typeof v == "number") {
            if (typeof u == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return I(v)
        }
        return c(v, u, l)
    }
    a.poolSize = 8192;

    function c(v, u, l) {
        if (typeof v == "string") return N(v, u);
        if (ArrayBuffer.isView(v)) return T(v);
        if (v == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof v);
        if (Xe(v, ArrayBuffer) || v && Xe(v.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (Xe(v, SharedArrayBuffer) || v && Xe(v.buffer, SharedArrayBuffer))) return j(v, u, l);
        if (typeof v == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const S = v.valueOf && v.valueOf();
        if (S != null && S !== v) return a.from(S, u, l);
        const D = V(v);
        if (D) return D;
        if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof v[Symbol.toPrimitive] == "function") return a.from(v[Symbol.toPrimitive]("string"), u, l);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof v)
    }
    a.from = function(v, u, l) {
        return c(v, u, l)
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);

    function d(v) {
        if (typeof v != "number") throw new TypeError('"size" argument must be of type number');
        if (v < 0) throw new RangeError('The value "' + v + '" is invalid for option "size"')
    }

    function y(v, u, l) {
        return d(v), v <= 0 ? o(v) : u !== void 0 ? typeof l == "string" ? o(v).fill(u, l) : o(v).fill(u) : o(v)
    }
    a.alloc = function(v, u, l) {
        return y(v, u, l)
    };

    function I(v) {
        return d(v), o(v < 0 ? 0 : P(v) | 0)
    }
    a.allocUnsafe = function(v) {
        return I(v)
    }, a.allocUnsafeSlow = function(v) {
        return I(v)
    };

    function N(v, u) {
        if ((typeof u != "string" || u === "") && (u = "utf8"), !a.isEncoding(u)) throw new TypeError("Unknown encoding: " + u);
        const l = R(v, u) | 0;
        let S = o(l);
        const D = S.write(v, u);
        return D !== l && (S = S.slice(0, D)), S
    }

    function E(v) {
        const u = v.length < 0 ? 0 : P(v.length) | 0,
            l = o(u);
        for (let S = 0; S < u; S += 1) l[S] = v[S] & 255;
        return l
    }

    function T(v) {
        if (Xe(v, Uint8Array)) {
            const u = new Uint8Array(v);
            return j(u.buffer, u.byteOffset, u.byteLength)
        }
        return E(v)
    }

    function j(v, u, l) {
        if (u < 0 || v.byteLength < u) throw new RangeError('"offset" is outside of buffer bounds');
        if (v.byteLength < u + (l || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let S;
        return u === void 0 && l === void 0 ? S = new Uint8Array(v) : l === void 0 ? S = new Uint8Array(v, u) : S = new Uint8Array(v, u, l), Object.setPrototypeOf(S, a.prototype), S
    }

    function V(v) {
        if (a.isBuffer(v)) {
            const u = P(v.length) | 0,
                l = o(u);
            return l.length === 0 || v.copy(l, 0, 0, u), l
        }
        if (v.length !== void 0) return typeof v.length != "number" || St(v.length) ? o(0) : E(v);
        if (v.type === "Buffer" && Array.isArray(v.data)) return E(v.data)
    }

    function P(v) {
        if (v >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return v | 0
    }

    function O(v) {
        return +v != v && (v = 0), a.alloc(+v)
    }
    a.isBuffer = function(u) {
        return u != null && u._isBuffer === !0 && u !== a.prototype
    }, a.compare = function(u, l) {
        if (Xe(u, Uint8Array) && (u = a.from(u, u.offset, u.byteLength)), Xe(l, Uint8Array) && (l = a.from(l, l.offset, l.byteLength)), !a.isBuffer(u) || !a.isBuffer(l)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (u === l) return 0;
        let S = u.length,
            D = l.length;
        for (let $ = 0, Q = Math.min(S, D); $ < Q; ++$)
            if (u[$] !== l[$]) {
                S = u[$], D = l[$];
                break
            }
        return S < D ? -1 : D < S ? 1 : 0
    }, a.isEncoding = function(u) {
        switch (String(u).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
        }
    }, a.concat = function(u, l) {
        if (!Array.isArray(u)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (u.length === 0) return a.alloc(0);
        let S;
        if (l === void 0)
            for (l = 0, S = 0; S < u.length; ++S) l += u[S].length;
        const D = a.allocUnsafe(l);
        let $ = 0;
        for (S = 0; S < u.length; ++S) {
            let Q = u[S];
            if (Xe(Q, Uint8Array)) $ + Q.length > D.length ? (a.isBuffer(Q) || (Q = a.from(Q)), Q.copy(D, $)) : Uint8Array.prototype.set.call(D, Q, $);
            else if (a.isBuffer(Q)) Q.copy(D, $);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            $ += Q.length
        }
        return D
    };

    function R(v, u) {
        if (a.isBuffer(v)) return v.length;
        if (ArrayBuffer.isView(v) || Xe(v, ArrayBuffer)) return v.byteLength;
        if (typeof v != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof v);
        const l = v.length,
            S = arguments.length > 2 && arguments[2] === !0;
        if (!S && l === 0) return 0;
        let D = !1;
        for (;;) switch (u) {
            case "ascii":
            case "latin1":
            case "binary":
                return l;
            case "utf8":
            case "utf-8":
                return It(v).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return l * 2;
            case "hex":
                return l >>> 1;
            case "base64":
                return Ct(v).length;
            default:
                if (D) return S ? -1 : It(v).length;
                u = ("" + u).toLowerCase(), D = !0
        }
    }
    a.byteLength = R;

    function q(v, u, l) {
        let S = !1;
        if ((u === void 0 || u < 0) && (u = 0), u > this.length || ((l === void 0 || l > this.length) && (l = this.length), l <= 0) || (l >>>= 0, u >>>= 0, l <= u)) return "";
        for (v || (v = "utf8");;) switch (v) {
            case "hex":
                return M(this, u, l);
            case "utf8":
            case "utf-8":
                return f(this, u, l);
            case "ascii":
                return C(this, u, l);
            case "latin1":
            case "binary":
                return _(this, u, l);
            case "base64":
                return p(this, u, l);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return m(this, u, l);
            default:
                if (S) throw new TypeError("Unknown encoding: " + v);
                v = (v + "").toLowerCase(), S = !0
        }
    }
    a.prototype._isBuffer = !0;

    function W(v, u, l) {
        const S = v[u];
        v[u] = v[l], v[l] = S
    }
    a.prototype.swap16 = function() {
        const u = this.length;
        if (u % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let l = 0; l < u; l += 2) W(this, l, l + 1);
        return this
    }, a.prototype.swap32 = function() {
        const u = this.length;
        if (u % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let l = 0; l < u; l += 4) W(this, l, l + 3), W(this, l + 1, l + 2);
        return this
    }, a.prototype.swap64 = function() {
        const u = this.length;
        if (u % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let l = 0; l < u; l += 8) W(this, l, l + 7), W(this, l + 1, l + 6), W(this, l + 2, l + 5), W(this, l + 3, l + 4);
        return this
    }, a.prototype.toString = function() {
        const u = this.length;
        return u === 0 ? "" : arguments.length === 0 ? f(this, 0, u) : q.apply(this, arguments)
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(u) {
        if (!a.isBuffer(u)) throw new TypeError("Argument must be a Buffer");
        return this === u ? !0 : a.compare(this, u) === 0
    }, a.prototype.inspect = function() {
        let u = "";
        const l = t.INSPECT_MAX_BYTES;
        return u = this.toString("hex", 0, l).replace(/(.{2})/g, "$1 ").trim(), this.length > l && (u += " ... "), "<Buffer " + u + ">"
    }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(u, l, S, D, $) {
        if (Xe(u, Uint8Array) && (u = a.from(u, u.offset, u.byteLength)), !a.isBuffer(u)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof u);
        if (l === void 0 && (l = 0), S === void 0 && (S = u ? u.length : 0), D === void 0 && (D = 0), $ === void 0 && ($ = this.length), l < 0 || S > u.length || D < 0 || $ > this.length) throw new RangeError("out of range index");
        if (D >= $ && l >= S) return 0;
        if (D >= $) return -1;
        if (l >= S) return 1;
        if (l >>>= 0, S >>>= 0, D >>>= 0, $ >>>= 0, this === u) return 0;
        let Q = $ - D,
            he = S - l;
        const Be = Math.min(Q, he),
            ge = this.slice(D, $),
            Te = u.slice(l, S);
        for (let Se = 0; Se < Be; ++Se)
            if (ge[Se] !== Te[Se]) {
                Q = ge[Se], he = Te[Se];
                break
            }
        return Q < he ? -1 : he < Q ? 1 : 0
    };

    function Y(v, u, l, S, D) {
        if (v.length === 0) return -1;
        if (typeof l == "string" ? (S = l, l = 0) : l > 2147483647 ? l = 2147483647 : l < -2147483648 && (l = -2147483648), l = +l, St(l) && (l = D ? 0 : v.length - 1), l < 0 && (l = v.length + l), l >= v.length) {
            if (D) return -1;
            l = v.length - 1
        } else if (l < 0)
            if (D) l = 0;
            else return -1;
        if (typeof u == "string" && (u = a.from(u, S)), a.isBuffer(u)) return u.length === 0 ? -1 : G(v, u, l, S, D);
        if (typeof u == "number") return u = u & 255, typeof Uint8Array.prototype.indexOf == "function" ? D ? Uint8Array.prototype.indexOf.call(v, u, l) : Uint8Array.prototype.lastIndexOf.call(v, u, l) : G(v, [u], l, S, D);
        throw new TypeError("val must be string, number or Buffer")
    }

    function G(v, u, l, S, D) {
        let $ = 1,
            Q = v.length,
            he = u.length;
        if (S !== void 0 && (S = String(S).toLowerCase(), S === "ucs2" || S === "ucs-2" || S === "utf16le" || S === "utf-16le")) {
            if (v.length < 2 || u.length < 2) return -1;
            $ = 2, Q /= 2, he /= 2, l /= 2
        }

        function Be(Te, Se) {
            return $ === 1 ? Te[Se] : Te.readUInt16BE(Se * $)
        }
        let ge;
        if (D) {
            let Te = -1;
            for (ge = l; ge < Q; ge++)
                if (Be(v, ge) === Be(u, Te === -1 ? 0 : ge - Te)) {
                    if (Te === -1 && (Te = ge), ge - Te + 1 === he) return Te * $
                } else Te !== -1 && (ge -= ge - Te), Te = -1
        } else
            for (l + he > Q && (l = Q - he), ge = l; ge >= 0; ge--) {
                let Te = !0;
                for (let Se = 0; Se < he; Se++)
                    if (Be(v, ge + Se) !== Be(u, Se)) {
                        Te = !1;
                        break
                    }
                if (Te) return ge
            }
        return -1
    }
    a.prototype.includes = function(u, l, S) {
        return this.indexOf(u, l, S) !== -1
    }, a.prototype.indexOf = function(u, l, S) {
        return Y(this, u, l, S, !0)
    }, a.prototype.lastIndexOf = function(u, l, S) {
        return Y(this, u, l, S, !1)
    };

    function J(v, u, l, S) {
        l = Number(l) || 0;
        const D = v.length - l;
        S ? (S = Number(S), S > D && (S = D)) : S = D;
        const $ = u.length;
        S > $ / 2 && (S = $ / 2);
        let Q;
        for (Q = 0; Q < S; ++Q) {
            const he = parseInt(u.substr(Q * 2, 2), 16);
            if (St(he)) return Q;
            v[l + Q] = he
        }
        return Q
    }

    function pe(v, u, l, S) {
        return Ye(It(u, v.length - l), v, l, S)
    }

    function we(v, u, l, S) {
        return Ye(it(u), v, l, S)
    }

    function H(v, u, l, S) {
        return Ye(Ct(u), v, l, S)
    }

    function w(v, u, l, S) {
        return Ye(At(u, v.length - l), v, l, S)
    }
    a.prototype.write = function(u, l, S, D) {
        if (l === void 0) D = "utf8", S = this.length, l = 0;
        else if (S === void 0 && typeof l == "string") D = l, S = this.length, l = 0;
        else if (isFinite(l)) l = l >>> 0, isFinite(S) ? (S = S >>> 0, D === void 0 && (D = "utf8")) : (D = S, S = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const $ = this.length - l;
        if ((S === void 0 || S > $) && (S = $), u.length > 0 && (S < 0 || l < 0) || l > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        D || (D = "utf8");
        let Q = !1;
        for (;;) switch (D) {
            case "hex":
                return J(this, u, l, S);
            case "utf8":
            case "utf-8":
                return pe(this, u, l, S);
            case "ascii":
            case "latin1":
            case "binary":
                return we(this, u, l, S);
            case "base64":
                return H(this, u, l, S);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return w(this, u, l, S);
            default:
                if (Q) throw new TypeError("Unknown encoding: " + D);
                D = ("" + D).toLowerCase(), Q = !0
        }
    }, a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    };

    function p(v, u, l) {
        return u === 0 && l === v.length ? e.fromByteArray(v) : e.fromByteArray(v.slice(u, l))
    }

    function f(v, u, l) {
        l = Math.min(v.length, l);
        const S = [];
        let D = u;
        for (; D < l;) {
            const $ = v[D];
            let Q = null,
                he = $ > 239 ? 4 : $ > 223 ? 3 : $ > 191 ? 2 : 1;
            if (D + he <= l) {
                let Be, ge, Te, Se;
                switch (he) {
                    case 1:
                        $ < 128 && (Q = $);
                        break;
                    case 2:
                        Be = v[D + 1], (Be & 192) === 128 && (Se = ($ & 31) << 6 | Be & 63, Se > 127 && (Q = Se));
                        break;
                    case 3:
                        Be = v[D + 1], ge = v[D + 2], (Be & 192) === 128 && (ge & 192) === 128 && (Se = ($ & 15) << 12 | (Be & 63) << 6 | ge & 63, Se > 2047 && (Se < 55296 || Se > 57343) && (Q = Se));
                        break;
                    case 4:
                        Be = v[D + 1], ge = v[D + 2], Te = v[D + 3], (Be & 192) === 128 && (ge & 192) === 128 && (Te & 192) === 128 && (Se = ($ & 15) << 18 | (Be & 63) << 12 | (ge & 63) << 6 | Te & 63, Se > 65535 && Se < 1114112 && (Q = Se))
                }
            }
            Q === null ? (Q = 65533, he = 1) : Q > 65535 && (Q -= 65536, S.push(Q >>> 10 & 1023 | 55296), Q = 56320 | Q & 1023), S.push(Q), D += he
        }
        return b(S)
    }
    const h = 4096;

    function b(v) {
        const u = v.length;
        if (u <= h) return String.fromCharCode.apply(String, v);
        let l = "",
            S = 0;
        for (; S < u;) l += String.fromCharCode.apply(String, v.slice(S, S += h));
        return l
    }

    function C(v, u, l) {
        let S = "";
        l = Math.min(v.length, l);
        for (let D = u; D < l; ++D) S += String.fromCharCode(v[D] & 127);
        return S
    }

    function _(v, u, l) {
        let S = "";
        l = Math.min(v.length, l);
        for (let D = u; D < l; ++D) S += String.fromCharCode(v[D]);
        return S
    }

    function M(v, u, l) {
        const S = v.length;
        (!u || u < 0) && (u = 0), (!l || l < 0 || l > S) && (l = S);
        let D = "";
        for (let $ = u; $ < l; ++$) D += Ze[v[$]];
        return D
    }

    function m(v, u, l) {
        const S = v.slice(u, l);
        let D = "";
        for (let $ = 0; $ < S.length - 1; $ += 2) D += String.fromCharCode(S[$] + S[$ + 1] * 256);
        return D
    }
    a.prototype.slice = function(u, l) {
        const S = this.length;
        u = ~~u, l = l === void 0 ? S : ~~l, u < 0 ? (u += S, u < 0 && (u = 0)) : u > S && (u = S), l < 0 ? (l += S, l < 0 && (l = 0)) : l > S && (l = S), l < u && (l = u);
        const D = this.subarray(u, l);
        return Object.setPrototypeOf(D, a.prototype), D
    };

    function A(v, u, l) {
        if (v % 1 !== 0 || v < 0) throw new RangeError("offset is not uint");
        if (v + u > l) throw new RangeError("Trying to access beyond buffer length")
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(u, l, S) {
        u = u >>> 0, l = l >>> 0, S || A(u, l, this.length);
        let D = this[u],
            $ = 1,
            Q = 0;
        for (; ++Q < l && ($ *= 256);) D += this[u + Q] * $;
        return D
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(u, l, S) {
        u = u >>> 0, l = l >>> 0, S || A(u, l, this.length);
        let D = this[u + --l],
            $ = 1;
        for (; l > 0 && ($ *= 256);) D += this[u + --l] * $;
        return D
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(u, l) {
        return u = u >>> 0, l || A(u, 1, this.length), this[u]
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(u, l) {
        return u = u >>> 0, l || A(u, 2, this.length), this[u] | this[u + 1] << 8
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(u, l) {
        return u = u >>> 0, l || A(u, 2, this.length), this[u] << 8 | this[u + 1]
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), (this[u] | this[u + 1] << 8 | this[u + 2] << 16) + this[u + 3] * 16777216
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), this[u] * 16777216 + (this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3])
    }, a.prototype.readBigUInt64LE = ft(function(u) {
        u = u >>> 0, We(u, "offset");
        const l = this[u],
            S = this[u + 7];
        (l === void 0 || S === void 0) && Ie(u, this.length - 8);
        const D = l + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24,
            $ = this[++u] + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + S * 2 ** 24;
        return BigInt(D) + (BigInt($) << BigInt(32))
    }), a.prototype.readBigUInt64BE = ft(function(u) {
        u = u >>> 0, We(u, "offset");
        const l = this[u],
            S = this[u + 7];
        (l === void 0 || S === void 0) && Ie(u, this.length - 8);
        const D = l * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u],
            $ = this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + S;
        return (BigInt(D) << BigInt(32)) + BigInt($)
    }), a.prototype.readIntLE = function(u, l, S) {
        u = u >>> 0, l = l >>> 0, S || A(u, l, this.length);
        let D = this[u],
            $ = 1,
            Q = 0;
        for (; ++Q < l && ($ *= 256);) D += this[u + Q] * $;
        return $ *= 128, D >= $ && (D -= Math.pow(2, 8 * l)), D
    }, a.prototype.readIntBE = function(u, l, S) {
        u = u >>> 0, l = l >>> 0, S || A(u, l, this.length);
        let D = l,
            $ = 1,
            Q = this[u + --D];
        for (; D > 0 && ($ *= 256);) Q += this[u + --D] * $;
        return $ *= 128, Q >= $ && (Q -= Math.pow(2, 8 * l)), Q
    }, a.prototype.readInt8 = function(u, l) {
        return u = u >>> 0, l || A(u, 1, this.length), this[u] & 128 ? (255 - this[u] + 1) * -1 : this[u]
    }, a.prototype.readInt16LE = function(u, l) {
        u = u >>> 0, l || A(u, 2, this.length);
        const S = this[u] | this[u + 1] << 8;
        return S & 32768 ? S | 4294901760 : S
    }, a.prototype.readInt16BE = function(u, l) {
        u = u >>> 0, l || A(u, 2, this.length);
        const S = this[u + 1] | this[u] << 8;
        return S & 32768 ? S | 4294901760 : S
    }, a.prototype.readInt32LE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), this[u] | this[u + 1] << 8 | this[u + 2] << 16 | this[u + 3] << 24
    }, a.prototype.readInt32BE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), this[u] << 24 | this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3]
    }, a.prototype.readBigInt64LE = ft(function(u) {
        u = u >>> 0, We(u, "offset");
        const l = this[u],
            S = this[u + 7];
        (l === void 0 || S === void 0) && Ie(u, this.length - 8);
        const D = this[u + 4] + this[u + 5] * 2 ** 8 + this[u + 6] * 2 ** 16 + (S << 24);
        return (BigInt(D) << BigInt(32)) + BigInt(l + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24)
    }), a.prototype.readBigInt64BE = ft(function(u) {
        u = u >>> 0, We(u, "offset");
        const l = this[u],
            S = this[u + 7];
        (l === void 0 || S === void 0) && Ie(u, this.length - 8);
        const D = (l << 24) + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u];
        return (BigInt(D) << BigInt(32)) + BigInt(this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + S)
    }), a.prototype.readFloatLE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), r.read(this, u, !0, 23, 4)
    }, a.prototype.readFloatBE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), r.read(this, u, !1, 23, 4)
    }, a.prototype.readDoubleLE = function(u, l) {
        return u = u >>> 0, l || A(u, 8, this.length), r.read(this, u, !0, 52, 8)
    }, a.prototype.readDoubleBE = function(u, l) {
        return u = u >>> 0, l || A(u, 8, this.length), r.read(this, u, !1, 52, 8)
    };

    function x(v, u, l, S, D, $) {
        if (!a.isBuffer(v)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (u > D || u < $) throw new RangeError('"value" argument is out of bounds');
        if (l + S > v.length) throw new RangeError("Index out of range")
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(u, l, S, D) {
        if (u = +u, l = l >>> 0, S = S >>> 0, !D) {
            const he = Math.pow(2, 8 * S) - 1;
            x(this, u, l, S, he, 0)
        }
        let $ = 1,
            Q = 0;
        for (this[l] = u & 255; ++Q < S && ($ *= 256);) this[l + Q] = u / $ & 255;
        return l + S
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(u, l, S, D) {
        if (u = +u, l = l >>> 0, S = S >>> 0, !D) {
            const he = Math.pow(2, 8 * S) - 1;
            x(this, u, l, S, he, 0)
        }
        let $ = S - 1,
            Q = 1;
        for (this[l + $] = u & 255; --$ >= 0 && (Q *= 256);) this[l + $] = u / Q & 255;
        return l + S
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 1, 255, 0), this[l] = u & 255, l + 1
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 2, 65535, 0), this[l] = u & 255, this[l + 1] = u >>> 8, l + 2
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 2, 65535, 0), this[l] = u >>> 8, this[l + 1] = u & 255, l + 2
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 4, 4294967295, 0), this[l + 3] = u >>> 24, this[l + 2] = u >>> 16, this[l + 1] = u >>> 8, this[l] = u & 255, l + 4
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 4, 4294967295, 0), this[l] = u >>> 24, this[l + 1] = u >>> 16, this[l + 2] = u >>> 8, this[l + 3] = u & 255, l + 4
    };

    function z(v, u, l, S, D) {
        ve(u, S, D, v, l, 7);
        let $ = Number(u & BigInt(4294967295));
        v[l++] = $, $ = $ >> 8, v[l++] = $, $ = $ >> 8, v[l++] = $, $ = $ >> 8, v[l++] = $;
        let Q = Number(u >> BigInt(32) & BigInt(4294967295));
        return v[l++] = Q, Q = Q >> 8, v[l++] = Q, Q = Q >> 8, v[l++] = Q, Q = Q >> 8, v[l++] = Q, l
    }

    function oe(v, u, l, S, D) {
        ve(u, S, D, v, l, 7);
        let $ = Number(u & BigInt(4294967295));
        v[l + 7] = $, $ = $ >> 8, v[l + 6] = $, $ = $ >> 8, v[l + 5] = $, $ = $ >> 8, v[l + 4] = $;
        let Q = Number(u >> BigInt(32) & BigInt(4294967295));
        return v[l + 3] = Q, Q = Q >> 8, v[l + 2] = Q, Q = Q >> 8, v[l + 1] = Q, Q = Q >> 8, v[l] = Q, l + 8
    }
    a.prototype.writeBigUInt64LE = ft(function(u, l = 0) {
        return z(this, u, l, BigInt(0), BigInt("0xffffffffffffffff"))
    }), a.prototype.writeBigUInt64BE = ft(function(u, l = 0) {
        return oe(this, u, l, BigInt(0), BigInt("0xffffffffffffffff"))
    }), a.prototype.writeIntLE = function(u, l, S, D) {
        if (u = +u, l = l >>> 0, !D) {
            const Be = Math.pow(2, 8 * S - 1);
            x(this, u, l, S, Be - 1, -Be)
        }
        let $ = 0,
            Q = 1,
            he = 0;
        for (this[l] = u & 255; ++$ < S && (Q *= 256);) u < 0 && he === 0 && this[l + $ - 1] !== 0 && (he = 1), this[l + $] = (u / Q >> 0) - he & 255;
        return l + S
    }, a.prototype.writeIntBE = function(u, l, S, D) {
        if (u = +u, l = l >>> 0, !D) {
            const Be = Math.pow(2, 8 * S - 1);
            x(this, u, l, S, Be - 1, -Be)
        }
        let $ = S - 1,
            Q = 1,
            he = 0;
        for (this[l + $] = u & 255; --$ >= 0 && (Q *= 256);) u < 0 && he === 0 && this[l + $ + 1] !== 0 && (he = 1), this[l + $] = (u / Q >> 0) - he & 255;
        return l + S
    }, a.prototype.writeInt8 = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 1, 127, -128), u < 0 && (u = 255 + u + 1), this[l] = u & 255, l + 1
    }, a.prototype.writeInt16LE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 2, 32767, -32768), this[l] = u & 255, this[l + 1] = u >>> 8, l + 2
    }, a.prototype.writeInt16BE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 2, 32767, -32768), this[l] = u >>> 8, this[l + 1] = u & 255, l + 2
    }, a.prototype.writeInt32LE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 4, 2147483647, -2147483648), this[l] = u & 255, this[l + 1] = u >>> 8, this[l + 2] = u >>> 16, this[l + 3] = u >>> 24, l + 4
    }, a.prototype.writeInt32BE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 4, 2147483647, -2147483648), u < 0 && (u = 4294967295 + u + 1), this[l] = u >>> 24, this[l + 1] = u >>> 16, this[l + 2] = u >>> 8, this[l + 3] = u & 255, l + 4
    }, a.prototype.writeBigInt64LE = ft(function(u, l = 0) {
        return z(this, u, l, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }), a.prototype.writeBigInt64BE = ft(function(u, l = 0) {
        return oe(this, u, l, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });

    function k(v, u, l, S, D, $) {
        if (l + S > v.length) throw new RangeError("Index out of range");
        if (l < 0) throw new RangeError("Index out of range")
    }

    function X(v, u, l, S, D) {
        return u = +u, l = l >>> 0, D || k(v, u, l, 4), r.write(v, u, l, S, 23, 4), l + 4
    }
    a.prototype.writeFloatLE = function(u, l, S) {
        return X(this, u, l, !0, S)
    }, a.prototype.writeFloatBE = function(u, l, S) {
        return X(this, u, l, !1, S)
    };

    function re(v, u, l, S, D) {
        return u = +u, l = l >>> 0, D || k(v, u, l, 8), r.write(v, u, l, S, 52, 8), l + 8
    }
    a.prototype.writeDoubleLE = function(u, l, S) {
        return re(this, u, l, !0, S)
    }, a.prototype.writeDoubleBE = function(u, l, S) {
        return re(this, u, l, !1, S)
    }, a.prototype.copy = function(u, l, S, D) {
        if (!a.isBuffer(u)) throw new TypeError("argument should be a Buffer");
        if (S || (S = 0), !D && D !== 0 && (D = this.length), l >= u.length && (l = u.length), l || (l = 0), D > 0 && D < S && (D = S), D === S || u.length === 0 || this.length === 0) return 0;
        if (l < 0) throw new RangeError("targetStart out of bounds");
        if (S < 0 || S >= this.length) throw new RangeError("Index out of range");
        if (D < 0) throw new RangeError("sourceEnd out of bounds");
        D > this.length && (D = this.length), u.length - l < D - S && (D = u.length - l + S);
        const $ = D - S;
        return this === u && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(l, S, D) : Uint8Array.prototype.set.call(u, this.subarray(S, D), l), $
    }, a.prototype.fill = function(u, l, S, D) {
        if (typeof u == "string") {
            if (typeof l == "string" ? (D = l, l = 0, S = this.length) : typeof S == "string" && (D = S, S = this.length), D !== void 0 && typeof D != "string") throw new TypeError("encoding must be a string");
            if (typeof D == "string" && !a.isEncoding(D)) throw new TypeError("Unknown encoding: " + D);
            if (u.length === 1) {
                const Q = u.charCodeAt(0);
                (D === "utf8" && Q < 128 || D === "latin1") && (u = Q)
            }
        } else typeof u == "number" ? u = u & 255 : typeof u == "boolean" && (u = Number(u));
        if (l < 0 || this.length < l || this.length < S) throw new RangeError("Out of range index");
        if (S <= l) return this;
        l = l >>> 0, S = S === void 0 ? this.length : S >>> 0, u || (u = 0);
        let $;
        if (typeof u == "number")
            for ($ = l; $ < S; ++$) this[$] = u;
        else {
            const Q = a.isBuffer(u) ? u : a.from(u, D),
                he = Q.length;
            if (he === 0) throw new TypeError('The value "' + u + '" is invalid for argument "value"');
            for ($ = 0; $ < S - l; ++$) this[$ + l] = Q[$ % he]
        }
        return this
    };
    const ae = {};

    function le(v, u, l) {
        ae[v] = class extends l {
            constructor() {
                super(), Object.defineProperty(this, "message", {
                    value: u.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${v}]`, this.stack, delete this.name
            }
            get code() {
                return v
            }
            set code(D) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: D,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${v}]: ${this.message}`
            }
        }
    }
    le("ERR_BUFFER_OUT_OF_BOUNDS", function(v) {
        return v ? `${v} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError), le("ERR_INVALID_ARG_TYPE", function(v, u) {
        return `The "${v}" argument must be of type number. Received type ${typeof u}`
    }, TypeError), le("ERR_OUT_OF_RANGE", function(v, u, l) {
        let S = `The value of "${v}" is out of range.`,
            D = l;
        return Number.isInteger(l) && Math.abs(l) > 2 ** 32 ? D = Me(String(l)) : typeof l == "bigint" && (D = String(l), (l > BigInt(2) ** BigInt(32) || l < -(BigInt(2) ** BigInt(32))) && (D = Me(D)), D += "n"), S += ` It must be ${u}. Received ${D}`, S
    }, RangeError);

    function Me(v) {
        let u = "",
            l = v.length;
        const S = v[0] === "-" ? 1 : 0;
        for (; l >= S + 4; l -= 3) u = `_${v.slice(l-3,l)}${u}`;
        return `${v.slice(0,l)}${u}`
    }

    function Re(v, u, l) {
        We(u, "offset"), (v[u] === void 0 || v[u + l] === void 0) && Ie(u, v.length - (l + 1))
    }

    function ve(v, u, l, S, D, $) {
        if (v > l || v < u) {
            const Q = typeof u == "bigint" ? "n" : "";
            let he;
            throw $ > 3 ? u === 0 || u === BigInt(0) ? he = `>= 0${Q} and < 2${Q} ** ${($+1)*8}${Q}` : he = `>= -(2${Q} ** ${($+1)*8-1}${Q}) and < 2 ** ${($+1)*8-1}${Q}` : he = `>= ${u}${Q} and <= ${l}${Q}`, new ae.ERR_OUT_OF_RANGE("value", he, v)
        }
        Re(S, D, $)
    }

    function We(v, u) {
        if (typeof v != "number") throw new ae.ERR_INVALID_ARG_TYPE(u, "number", v)
    }

    function Ie(v, u, l) {
        throw Math.floor(v) !== v ? (We(v, l), new ae.ERR_OUT_OF_RANGE(l || "offset", "an integer", v)) : u < 0 ? new ae.ERR_BUFFER_OUT_OF_BOUNDS : new ae.ERR_OUT_OF_RANGE(l || "offset", `>= ${l?1:0} and <= ${u}`, v)
    }
    const Ue = /[^+/0-9A-Za-z-_]/g;

    function Ut(v) {
        if (v = v.split("=")[0], v = v.trim().replace(Ue, ""), v.length < 2) return "";
        for (; v.length % 4 !== 0;) v = v + "=";
        return v
    }

    function It(v, u) {
        u = u || 1 / 0;
        let l;
        const S = v.length;
        let D = null;
        const $ = [];
        for (let Q = 0; Q < S; ++Q) {
            if (l = v.charCodeAt(Q), l > 55295 && l < 57344) {
                if (!D) {
                    if (l > 56319) {
                        (u -= 3) > -1 && $.push(239, 191, 189);
                        continue
                    } else if (Q + 1 === S) {
                        (u -= 3) > -1 && $.push(239, 191, 189);
                        continue
                    }
                    D = l;
                    continue
                }
                if (l < 56320) {
                    (u -= 3) > -1 && $.push(239, 191, 189), D = l;
                    continue
                }
                l = (D - 55296 << 10 | l - 56320) + 65536
            } else D && (u -= 3) > -1 && $.push(239, 191, 189);
            if (D = null, l < 128) {
                if ((u -= 1) < 0) break;
                $.push(l)
            } else if (l < 2048) {
                if ((u -= 2) < 0) break;
                $.push(l >> 6 | 192, l & 63 | 128)
            } else if (l < 65536) {
                if ((u -= 3) < 0) break;
                $.push(l >> 12 | 224, l >> 6 & 63 | 128, l & 63 | 128)
            } else if (l < 1114112) {
                if ((u -= 4) < 0) break;
                $.push(l >> 18 | 240, l >> 12 & 63 | 128, l >> 6 & 63 | 128, l & 63 | 128)
            } else throw new Error("Invalid code point")
        }
        return $
    }

    function it(v) {
        const u = [];
        for (let l = 0; l < v.length; ++l) u.push(v.charCodeAt(l) & 255);
        return u
    }

    function At(v, u) {
        let l, S, D;
        const $ = [];
        for (let Q = 0; Q < v.length && !((u -= 2) < 0); ++Q) l = v.charCodeAt(Q), S = l >> 8, D = l % 256, $.push(D), $.push(S);
        return $
    }

    function Ct(v) {
        return e.toByteArray(Ut(v))
    }

    function Ye(v, u, l, S) {
        let D;
        for (D = 0; D < S && !(D + l >= u.length || D >= v.length); ++D) u[D + l] = v[D];
        return D
    }

    function Xe(v, u) {
        return v instanceof u || v != null && v.constructor != null && v.constructor.name != null && v.constructor.name === u.name
    }

    function St(v) {
        return v !== v
    }
    const Ze = function() {
        const v = "0123456789abcdef",
            u = new Array(256);
        for (let l = 0; l < 16; ++l) {
            const S = l * 16;
            for (let D = 0; D < 16; ++D) u[S + D] = v[l] + v[D]
        }
        return u
    }();

    function ft(v) {
        return typeof BigInt == "undefined" ? Ot : v
    }

    function Ot() {
        throw new Error("BigInt not supported")
    }
})(Et);
var l1 = {
    exports: {}
};
(function(t) {
    (function(e, r) {
        function n(p, f) {
            if (!p) throw new Error(f || "Assertion failed")
        }

        function i(p, f) {
            p.super_ = f;
            var h = function() {};
            h.prototype = f.prototype, p.prototype = new h, p.prototype.constructor = p
        }

        function s(p, f, h) {
            if (s.isBN(p)) return p;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, p !== null && ((f === "le" || f === "be") && (h = f, f = 10), this._init(p || 0, f || 10, h || "be"))
        }
        typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
        var o;
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? o = window.Buffer : o = require("buffer").Buffer
        } catch {}
        s.isBN = function(f) {
            return f instanceof s ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === s.wordSize && Array.isArray(f.words)
        }, s.max = function(f, h) {
            return f.cmp(h) > 0 ? f : h
        }, s.min = function(f, h) {
            return f.cmp(h) < 0 ? f : h
        }, s.prototype._init = function(f, h, b) {
            if (typeof f == "number") return this._initNumber(f, h, b);
            if (typeof f == "object") return this._initArray(f, h, b);
            h === "hex" && (h = 16), n(h === (h | 0) && h >= 2 && h <= 36), f = f.toString().replace(/\s+/g, "");
            var C = 0;
            f[0] === "-" && (C++, this.negative = 1), C < f.length && (h === 16 ? this._parseHex(f, C, b) : (this._parseBase(f, h, C), b === "le" && this._initArray(this.toArray(), h, b)))
        }, s.prototype._initNumber = function(f, h, b) {
            f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [f & 67108863, f / 67108864 & 67108863], this.length = 2) : (n(f < 9007199254740992), this.words = [f & 67108863, f / 67108864 & 67108863, 1], this.length = 3), b === "le" && this._initArray(this.toArray(), h, b)
        }, s.prototype._initArray = function(f, h, b) {
            if (n(typeof f.length == "number"), f.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
            for (var C = 0; C < this.length; C++) this.words[C] = 0;
            var _, M, m = 0;
            if (b === "be")
                for (C = f.length - 1, _ = 0; C >= 0; C -= 3) M = f[C] | f[C - 1] << 8 | f[C - 2] << 16, this.words[_] |= M << m & 67108863, this.words[_ + 1] = M >>> 26 - m & 67108863, m += 24, m >= 26 && (m -= 26, _++);
            else if (b === "le")
                for (C = 0, _ = 0; C < f.length; C += 3) M = f[C] | f[C + 1] << 8 | f[C + 2] << 16, this.words[_] |= M << m & 67108863, this.words[_ + 1] = M >>> 26 - m & 67108863, m += 24, m >= 26 && (m -= 26, _++);
            return this._strip()
        };

        function a(p, f) {
            var h = p.charCodeAt(f);
            if (h >= 48 && h <= 57) return h - 48;
            if (h >= 65 && h <= 70) return h - 55;
            if (h >= 97 && h <= 102) return h - 87;
            n(!1, "Invalid character in " + p)
        }

        function c(p, f, h) {
            var b = a(p, h);
            return h - 1 >= f && (b |= a(p, h - 1) << 4), b
        }
        s.prototype._parseHex = function(f, h, b) {
            this.length = Math.ceil((f.length - h) / 6), this.words = new Array(this.length);
            for (var C = 0; C < this.length; C++) this.words[C] = 0;
            var _ = 0,
                M = 0,
                m;
            if (b === "be")
                for (C = f.length - 1; C >= h; C -= 2) m = c(f, h, C) << _, this.words[M] |= m & 67108863, _ >= 18 ? (_ -= 18, M += 1, this.words[M] |= m >>> 26) : _ += 8;
            else {
                var A = f.length - h;
                for (C = A % 2 === 0 ? h + 1 : h; C < f.length; C += 2) m = c(f, h, C) << _, this.words[M] |= m & 67108863, _ >= 18 ? (_ -= 18, M += 1, this.words[M] |= m >>> 26) : _ += 8
            }
            this._strip()
        };

        function d(p, f, h, b) {
            for (var C = 0, _ = 0, M = Math.min(p.length, h), m = f; m < M; m++) {
                var A = p.charCodeAt(m) - 48;
                C *= b, A >= 49 ? _ = A - 49 + 10 : A >= 17 ? _ = A - 17 + 10 : _ = A, n(A >= 0 && _ < b, "Invalid character"), C += _
            }
            return C
        }
        s.prototype._parseBase = function(f, h, b) {
            this.words = [0], this.length = 1;
            for (var C = 0, _ = 1; _ <= 67108863; _ *= h) C++;
            C--, _ = _ / h | 0;
            for (var M = f.length - b, m = M % C, A = Math.min(M, M - m) + b, x = 0, z = b; z < A; z += C) x = d(f, z, z + C, h), this.imuln(_), this.words[0] + x < 67108864 ? this.words[0] += x : this._iaddn(x);
            if (m !== 0) {
                var oe = 1;
                for (x = d(f, z, f.length, h), z = 0; z < m; z++) oe *= h;
                this.imuln(oe), this.words[0] + x < 67108864 ? this.words[0] += x : this._iaddn(x)
            }
            this._strip()
        }, s.prototype.copy = function(f) {
            f.words = new Array(this.length);
            for (var h = 0; h < this.length; h++) f.words[h] = this.words[h];
            f.length = this.length, f.negative = this.negative, f.red = this.red
        };

        function y(p, f) {
            p.words = f.words, p.length = f.length, p.negative = f.negative, p.red = f.red
        }
        if (s.prototype._move = function(f) {
                y(f, this)
            }, s.prototype.clone = function() {
                var f = new s(null);
                return this.copy(f), f
            }, s.prototype._expand = function(f) {
                for (; this.length < f;) this.words[this.length++] = 0;
                return this
            }, s.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
                return this._normSign()
            }, s.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }, typeof Symbol != "undefined" && typeof Symbol.for == "function") try {
            s.prototype[Symbol.for("nodejs.util.inspect.custom")] = I
        } catch {
            s.prototype.inspect = I
        } else s.prototype.inspect = I;

        function I() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var N = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            E = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            T = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        s.prototype.toString = function(f, h) {
            f = f || 10, h = h | 0 || 1;
            var b;
            if (f === 16 || f === "hex") {
                b = "";
                for (var C = 0, _ = 0, M = 0; M < this.length; M++) {
                    var m = this.words[M],
                        A = ((m << C | _) & 16777215).toString(16);
                    _ = m >>> 24 - C & 16777215, C += 2, C >= 26 && (C -= 26, M--), _ !== 0 || M !== this.length - 1 ? b = N[6 - A.length] + A + b : b = A + b
                }
                for (_ !== 0 && (b = _.toString(16) + b); b.length % h !== 0;) b = "0" + b;
                return this.negative !== 0 && (b = "-" + b), b
            }
            if (f === (f | 0) && f >= 2 && f <= 36) {
                var x = E[f],
                    z = T[f];
                b = "";
                var oe = this.clone();
                for (oe.negative = 0; !oe.isZero();) {
                    var k = oe.modrn(z).toString(f);
                    oe = oe.idivn(z), oe.isZero() ? b = k + b : b = N[x - k.length] + k + b
                }
                for (this.isZero() && (b = "0" + b); b.length % h !== 0;) b = "0" + b;
                return this.negative !== 0 && (b = "-" + b), b
            }
            n(!1, "Base should be between 2 and 36")
        }, s.prototype.toNumber = function() {
            var f = this.words[0];
            return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f
        }, s.prototype.toJSON = function() {
            return this.toString(16, 2)
        }, o && (s.prototype.toBuffer = function(f, h) {
            return this.toArrayLike(o, f, h)
        }), s.prototype.toArray = function(f, h) {
            return this.toArrayLike(Array, f, h)
        };
        var j = function(f, h) {
            return f.allocUnsafe ? f.allocUnsafe(h) : new f(h)
        };
        s.prototype.toArrayLike = function(f, h, b) {
            this._strip();
            var C = this.byteLength(),
                _ = b || Math.max(1, C);
            n(C <= _, "byte array longer than desired length"), n(_ > 0, "Requested array length <= 0");
            var M = j(f, _),
                m = h === "le" ? "LE" : "BE";
            return this["_toArrayLike" + m](M, C), M
        }, s.prototype._toArrayLikeLE = function(f, h) {
            for (var b = 0, C = 0, _ = 0, M = 0; _ < this.length; _++) {
                var m = this.words[_] << M | C;
                f[b++] = m & 255, b < f.length && (f[b++] = m >> 8 & 255), b < f.length && (f[b++] = m >> 16 & 255), M === 6 ? (b < f.length && (f[b++] = m >> 24 & 255), C = 0, M = 0) : (C = m >>> 24, M += 2)
            }
            if (b < f.length)
                for (f[b++] = C; b < f.length;) f[b++] = 0
        }, s.prototype._toArrayLikeBE = function(f, h) {
            for (var b = f.length - 1, C = 0, _ = 0, M = 0; _ < this.length; _++) {
                var m = this.words[_] << M | C;
                f[b--] = m & 255, b >= 0 && (f[b--] = m >> 8 & 255), b >= 0 && (f[b--] = m >> 16 & 255), M === 6 ? (b >= 0 && (f[b--] = m >> 24 & 255), C = 0, M = 0) : (C = m >>> 24, M += 2)
            }
            if (b >= 0)
                for (f[b--] = C; b >= 0;) f[b--] = 0
        }, Math.clz32 ? s.prototype._countBits = function(f) {
            return 32 - Math.clz32(f)
        } : s.prototype._countBits = function(f) {
            var h = f,
                b = 0;
            return h >= 4096 && (b += 13, h >>>= 13), h >= 64 && (b += 7, h >>>= 7), h >= 8 && (b += 4, h >>>= 4), h >= 2 && (b += 2, h >>>= 2), b + h
        }, s.prototype._zeroBits = function(f) {
            if (f === 0) return 26;
            var h = f,
                b = 0;
            return (h & 8191) === 0 && (b += 13, h >>>= 13), (h & 127) === 0 && (b += 7, h >>>= 7), (h & 15) === 0 && (b += 4, h >>>= 4), (h & 3) === 0 && (b += 2, h >>>= 2), (h & 1) === 0 && b++, b
        }, s.prototype.bitLength = function() {
            var f = this.words[this.length - 1],
                h = this._countBits(f);
            return (this.length - 1) * 26 + h
        };

        function V(p) {
            for (var f = new Array(p.bitLength()), h = 0; h < f.length; h++) {
                var b = h / 26 | 0,
                    C = h % 26;
                f[h] = p.words[b] >>> C & 1
            }
            return f
        }
        s.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var f = 0, h = 0; h < this.length; h++) {
                var b = this._zeroBits(this.words[h]);
                if (f += b, b !== 26) break
            }
            return f
        }, s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }, s.prototype.toTwos = function(f) {
            return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone()
        }, s.prototype.fromTwos = function(f) {
            return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone()
        }, s.prototype.isNeg = function() {
            return this.negative !== 0
        }, s.prototype.neg = function() {
            return this.clone().ineg()
        }, s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this
        }, s.prototype.iuor = function(f) {
            for (; this.length < f.length;) this.words[this.length++] = 0;
            for (var h = 0; h < f.length; h++) this.words[h] = this.words[h] | f.words[h];
            return this._strip()
        }, s.prototype.ior = function(f) {
            return n((this.negative | f.negative) === 0), this.iuor(f)
        }, s.prototype.or = function(f) {
            return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this)
        }, s.prototype.uor = function(f) {
            return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this)
        }, s.prototype.iuand = function(f) {
            var h;
            this.length > f.length ? h = f : h = this;
            for (var b = 0; b < h.length; b++) this.words[b] = this.words[b] & f.words[b];
            return this.length = h.length, this._strip()
        }, s.prototype.iand = function(f) {
            return n((this.negative | f.negative) === 0), this.iuand(f)
        }, s.prototype.and = function(f) {
            return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this)
        }, s.prototype.uand = function(f) {
            return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this)
        }, s.prototype.iuxor = function(f) {
            var h, b;
            this.length > f.length ? (h = this, b = f) : (h = f, b = this);
            for (var C = 0; C < b.length; C++) this.words[C] = h.words[C] ^ b.words[C];
            if (this !== h)
                for (; C < h.length; C++) this.words[C] = h.words[C];
            return this.length = h.length, this._strip()
        }, s.prototype.ixor = function(f) {
            return n((this.negative | f.negative) === 0), this.iuxor(f)
        }, s.prototype.xor = function(f) {
            return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this)
        }, s.prototype.uxor = function(f) {
            return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this)
        }, s.prototype.inotn = function(f) {
            n(typeof f == "number" && f >= 0);
            var h = Math.ceil(f / 26) | 0,
                b = f % 26;
            this._expand(h), b > 0 && h--;
            for (var C = 0; C < h; C++) this.words[C] = ~this.words[C] & 67108863;
            return b > 0 && (this.words[C] = ~this.words[C] & 67108863 >> 26 - b), this._strip()
        }, s.prototype.notn = function(f) {
            return this.clone().inotn(f)
        }, s.prototype.setn = function(f, h) {
            n(typeof f == "number" && f >= 0);
            var b = f / 26 | 0,
                C = f % 26;
            return this._expand(b + 1), h ? this.words[b] = this.words[b] | 1 << C : this.words[b] = this.words[b] & ~(1 << C), this._strip()
        }, s.prototype.iadd = function(f) {
            var h;
            if (this.negative !== 0 && f.negative === 0) return this.negative = 0, h = this.isub(f), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && f.negative !== 0) return f.negative = 0, h = this.isub(f), f.negative = 1, h._normSign();
            var b, C;
            this.length > f.length ? (b = this, C = f) : (b = f, C = this);
            for (var _ = 0, M = 0; M < C.length; M++) h = (b.words[M] | 0) + (C.words[M] | 0) + _, this.words[M] = h & 67108863, _ = h >>> 26;
            for (; _ !== 0 && M < b.length; M++) h = (b.words[M] | 0) + _, this.words[M] = h & 67108863, _ = h >>> 26;
            if (this.length = b.length, _ !== 0) this.words[this.length] = _, this.length++;
            else if (b !== this)
                for (; M < b.length; M++) this.words[M] = b.words[M];
            return this
        }, s.prototype.add = function(f) {
            var h;
            return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, h = this.sub(f), f.negative ^= 1, h) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = f.sub(this), this.negative = 1, h) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this)
        }, s.prototype.isub = function(f) {
            if (f.negative !== 0) {
                f.negative = 0;
                var h = this.iadd(f);
                return f.negative = 1, h._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
            var b = this.cmp(f);
            if (b === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var C, _;
            b > 0 ? (C = this, _ = f) : (C = f, _ = this);
            for (var M = 0, m = 0; m < _.length; m++) h = (C.words[m] | 0) - (_.words[m] | 0) + M, M = h >> 26, this.words[m] = h & 67108863;
            for (; M !== 0 && m < C.length; m++) h = (C.words[m] | 0) + M, M = h >> 26, this.words[m] = h & 67108863;
            if (M === 0 && m < C.length && C !== this)
                for (; m < C.length; m++) this.words[m] = C.words[m];
            return this.length = Math.max(this.length, m), C !== this && (this.negative = 1), this._strip()
        }, s.prototype.sub = function(f) {
            return this.clone().isub(f)
        };

        function P(p, f, h) {
            h.negative = f.negative ^ p.negative;
            var b = p.length + f.length | 0;
            h.length = b, b = b - 1 | 0;
            var C = p.words[0] | 0,
                _ = f.words[0] | 0,
                M = C * _,
                m = M & 67108863,
                A = M / 67108864 | 0;
            h.words[0] = m;
            for (var x = 1; x < b; x++) {
                for (var z = A >>> 26, oe = A & 67108863, k = Math.min(x, f.length - 1), X = Math.max(0, x - p.length + 1); X <= k; X++) {
                    var re = x - X | 0;
                    C = p.words[re] | 0, _ = f.words[X] | 0, M = C * _ + oe, z += M / 67108864 | 0, oe = M & 67108863
                }
                h.words[x] = oe | 0, A = z | 0
            }
            return A !== 0 ? h.words[x] = A | 0 : h.length--, h._strip()
        }
        var O = function(f, h, b) {
            var C = f.words,
                _ = h.words,
                M = b.words,
                m = 0,
                A, x, z, oe = C[0] | 0,
                k = oe & 8191,
                X = oe >>> 13,
                re = C[1] | 0,
                ae = re & 8191,
                le = re >>> 13,
                Me = C[2] | 0,
                Re = Me & 8191,
                ve = Me >>> 13,
                We = C[3] | 0,
                Ie = We & 8191,
                Ue = We >>> 13,
                Ut = C[4] | 0,
                It = Ut & 8191,
                it = Ut >>> 13,
                At = C[5] | 0,
                Ct = At & 8191,
                Ye = At >>> 13,
                Xe = C[6] | 0,
                St = Xe & 8191,
                Ze = Xe >>> 13,
                ft = C[7] | 0,
                Ot = ft & 8191,
                v = ft >>> 13,
                u = C[8] | 0,
                l = u & 8191,
                S = u >>> 13,
                D = C[9] | 0,
                $ = D & 8191,
                Q = D >>> 13,
                he = _[0] | 0,
                Be = he & 8191,
                ge = he >>> 13,
                Te = _[1] | 0,
                Se = Te & 8191,
                ot = Te >>> 13,
                Gt = _[2] | 0,
                Zt = Gt & 8191,
                ht = Gt >>> 13,
                tr = _[3] | 0,
                Nt = tr & 8191,
                et = tr >>> 13,
                Lt = _[4] | 0,
                Yt = Lt & 8191,
                ct = Lt >>> 13,
                Jt = _[5] | 0,
                rr = Jt & 8191,
                Ve = Jt >>> 13,
                Xt = _[6] | 0,
                B = Xt & 8191,
                L = Xt >>> 13,
                F = _[7] | 0,
                g = F & 8191,
                U = F >>> 13,
                Z = _[8] | 0,
                ee = Z & 8191,
                te = Z >>> 13,
                fe = _[9] | 0,
                Ae = fe & 8191,
                ye = fe >>> 13;
            b.negative = f.negative ^ h.negative, b.length = 19, A = Math.imul(k, Be), x = Math.imul(k, ge), x = x + Math.imul(X, Be) | 0, z = Math.imul(X, ge);
            var dt = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, A = Math.imul(ae, Be), x = Math.imul(ae, ge), x = x + Math.imul(le, Be) | 0, z = Math.imul(le, ge), A = A + Math.imul(k, Se) | 0, x = x + Math.imul(k, ot) | 0, x = x + Math.imul(X, Se) | 0, z = z + Math.imul(X, ot) | 0;
            var Ne = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, A = Math.imul(Re, Be), x = Math.imul(Re, ge), x = x + Math.imul(ve, Be) | 0, z = Math.imul(ve, ge), A = A + Math.imul(ae, Se) | 0, x = x + Math.imul(ae, ot) | 0, x = x + Math.imul(le, Se) | 0, z = z + Math.imul(le, ot) | 0, A = A + Math.imul(k, Zt) | 0, x = x + Math.imul(k, ht) | 0, x = x + Math.imul(X, Zt) | 0, z = z + Math.imul(X, ht) | 0;
            var Ge = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, A = Math.imul(Ie, Be), x = Math.imul(Ie, ge), x = x + Math.imul(Ue, Be) | 0, z = Math.imul(Ue, ge), A = A + Math.imul(Re, Se) | 0, x = x + Math.imul(Re, ot) | 0, x = x + Math.imul(ve, Se) | 0, z = z + Math.imul(ve, ot) | 0, A = A + Math.imul(ae, Zt) | 0, x = x + Math.imul(ae, ht) | 0, x = x + Math.imul(le, Zt) | 0, z = z + Math.imul(le, ht) | 0, A = A + Math.imul(k, Nt) | 0, x = x + Math.imul(k, et) | 0, x = x + Math.imul(X, Nt) | 0, z = z + Math.imul(X, et) | 0;
            var Ke = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, A = Math.imul(It, Be), x = Math.imul(It, ge), x = x + Math.imul(it, Be) | 0, z = Math.imul(it, ge), A = A + Math.imul(Ie, Se) | 0, x = x + Math.imul(Ie, ot) | 0, x = x + Math.imul(Ue, Se) | 0, z = z + Math.imul(Ue, ot) | 0, A = A + Math.imul(Re, Zt) | 0, x = x + Math.imul(Re, ht) | 0, x = x + Math.imul(ve, Zt) | 0, z = z + Math.imul(ve, ht) | 0, A = A + Math.imul(ae, Nt) | 0, x = x + Math.imul(ae, et) | 0, x = x + Math.imul(le, Nt) | 0, z = z + Math.imul(le, et) | 0, A = A + Math.imul(k, Yt) | 0, x = x + Math.imul(k, ct) | 0, x = x + Math.imul(X, Yt) | 0, z = z + Math.imul(X, ct) | 0;
            var Je = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, A = Math.imul(Ct, Be), x = Math.imul(Ct, ge), x = x + Math.imul(Ye, Be) | 0, z = Math.imul(Ye, ge), A = A + Math.imul(It, Se) | 0, x = x + Math.imul(It, ot) | 0, x = x + Math.imul(it, Se) | 0, z = z + Math.imul(it, ot) | 0, A = A + Math.imul(Ie, Zt) | 0, x = x + Math.imul(Ie, ht) | 0, x = x + Math.imul(Ue, Zt) | 0, z = z + Math.imul(Ue, ht) | 0, A = A + Math.imul(Re, Nt) | 0, x = x + Math.imul(Re, et) | 0, x = x + Math.imul(ve, Nt) | 0, z = z + Math.imul(ve, et) | 0, A = A + Math.imul(ae, Yt) | 0, x = x + Math.imul(ae, ct) | 0, x = x + Math.imul(le, Yt) | 0, z = z + Math.imul(le, ct) | 0, A = A + Math.imul(k, rr) | 0, x = x + Math.imul(k, Ve) | 0, x = x + Math.imul(X, rr) | 0, z = z + Math.imul(X, Ve) | 0;
            var ut = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, A = Math.imul(St, Be), x = Math.imul(St, ge), x = x + Math.imul(Ze, Be) | 0, z = Math.imul(Ze, ge), A = A + Math.imul(Ct, Se) | 0, x = x + Math.imul(Ct, ot) | 0, x = x + Math.imul(Ye, Se) | 0, z = z + Math.imul(Ye, ot) | 0, A = A + Math.imul(It, Zt) | 0, x = x + Math.imul(It, ht) | 0, x = x + Math.imul(it, Zt) | 0, z = z + Math.imul(it, ht) | 0, A = A + Math.imul(Ie, Nt) | 0, x = x + Math.imul(Ie, et) | 0, x = x + Math.imul(Ue, Nt) | 0, z = z + Math.imul(Ue, et) | 0, A = A + Math.imul(Re, Yt) | 0, x = x + Math.imul(Re, ct) | 0, x = x + Math.imul(ve, Yt) | 0, z = z + Math.imul(ve, ct) | 0, A = A + Math.imul(ae, rr) | 0, x = x + Math.imul(ae, Ve) | 0, x = x + Math.imul(le, rr) | 0, z = z + Math.imul(le, Ve) | 0, A = A + Math.imul(k, B) | 0, x = x + Math.imul(k, L) | 0, x = x + Math.imul(X, B) | 0, z = z + Math.imul(X, L) | 0;
            var tt = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, A = Math.imul(Ot, Be), x = Math.imul(Ot, ge), x = x + Math.imul(v, Be) | 0, z = Math.imul(v, ge), A = A + Math.imul(St, Se) | 0, x = x + Math.imul(St, ot) | 0, x = x + Math.imul(Ze, Se) | 0, z = z + Math.imul(Ze, ot) | 0, A = A + Math.imul(Ct, Zt) | 0, x = x + Math.imul(Ct, ht) | 0, x = x + Math.imul(Ye, Zt) | 0, z = z + Math.imul(Ye, ht) | 0, A = A + Math.imul(It, Nt) | 0, x = x + Math.imul(It, et) | 0, x = x + Math.imul(it, Nt) | 0, z = z + Math.imul(it, et) | 0, A = A + Math.imul(Ie, Yt) | 0, x = x + Math.imul(Ie, ct) | 0, x = x + Math.imul(Ue, Yt) | 0, z = z + Math.imul(Ue, ct) | 0, A = A + Math.imul(Re, rr) | 0, x = x + Math.imul(Re, Ve) | 0, x = x + Math.imul(ve, rr) | 0, z = z + Math.imul(ve, Ve) | 0, A = A + Math.imul(ae, B) | 0, x = x + Math.imul(ae, L) | 0, x = x + Math.imul(le, B) | 0, z = z + Math.imul(le, L) | 0, A = A + Math.imul(k, g) | 0, x = x + Math.imul(k, U) | 0, x = x + Math.imul(X, g) | 0, z = z + Math.imul(X, U) | 0;
            var st = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, A = Math.imul(l, Be), x = Math.imul(l, ge), x = x + Math.imul(S, Be) | 0, z = Math.imul(S, ge), A = A + Math.imul(Ot, Se) | 0, x = x + Math.imul(Ot, ot) | 0, x = x + Math.imul(v, Se) | 0, z = z + Math.imul(v, ot) | 0, A = A + Math.imul(St, Zt) | 0, x = x + Math.imul(St, ht) | 0, x = x + Math.imul(Ze, Zt) | 0, z = z + Math.imul(Ze, ht) | 0, A = A + Math.imul(Ct, Nt) | 0, x = x + Math.imul(Ct, et) | 0, x = x + Math.imul(Ye, Nt) | 0, z = z + Math.imul(Ye, et) | 0, A = A + Math.imul(It, Yt) | 0, x = x + Math.imul(It, ct) | 0, x = x + Math.imul(it, Yt) | 0, z = z + Math.imul(it, ct) | 0, A = A + Math.imul(Ie, rr) | 0, x = x + Math.imul(Ie, Ve) | 0, x = x + Math.imul(Ue, rr) | 0, z = z + Math.imul(Ue, Ve) | 0, A = A + Math.imul(Re, B) | 0, x = x + Math.imul(Re, L) | 0, x = x + Math.imul(ve, B) | 0, z = z + Math.imul(ve, L) | 0, A = A + Math.imul(ae, g) | 0, x = x + Math.imul(ae, U) | 0, x = x + Math.imul(le, g) | 0, z = z + Math.imul(le, U) | 0, A = A + Math.imul(k, ee) | 0, x = x + Math.imul(k, te) | 0, x = x + Math.imul(X, ee) | 0, z = z + Math.imul(X, te) | 0;
            var rt = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, A = Math.imul($, Be), x = Math.imul($, ge), x = x + Math.imul(Q, Be) | 0, z = Math.imul(Q, ge), A = A + Math.imul(l, Se) | 0, x = x + Math.imul(l, ot) | 0, x = x + Math.imul(S, Se) | 0, z = z + Math.imul(S, ot) | 0, A = A + Math.imul(Ot, Zt) | 0, x = x + Math.imul(Ot, ht) | 0, x = x + Math.imul(v, Zt) | 0, z = z + Math.imul(v, ht) | 0, A = A + Math.imul(St, Nt) | 0, x = x + Math.imul(St, et) | 0, x = x + Math.imul(Ze, Nt) | 0, z = z + Math.imul(Ze, et) | 0, A = A + Math.imul(Ct, Yt) | 0, x = x + Math.imul(Ct, ct) | 0, x = x + Math.imul(Ye, Yt) | 0, z = z + Math.imul(Ye, ct) | 0, A = A + Math.imul(It, rr) | 0, x = x + Math.imul(It, Ve) | 0, x = x + Math.imul(it, rr) | 0, z = z + Math.imul(it, Ve) | 0, A = A + Math.imul(Ie, B) | 0, x = x + Math.imul(Ie, L) | 0, x = x + Math.imul(Ue, B) | 0, z = z + Math.imul(Ue, L) | 0, A = A + Math.imul(Re, g) | 0, x = x + Math.imul(Re, U) | 0, x = x + Math.imul(ve, g) | 0, z = z + Math.imul(ve, U) | 0, A = A + Math.imul(ae, ee) | 0, x = x + Math.imul(ae, te) | 0, x = x + Math.imul(le, ee) | 0, z = z + Math.imul(le, te) | 0, A = A + Math.imul(k, Ae) | 0, x = x + Math.imul(k, ye) | 0, x = x + Math.imul(X, Ae) | 0, z = z + Math.imul(X, ye) | 0;
            var Pe = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, A = Math.imul($, Se), x = Math.imul($, ot), x = x + Math.imul(Q, Se) | 0, z = Math.imul(Q, ot), A = A + Math.imul(l, Zt) | 0, x = x + Math.imul(l, ht) | 0, x = x + Math.imul(S, Zt) | 0, z = z + Math.imul(S, ht) | 0, A = A + Math.imul(Ot, Nt) | 0, x = x + Math.imul(Ot, et) | 0, x = x + Math.imul(v, Nt) | 0, z = z + Math.imul(v, et) | 0, A = A + Math.imul(St, Yt) | 0, x = x + Math.imul(St, ct) | 0, x = x + Math.imul(Ze, Yt) | 0, z = z + Math.imul(Ze, ct) | 0, A = A + Math.imul(Ct, rr) | 0, x = x + Math.imul(Ct, Ve) | 0, x = x + Math.imul(Ye, rr) | 0, z = z + Math.imul(Ye, Ve) | 0, A = A + Math.imul(It, B) | 0, x = x + Math.imul(It, L) | 0, x = x + Math.imul(it, B) | 0, z = z + Math.imul(it, L) | 0, A = A + Math.imul(Ie, g) | 0, x = x + Math.imul(Ie, U) | 0, x = x + Math.imul(Ue, g) | 0, z = z + Math.imul(Ue, U) | 0, A = A + Math.imul(Re, ee) | 0, x = x + Math.imul(Re, te) | 0, x = x + Math.imul(ve, ee) | 0, z = z + Math.imul(ve, te) | 0, A = A + Math.imul(ae, Ae) | 0, x = x + Math.imul(ae, ye) | 0, x = x + Math.imul(le, Ae) | 0, z = z + Math.imul(le, ye) | 0;
            var He = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, A = Math.imul($, Zt), x = Math.imul($, ht), x = x + Math.imul(Q, Zt) | 0, z = Math.imul(Q, ht), A = A + Math.imul(l, Nt) | 0, x = x + Math.imul(l, et) | 0, x = x + Math.imul(S, Nt) | 0, z = z + Math.imul(S, et) | 0, A = A + Math.imul(Ot, Yt) | 0, x = x + Math.imul(Ot, ct) | 0, x = x + Math.imul(v, Yt) | 0, z = z + Math.imul(v, ct) | 0, A = A + Math.imul(St, rr) | 0, x = x + Math.imul(St, Ve) | 0, x = x + Math.imul(Ze, rr) | 0, z = z + Math.imul(Ze, Ve) | 0, A = A + Math.imul(Ct, B) | 0, x = x + Math.imul(Ct, L) | 0, x = x + Math.imul(Ye, B) | 0, z = z + Math.imul(Ye, L) | 0, A = A + Math.imul(It, g) | 0, x = x + Math.imul(It, U) | 0, x = x + Math.imul(it, g) | 0, z = z + Math.imul(it, U) | 0, A = A + Math.imul(Ie, ee) | 0, x = x + Math.imul(Ie, te) | 0, x = x + Math.imul(Ue, ee) | 0, z = z + Math.imul(Ue, te) | 0, A = A + Math.imul(Re, Ae) | 0, x = x + Math.imul(Re, ye) | 0, x = x + Math.imul(ve, Ae) | 0, z = z + Math.imul(ve, ye) | 0;
            var Oe = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, A = Math.imul($, Nt), x = Math.imul($, et), x = x + Math.imul(Q, Nt) | 0, z = Math.imul(Q, et), A = A + Math.imul(l, Yt) | 0, x = x + Math.imul(l, ct) | 0, x = x + Math.imul(S, Yt) | 0, z = z + Math.imul(S, ct) | 0, A = A + Math.imul(Ot, rr) | 0, x = x + Math.imul(Ot, Ve) | 0, x = x + Math.imul(v, rr) | 0, z = z + Math.imul(v, Ve) | 0, A = A + Math.imul(St, B) | 0, x = x + Math.imul(St, L) | 0, x = x + Math.imul(Ze, B) | 0, z = z + Math.imul(Ze, L) | 0, A = A + Math.imul(Ct, g) | 0, x = x + Math.imul(Ct, U) | 0, x = x + Math.imul(Ye, g) | 0, z = z + Math.imul(Ye, U) | 0, A = A + Math.imul(It, ee) | 0, x = x + Math.imul(It, te) | 0, x = x + Math.imul(it, ee) | 0, z = z + Math.imul(it, te) | 0, A = A + Math.imul(Ie, Ae) | 0, x = x + Math.imul(Ie, ye) | 0, x = x + Math.imul(Ue, Ae) | 0, z = z + Math.imul(Ue, ye) | 0;
            var Le = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, A = Math.imul($, Yt), x = Math.imul($, ct), x = x + Math.imul(Q, Yt) | 0, z = Math.imul(Q, ct), A = A + Math.imul(l, rr) | 0, x = x + Math.imul(l, Ve) | 0, x = x + Math.imul(S, rr) | 0, z = z + Math.imul(S, Ve) | 0, A = A + Math.imul(Ot, B) | 0, x = x + Math.imul(Ot, L) | 0, x = x + Math.imul(v, B) | 0, z = z + Math.imul(v, L) | 0, A = A + Math.imul(St, g) | 0, x = x + Math.imul(St, U) | 0, x = x + Math.imul(Ze, g) | 0, z = z + Math.imul(Ze, U) | 0, A = A + Math.imul(Ct, ee) | 0, x = x + Math.imul(Ct, te) | 0, x = x + Math.imul(Ye, ee) | 0, z = z + Math.imul(Ye, te) | 0, A = A + Math.imul(It, Ae) | 0, x = x + Math.imul(It, ye) | 0, x = x + Math.imul(it, Ae) | 0, z = z + Math.imul(it, ye) | 0;
            var ze = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, A = Math.imul($, rr), x = Math.imul($, Ve), x = x + Math.imul(Q, rr) | 0, z = Math.imul(Q, Ve), A = A + Math.imul(l, B) | 0, x = x + Math.imul(l, L) | 0, x = x + Math.imul(S, B) | 0, z = z + Math.imul(S, L) | 0, A = A + Math.imul(Ot, g) | 0, x = x + Math.imul(Ot, U) | 0, x = x + Math.imul(v, g) | 0, z = z + Math.imul(v, U) | 0, A = A + Math.imul(St, ee) | 0, x = x + Math.imul(St, te) | 0, x = x + Math.imul(Ze, ee) | 0, z = z + Math.imul(Ze, te) | 0, A = A + Math.imul(Ct, Ae) | 0, x = x + Math.imul(Ct, ye) | 0, x = x + Math.imul(Ye, Ae) | 0, z = z + Math.imul(Ye, ye) | 0;
            var ke = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, A = Math.imul($, B), x = Math.imul($, L), x = x + Math.imul(Q, B) | 0, z = Math.imul(Q, L), A = A + Math.imul(l, g) | 0, x = x + Math.imul(l, U) | 0, x = x + Math.imul(S, g) | 0, z = z + Math.imul(S, U) | 0, A = A + Math.imul(Ot, ee) | 0, x = x + Math.imul(Ot, te) | 0, x = x + Math.imul(v, ee) | 0, z = z + Math.imul(v, te) | 0, A = A + Math.imul(St, Ae) | 0, x = x + Math.imul(St, ye) | 0, x = x + Math.imul(Ze, Ae) | 0, z = z + Math.imul(Ze, ye) | 0;
            var ie = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (ie >>> 26) | 0, ie &= 67108863, A = Math.imul($, g), x = Math.imul($, U), x = x + Math.imul(Q, g) | 0, z = Math.imul(Q, U), A = A + Math.imul(l, ee) | 0, x = x + Math.imul(l, te) | 0, x = x + Math.imul(S, ee) | 0, z = z + Math.imul(S, te) | 0, A = A + Math.imul(Ot, Ae) | 0, x = x + Math.imul(Ot, ye) | 0, x = x + Math.imul(v, Ae) | 0, z = z + Math.imul(v, ye) | 0;
            var se = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (se >>> 26) | 0, se &= 67108863, A = Math.imul($, ee), x = Math.imul($, te), x = x + Math.imul(Q, ee) | 0, z = Math.imul(Q, te), A = A + Math.imul(l, Ae) | 0, x = x + Math.imul(l, ye) | 0, x = x + Math.imul(S, Ae) | 0, z = z + Math.imul(S, ye) | 0;
            var me = (m + A | 0) + ((x & 8191) << 13) | 0;
            m = (z + (x >>> 13) | 0) + (me >>> 26) | 0, me &= 67108863, A = Math.imul($, Ae), x = Math.imul($, ye), x = x + Math.imul(Q, Ae) | 0, z = Math.imul(Q, ye);
            var ce = (m + A | 0) + ((x & 8191) << 13) | 0;
            return m = (z + (x >>> 13) | 0) + (ce >>> 26) | 0, ce &= 67108863, M[0] = dt, M[1] = Ne, M[2] = Ge, M[3] = Ke, M[4] = Je, M[5] = ut, M[6] = tt, M[7] = st, M[8] = rt, M[9] = Pe, M[10] = He, M[11] = Oe, M[12] = Le, M[13] = ze, M[14] = ke, M[15] = ie, M[16] = se, M[17] = me, M[18] = ce, m !== 0 && (M[19] = m, b.length++), b
        };
        Math.imul || (O = P);

        function R(p, f, h) {
            h.negative = f.negative ^ p.negative, h.length = p.length + f.length;
            for (var b = 0, C = 0, _ = 0; _ < h.length - 1; _++) {
                var M = C;
                C = 0;
                for (var m = b & 67108863, A = Math.min(_, f.length - 1), x = Math.max(0, _ - p.length + 1); x <= A; x++) {
                    var z = _ - x,
                        oe = p.words[z] | 0,
                        k = f.words[x] | 0,
                        X = oe * k,
                        re = X & 67108863;
                    M = M + (X / 67108864 | 0) | 0, re = re + m | 0, m = re & 67108863, M = M + (re >>> 26) | 0, C += M >>> 26, M &= 67108863
                }
                h.words[_] = m, b = M, M = C
            }
            return b !== 0 ? h.words[_] = b : h.length--, h._strip()
        }

        function q(p, f, h) {
            return R(p, f, h)
        }
        s.prototype.mulTo = function(f, h) {
            var b, C = this.length + f.length;
            return this.length === 10 && f.length === 10 ? b = O(this, f, h) : C < 63 ? b = P(this, f, h) : C < 1024 ? b = R(this, f, h) : b = q(this, f, h), b
        }, s.prototype.mul = function(f) {
            var h = new s(null);
            return h.words = new Array(this.length + f.length), this.mulTo(f, h)
        }, s.prototype.mulf = function(f) {
            var h = new s(null);
            return h.words = new Array(this.length + f.length), q(this, f, h)
        }, s.prototype.imul = function(f) {
            return this.clone().mulTo(f, this)
        }, s.prototype.imuln = function(f) {
            var h = f < 0;
            h && (f = -f), n(typeof f == "number"), n(f < 67108864);
            for (var b = 0, C = 0; C < this.length; C++) {
                var _ = (this.words[C] | 0) * f,
                    M = (_ & 67108863) + (b & 67108863);
                b >>= 26, b += _ / 67108864 | 0, b += M >>> 26, this.words[C] = M & 67108863
            }
            return b !== 0 && (this.words[C] = b, this.length++), h ? this.ineg() : this
        }, s.prototype.muln = function(f) {
            return this.clone().imuln(f)
        }, s.prototype.sqr = function() {
            return this.mul(this)
        }, s.prototype.isqr = function() {
            return this.imul(this.clone())
        }, s.prototype.pow = function(f) {
            var h = V(f);
            if (h.length === 0) return new s(1);
            for (var b = this, C = 0; C < h.length && h[C] === 0; C++, b = b.sqr());
            if (++C < h.length)
                for (var _ = b.sqr(); C < h.length; C++, _ = _.sqr()) h[C] !== 0 && (b = b.mul(_));
            return b
        }, s.prototype.iushln = function(f) {
            n(typeof f == "number" && f >= 0);
            var h = f % 26,
                b = (f - h) / 26,
                C = 67108863 >>> 26 - h << 26 - h,
                _;
            if (h !== 0) {
                var M = 0;
                for (_ = 0; _ < this.length; _++) {
                    var m = this.words[_] & C,
                        A = (this.words[_] | 0) - m << h;
                    this.words[_] = A | M, M = m >>> 26 - h
                }
                M && (this.words[_] = M, this.length++)
            }
            if (b !== 0) {
                for (_ = this.length - 1; _ >= 0; _--) this.words[_ + b] = this.words[_];
                for (_ = 0; _ < b; _++) this.words[_] = 0;
                this.length += b
            }
            return this._strip()
        }, s.prototype.ishln = function(f) {
            return n(this.negative === 0), this.iushln(f)
        }, s.prototype.iushrn = function(f, h, b) {
            n(typeof f == "number" && f >= 0);
            var C;
            h ? C = (h - h % 26) / 26 : C = 0;
            var _ = f % 26,
                M = Math.min((f - _) / 26, this.length),
                m = 67108863 ^ 67108863 >>> _ << _,
                A = b;
            if (C -= M, C = Math.max(0, C), A) {
                for (var x = 0; x < M; x++) A.words[x] = this.words[x];
                A.length = M
            }
            if (M !== 0)
                if (this.length > M)
                    for (this.length -= M, x = 0; x < this.length; x++) this.words[x] = this.words[x + M];
                else this.words[0] = 0, this.length = 1;
            var z = 0;
            for (x = this.length - 1; x >= 0 && (z !== 0 || x >= C); x--) {
                var oe = this.words[x] | 0;
                this.words[x] = z << 26 - _ | oe >>> _, z = oe & m
            }
            return A && z !== 0 && (A.words[A.length++] = z), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
        }, s.prototype.ishrn = function(f, h, b) {
            return n(this.negative === 0), this.iushrn(f, h, b)
        }, s.prototype.shln = function(f) {
            return this.clone().ishln(f)
        }, s.prototype.ushln = function(f) {
            return this.clone().iushln(f)
        }, s.prototype.shrn = function(f) {
            return this.clone().ishrn(f)
        }, s.prototype.ushrn = function(f) {
            return this.clone().iushrn(f)
        }, s.prototype.testn = function(f) {
            n(typeof f == "number" && f >= 0);
            var h = f % 26,
                b = (f - h) / 26,
                C = 1 << h;
            if (this.length <= b) return !1;
            var _ = this.words[b];
            return !!(_ & C)
        }, s.prototype.imaskn = function(f) {
            n(typeof f == "number" && f >= 0);
            var h = f % 26,
                b = (f - h) / 26;
            if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= b) return this;
            if (h !== 0 && b++, this.length = Math.min(b, this.length), h !== 0) {
                var C = 67108863 ^ 67108863 >>> h << h;
                this.words[this.length - 1] &= C
            }
            return this._strip()
        }, s.prototype.maskn = function(f) {
            return this.clone().imaskn(f)
        }, s.prototype.iaddn = function(f) {
            return n(typeof f == "number"), n(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f)
        }, s.prototype._iaddn = function(f) {
            this.words[0] += f;
            for (var h = 0; h < this.length && this.words[h] >= 67108864; h++) this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
            return this.length = Math.max(this.length, h + 1), this
        }, s.prototype.isubn = function(f) {
            if (n(typeof f == "number"), n(f < 67108864), f < 0) return this.iaddn(-f);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(f), this.negative = 1, this;
            if (this.words[0] -= f, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else
                for (var h = 0; h < this.length && this.words[h] < 0; h++) this.words[h] += 67108864, this.words[h + 1] -= 1;
            return this._strip()
        }, s.prototype.addn = function(f) {
            return this.clone().iaddn(f)
        }, s.prototype.subn = function(f) {
            return this.clone().isubn(f)
        }, s.prototype.iabs = function() {
            return this.negative = 0, this
        }, s.prototype.abs = function() {
            return this.clone().iabs()
        }, s.prototype._ishlnsubmul = function(f, h, b) {
            var C = f.length + b,
                _;
            this._expand(C);
            var M, m = 0;
            for (_ = 0; _ < f.length; _++) {
                M = (this.words[_ + b] | 0) + m;
                var A = (f.words[_] | 0) * h;
                M -= A & 67108863, m = (M >> 26) - (A / 67108864 | 0), this.words[_ + b] = M & 67108863
            }
            for (; _ < this.length - b; _++) M = (this.words[_ + b] | 0) + m, m = M >> 26, this.words[_ + b] = M & 67108863;
            if (m === 0) return this._strip();
            for (n(m === -1), m = 0, _ = 0; _ < this.length; _++) M = -(this.words[_] | 0) + m, m = M >> 26, this.words[_] = M & 67108863;
            return this.negative = 1, this._strip()
        }, s.prototype._wordDiv = function(f, h) {
            var b = this.length - f.length,
                C = this.clone(),
                _ = f,
                M = _.words[_.length - 1] | 0,
                m = this._countBits(M);
            b = 26 - m, b !== 0 && (_ = _.ushln(b), C.iushln(b), M = _.words[_.length - 1] | 0);
            var A = C.length - _.length,
                x;
            if (h !== "mod") {
                x = new s(null), x.length = A + 1, x.words = new Array(x.length);
                for (var z = 0; z < x.length; z++) x.words[z] = 0
            }
            var oe = C.clone()._ishlnsubmul(_, 1, A);
            oe.negative === 0 && (C = oe, x && (x.words[A] = 1));
            for (var k = A - 1; k >= 0; k--) {
                var X = (C.words[_.length + k] | 0) * 67108864 + (C.words[_.length + k - 1] | 0);
                for (X = Math.min(X / M | 0, 67108863), C._ishlnsubmul(_, X, k); C.negative !== 0;) X--, C.negative = 0, C._ishlnsubmul(_, 1, k), C.isZero() || (C.negative ^= 1);
                x && (x.words[k] = X)
            }
            return x && x._strip(), C._strip(), h !== "div" && b !== 0 && C.iushrn(b), {
                div: x || null,
                mod: C
            }
        }, s.prototype.divmod = function(f, h, b) {
            if (n(!f.isZero()), this.isZero()) return {
                div: new s(0),
                mod: new s(0)
            };
            var C, _, M;
            return this.negative !== 0 && f.negative === 0 ? (M = this.neg().divmod(f, h), h !== "mod" && (C = M.div.neg()), h !== "div" && (_ = M.mod.neg(), b && _.negative !== 0 && _.iadd(f)), {
                div: C,
                mod: _
            }) : this.negative === 0 && f.negative !== 0 ? (M = this.divmod(f.neg(), h), h !== "mod" && (C = M.div.neg()), {
                div: C,
                mod: M.mod
            }) : (this.negative & f.negative) !== 0 ? (M = this.neg().divmod(f.neg(), h), h !== "div" && (_ = M.mod.neg(), b && _.negative !== 0 && _.isub(f)), {
                div: M.div,
                mod: _
            }) : f.length > this.length || this.cmp(f) < 0 ? {
                div: new s(0),
                mod: this
            } : f.length === 1 ? h === "div" ? {
                div: this.divn(f.words[0]),
                mod: null
            } : h === "mod" ? {
                div: null,
                mod: new s(this.modrn(f.words[0]))
            } : {
                div: this.divn(f.words[0]),
                mod: new s(this.modrn(f.words[0]))
            } : this._wordDiv(f, h)
        }, s.prototype.div = function(f) {
            return this.divmod(f, "div", !1).div
        }, s.prototype.mod = function(f) {
            return this.divmod(f, "mod", !1).mod
        }, s.prototype.umod = function(f) {
            return this.divmod(f, "mod", !0).mod
        }, s.prototype.divRound = function(f) {
            var h = this.divmod(f);
            if (h.mod.isZero()) return h.div;
            var b = h.div.negative !== 0 ? h.mod.isub(f) : h.mod,
                C = f.ushrn(1),
                _ = f.andln(1),
                M = b.cmp(C);
            return M < 0 || _ === 1 && M === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1)
        }, s.prototype.modrn = function(f) {
            var h = f < 0;
            h && (f = -f), n(f <= 67108863);
            for (var b = (1 << 26) % f, C = 0, _ = this.length - 1; _ >= 0; _--) C = (b * C + (this.words[_] | 0)) % f;
            return h ? -C : C
        }, s.prototype.modn = function(f) {
            return this.modrn(f)
        }, s.prototype.idivn = function(f) {
            var h = f < 0;
            h && (f = -f), n(f <= 67108863);
            for (var b = 0, C = this.length - 1; C >= 0; C--) {
                var _ = (this.words[C] | 0) + b * 67108864;
                this.words[C] = _ / f | 0, b = _ % f
            }
            return this._strip(), h ? this.ineg() : this
        }, s.prototype.divn = function(f) {
            return this.clone().idivn(f)
        }, s.prototype.egcd = function(f) {
            n(f.negative === 0), n(!f.isZero());
            var h = this,
                b = f.clone();
            h.negative !== 0 ? h = h.umod(f) : h = h.clone();
            for (var C = new s(1), _ = new s(0), M = new s(0), m = new s(1), A = 0; h.isEven() && b.isEven();) h.iushrn(1), b.iushrn(1), ++A;
            for (var x = b.clone(), z = h.clone(); !h.isZero();) {
                for (var oe = 0, k = 1;
                    (h.words[0] & k) === 0 && oe < 26; ++oe, k <<= 1);
                if (oe > 0)
                    for (h.iushrn(oe); oe-- > 0;)(C.isOdd() || _.isOdd()) && (C.iadd(x), _.isub(z)), C.iushrn(1), _.iushrn(1);
                for (var X = 0, re = 1;
                    (b.words[0] & re) === 0 && X < 26; ++X, re <<= 1);
                if (X > 0)
                    for (b.iushrn(X); X-- > 0;)(M.isOdd() || m.isOdd()) && (M.iadd(x), m.isub(z)), M.iushrn(1), m.iushrn(1);
                h.cmp(b) >= 0 ? (h.isub(b), C.isub(M), _.isub(m)) : (b.isub(h), M.isub(C), m.isub(_))
            }
            return {
                a: M,
                b: m,
                gcd: b.iushln(A)
            }
        }, s.prototype._invmp = function(f) {
            n(f.negative === 0), n(!f.isZero());
            var h = this,
                b = f.clone();
            h.negative !== 0 ? h = h.umod(f) : h = h.clone();
            for (var C = new s(1), _ = new s(0), M = b.clone(); h.cmpn(1) > 0 && b.cmpn(1) > 0;) {
                for (var m = 0, A = 1;
                    (h.words[0] & A) === 0 && m < 26; ++m, A <<= 1);
                if (m > 0)
                    for (h.iushrn(m); m-- > 0;) C.isOdd() && C.iadd(M), C.iushrn(1);
                for (var x = 0, z = 1;
                    (b.words[0] & z) === 0 && x < 26; ++x, z <<= 1);
                if (x > 0)
                    for (b.iushrn(x); x-- > 0;) _.isOdd() && _.iadd(M), _.iushrn(1);
                h.cmp(b) >= 0 ? (h.isub(b), C.isub(_)) : (b.isub(h), _.isub(C))
            }
            var oe;
            return h.cmpn(1) === 0 ? oe = C : oe = _, oe.cmpn(0) < 0 && oe.iadd(f), oe
        }, s.prototype.gcd = function(f) {
            if (this.isZero()) return f.abs();
            if (f.isZero()) return this.abs();
            var h = this.clone(),
                b = f.clone();
            h.negative = 0, b.negative = 0;
            for (var C = 0; h.isEven() && b.isEven(); C++) h.iushrn(1), b.iushrn(1);
            do {
                for (; h.isEven();) h.iushrn(1);
                for (; b.isEven();) b.iushrn(1);
                var _ = h.cmp(b);
                if (_ < 0) {
                    var M = h;
                    h = b, b = M
                } else if (_ === 0 || b.cmpn(1) === 0) break;
                h.isub(b)
            } while (!0);
            return b.iushln(C)
        }, s.prototype.invm = function(f) {
            return this.egcd(f).a.umod(f)
        }, s.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }, s.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }, s.prototype.andln = function(f) {
            return this.words[0] & f
        }, s.prototype.bincn = function(f) {
            n(typeof f == "number");
            var h = f % 26,
                b = (f - h) / 26,
                C = 1 << h;
            if (this.length <= b) return this._expand(b + 1), this.words[b] |= C, this;
            for (var _ = C, M = b; _ !== 0 && M < this.length; M++) {
                var m = this.words[M] | 0;
                m += _, _ = m >>> 26, m &= 67108863, this.words[M] = m
            }
            return _ !== 0 && (this.words[M] = _, this.length++), this
        }, s.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }, s.prototype.cmpn = function(f) {
            var h = f < 0;
            if (this.negative !== 0 && !h) return -1;
            if (this.negative === 0 && h) return 1;
            this._strip();
            var b;
            if (this.length > 1) b = 1;
            else {
                h && (f = -f), n(f <= 67108863, "Number is too big");
                var C = this.words[0] | 0;
                b = C === f ? 0 : C < f ? -1 : 1
            }
            return this.negative !== 0 ? -b | 0 : b
        }, s.prototype.cmp = function(f) {
            if (this.negative !== 0 && f.negative === 0) return -1;
            if (this.negative === 0 && f.negative !== 0) return 1;
            var h = this.ucmp(f);
            return this.negative !== 0 ? -h | 0 : h
        }, s.prototype.ucmp = function(f) {
            if (this.length > f.length) return 1;
            if (this.length < f.length) return -1;
            for (var h = 0, b = this.length - 1; b >= 0; b--) {
                var C = this.words[b] | 0,
                    _ = f.words[b] | 0;
                if (C !== _) {
                    C < _ ? h = -1 : C > _ && (h = 1);
                    break
                }
            }
            return h
        }, s.prototype.gtn = function(f) {
            return this.cmpn(f) === 1
        }, s.prototype.gt = function(f) {
            return this.cmp(f) === 1
        }, s.prototype.gten = function(f) {
            return this.cmpn(f) >= 0
        }, s.prototype.gte = function(f) {
            return this.cmp(f) >= 0
        }, s.prototype.ltn = function(f) {
            return this.cmpn(f) === -1
        }, s.prototype.lt = function(f) {
            return this.cmp(f) === -1
        }, s.prototype.lten = function(f) {
            return this.cmpn(f) <= 0
        }, s.prototype.lte = function(f) {
            return this.cmp(f) <= 0
        }, s.prototype.eqn = function(f) {
            return this.cmpn(f) === 0
        }, s.prototype.eq = function(f) {
            return this.cmp(f) === 0
        }, s.red = function(f) {
            return new H(f)
        }, s.prototype.toRed = function(f) {
            return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f)
        }, s.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, s.prototype._forceRed = function(f) {
            return this.red = f, this
        }, s.prototype.forceRed = function(f) {
            return n(!this.red, "Already a number in reduction context"), this._forceRed(f)
        }, s.prototype.redAdd = function(f) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, f)
        }, s.prototype.redIAdd = function(f) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f)
        }, s.prototype.redSub = function(f) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, f)
        }, s.prototype.redISub = function(f) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, f)
        }, s.prototype.redShl = function(f) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, f)
        }, s.prototype.redMul = function(f) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f)
        }, s.prototype.redIMul = function(f) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f)
        }, s.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, s.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, s.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, s.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, s.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, s.prototype.redPow = function(f) {
            return n(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f)
        };
        var W = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };

        function Y(p, f) {
            this.name = p, this.p = new s(f, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }
        Y.prototype._tmp = function() {
            var f = new s(null);
            return f.words = new Array(Math.ceil(this.n / 13)), f
        }, Y.prototype.ireduce = function(f) {
            var h = f,
                b;
            do this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), b = h.bitLength(); while (b > this.n);
            var C = b < this.n ? -1 : h.ucmp(this.p);
            return C === 0 ? (h.words[0] = 0, h.length = 1) : C > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h
        }, Y.prototype.split = function(f, h) {
            f.iushrn(this.n, 0, h)
        }, Y.prototype.imulK = function(f) {
            return f.imul(this.k)
        };

        function G() {
            Y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(G, Y), G.prototype.split = function(f, h) {
            for (var b = 4194303, C = Math.min(f.length, 9), _ = 0; _ < C; _++) h.words[_] = f.words[_];
            if (h.length = C, f.length <= 9) {
                f.words[0] = 0, f.length = 1;
                return
            }
            var M = f.words[9];
            for (h.words[h.length++] = M & b, _ = 10; _ < f.length; _++) {
                var m = f.words[_] | 0;
                f.words[_ - 10] = (m & b) << 4 | M >>> 22, M = m
            }
            M >>>= 22, f.words[_ - 10] = M, M === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9
        }, G.prototype.imulK = function(f) {
            f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
            for (var h = 0, b = 0; b < f.length; b++) {
                var C = f.words[b] | 0;
                h += C * 977, f.words[b] = h & 67108863, h = C * 64 + (h / 67108864 | 0)
            }
            return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f
        };

        function J() {
            Y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(J, Y);

        function pe() {
            Y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(pe, Y);

        function we() {
            Y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(we, Y), we.prototype.imulK = function(f) {
            for (var h = 0, b = 0; b < f.length; b++) {
                var C = (f.words[b] | 0) * 19 + h,
                    _ = C & 67108863;
                C >>>= 26, f.words[b] = _, h = C
            }
            return h !== 0 && (f.words[f.length++] = h), f
        }, s._prime = function(f) {
            if (W[f]) return W[f];
            var h;
            if (f === "k256") h = new G;
            else if (f === "p224") h = new J;
            else if (f === "p192") h = new pe;
            else if (f === "p25519") h = new we;
            else throw new Error("Unknown prime " + f);
            return W[f] = h, h
        };

        function H(p) {
            if (typeof p == "string") {
                var f = s._prime(p);
                this.m = f.p, this.prime = f
            } else n(p.gtn(1), "modulus must be greater than 1"), this.m = p, this.prime = null
        }
        H.prototype._verify1 = function(f) {
            n(f.negative === 0, "red works only with positives"), n(f.red, "red works only with red numbers")
        }, H.prototype._verify2 = function(f, h) {
            n((f.negative | h.negative) === 0, "red works only with positives"), n(f.red && f.red === h.red, "red works only with red numbers")
        }, H.prototype.imod = function(f) {
            return this.prime ? this.prime.ireduce(f)._forceRed(this) : (y(f, f.umod(this.m)._forceRed(this)), f)
        }, H.prototype.neg = function(f) {
            return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this)
        }, H.prototype.add = function(f, h) {
            this._verify2(f, h);
            var b = f.add(h);
            return b.cmp(this.m) >= 0 && b.isub(this.m), b._forceRed(this)
        }, H.prototype.iadd = function(f, h) {
            this._verify2(f, h);
            var b = f.iadd(h);
            return b.cmp(this.m) >= 0 && b.isub(this.m), b
        }, H.prototype.sub = function(f, h) {
            this._verify2(f, h);
            var b = f.sub(h);
            return b.cmpn(0) < 0 && b.iadd(this.m), b._forceRed(this)
        }, H.prototype.isub = function(f, h) {
            this._verify2(f, h);
            var b = f.isub(h);
            return b.cmpn(0) < 0 && b.iadd(this.m), b
        }, H.prototype.shl = function(f, h) {
            return this._verify1(f), this.imod(f.ushln(h))
        }, H.prototype.imul = function(f, h) {
            return this._verify2(f, h), this.imod(f.imul(h))
        }, H.prototype.mul = function(f, h) {
            return this._verify2(f, h), this.imod(f.mul(h))
        }, H.prototype.isqr = function(f) {
            return this.imul(f, f.clone())
        }, H.prototype.sqr = function(f) {
            return this.mul(f, f)
        }, H.prototype.sqrt = function(f) {
            if (f.isZero()) return f.clone();
            var h = this.m.andln(3);
            if (n(h % 2 === 1), h === 3) {
                var b = this.m.add(new s(1)).iushrn(2);
                return this.pow(f, b)
            }
            for (var C = this.m.subn(1), _ = 0; !C.isZero() && C.andln(1) === 0;) _++, C.iushrn(1);
            n(!C.isZero());
            var M = new s(1).toRed(this),
                m = M.redNeg(),
                A = this.m.subn(1).iushrn(1),
                x = this.m.bitLength();
            for (x = new s(2 * x * x).toRed(this); this.pow(x, A).cmp(m) !== 0;) x.redIAdd(m);
            for (var z = this.pow(x, C), oe = this.pow(f, C.addn(1).iushrn(1)), k = this.pow(f, C), X = _; k.cmp(M) !== 0;) {
                for (var re = k, ae = 0; re.cmp(M) !== 0; ae++) re = re.redSqr();
                n(ae < X);
                var le = this.pow(z, new s(1).iushln(X - ae - 1));
                oe = oe.redMul(le), z = le.redSqr(), k = k.redMul(z), X = ae
            }
            return oe
        }, H.prototype.invm = function(f) {
            var h = f._invmp(this.m);
            return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h)
        }, H.prototype.pow = function(f, h) {
            if (h.isZero()) return new s(1).toRed(this);
            if (h.cmpn(1) === 0) return f.clone();
            var b = 4,
                C = new Array(1 << b);
            C[0] = new s(1).toRed(this), C[1] = f;
            for (var _ = 2; _ < C.length; _++) C[_] = this.mul(C[_ - 1], f);
            var M = C[0],
                m = 0,
                A = 0,
                x = h.bitLength() % 26;
            for (x === 0 && (x = 26), _ = h.length - 1; _ >= 0; _--) {
                for (var z = h.words[_], oe = x - 1; oe >= 0; oe--) {
                    var k = z >> oe & 1;
                    if (M !== C[0] && (M = this.sqr(M)), k === 0 && m === 0) {
                        A = 0;
                        continue
                    }
                    m <<= 1, m |= k, A++, !(A !== b && (_ !== 0 || oe !== 0)) && (M = this.mul(M, C[m]), A = 0, m = 0)
                }
                x = 26
            }
            return M
        }, H.prototype.convertTo = function(f) {
            var h = f.umod(this.m);
            return h === f ? h.clone() : h
        }, H.prototype.convertFrom = function(f) {
            var h = f.clone();
            return h.red = null, h
        }, s.mont = function(f) {
            return new w(f)
        };

        function w(p) {
            H.call(this, p), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }
        i(w, H), w.prototype.convertTo = function(f) {
            return this.imod(f.ushln(this.shift))
        }, w.prototype.convertFrom = function(f) {
            var h = this.imod(f.mul(this.rinv));
            return h.red = null, h
        }, w.prototype.imul = function(f, h) {
            if (f.isZero() || h.isZero()) return f.words[0] = 0, f.length = 1, f;
            var b = f.imul(h),
                C = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                _ = b.isub(C).iushrn(this.shift),
                M = _;
            return _.cmp(this.m) >= 0 ? M = _.isub(this.m) : _.cmpn(0) < 0 && (M = _.iadd(this.m)), M._forceRed(this)
        }, w.prototype.mul = function(f, h) {
            if (f.isZero() || h.isZero()) return new s(0)._forceRed(this);
            var b = f.mul(h),
                C = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                _ = b.isub(C).iushrn(this.shift),
                M = _;
            return _.cmp(this.m) >= 0 ? M = _.isub(this.m) : _.cmpn(0) < 0 && (M = _.iadd(this.m)), M._forceRed(this)
        }, w.prototype.invm = function(f) {
            var h = this.imod(f._invmp(this.m).mul(this.r2));
            return h._forceRed(this)
        }
    })(t, zn)
})(l1);
var l0 = l1.exports,
    pl = {
        exports: {}
    },
    f1 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
    const e = Al,
        r = Gc,
        n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = a, t.SlowBuffer = O, t.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = s(), !a.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

    function s() {
        try {
            const v = new Uint8Array(1),
                u = {
                    foo: function() {
                        return 42
                    }
                };
            return Object.setPrototypeOf(u, Uint8Array.prototype), Object.setPrototypeOf(v, u), v.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (!!a.isBuffer(this)) return this.buffer
        }
    }), Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (!!a.isBuffer(this)) return this.byteOffset
        }
    });

    function o(v) {
        if (v > i) throw new RangeError('The value "' + v + '" is invalid for option "size"');
        const u = new Uint8Array(v);
        return Object.setPrototypeOf(u, a.prototype), u
    }

    function a(v, u, l) {
        if (typeof v == "number") {
            if (typeof u == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return I(v)
        }
        return c(v, u, l)
    }
    a.poolSize = 8192;

    function c(v, u, l) {
        if (typeof v == "string") return N(v, u);
        if (ArrayBuffer.isView(v)) return T(v);
        if (v == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof v);
        if (Xe(v, ArrayBuffer) || v && Xe(v.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (Xe(v, SharedArrayBuffer) || v && Xe(v.buffer, SharedArrayBuffer))) return j(v, u, l);
        if (typeof v == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const S = v.valueOf && v.valueOf();
        if (S != null && S !== v) return a.from(S, u, l);
        const D = V(v);
        if (D) return D;
        if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof v[Symbol.toPrimitive] == "function") return a.from(v[Symbol.toPrimitive]("string"), u, l);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof v)
    }
    a.from = function(v, u, l) {
        return c(v, u, l)
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);

    function d(v) {
        if (typeof v != "number") throw new TypeError('"size" argument must be of type number');
        if (v < 0) throw new RangeError('The value "' + v + '" is invalid for option "size"')
    }

    function y(v, u, l) {
        return d(v), v <= 0 ? o(v) : u !== void 0 ? typeof l == "string" ? o(v).fill(u, l) : o(v).fill(u) : o(v)
    }
    a.alloc = function(v, u, l) {
        return y(v, u, l)
    };

    function I(v) {
        return d(v), o(v < 0 ? 0 : P(v) | 0)
    }
    a.allocUnsafe = function(v) {
        return I(v)
    }, a.allocUnsafeSlow = function(v) {
        return I(v)
    };

    function N(v, u) {
        if ((typeof u != "string" || u === "") && (u = "utf8"), !a.isEncoding(u)) throw new TypeError("Unknown encoding: " + u);
        const l = R(v, u) | 0;
        let S = o(l);
        const D = S.write(v, u);
        return D !== l && (S = S.slice(0, D)), S
    }

    function E(v) {
        const u = v.length < 0 ? 0 : P(v.length) | 0,
            l = o(u);
        for (let S = 0; S < u; S += 1) l[S] = v[S] & 255;
        return l
    }

    function T(v) {
        if (Xe(v, Uint8Array)) {
            const u = new Uint8Array(v);
            return j(u.buffer, u.byteOffset, u.byteLength)
        }
        return E(v)
    }

    function j(v, u, l) {
        if (u < 0 || v.byteLength < u) throw new RangeError('"offset" is outside of buffer bounds');
        if (v.byteLength < u + (l || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let S;
        return u === void 0 && l === void 0 ? S = new Uint8Array(v) : l === void 0 ? S = new Uint8Array(v, u) : S = new Uint8Array(v, u, l), Object.setPrototypeOf(S, a.prototype), S
    }

    function V(v) {
        if (a.isBuffer(v)) {
            const u = P(v.length) | 0,
                l = o(u);
            return l.length === 0 || v.copy(l, 0, 0, u), l
        }
        if (v.length !== void 0) return typeof v.length != "number" || St(v.length) ? o(0) : E(v);
        if (v.type === "Buffer" && Array.isArray(v.data)) return E(v.data)
    }

    function P(v) {
        if (v >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return v | 0
    }

    function O(v) {
        return +v != v && (v = 0), a.alloc(+v)
    }
    a.isBuffer = function(u) {
        return u != null && u._isBuffer === !0 && u !== a.prototype
    }, a.compare = function(u, l) {
        if (Xe(u, Uint8Array) && (u = a.from(u, u.offset, u.byteLength)), Xe(l, Uint8Array) && (l = a.from(l, l.offset, l.byteLength)), !a.isBuffer(u) || !a.isBuffer(l)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (u === l) return 0;
        let S = u.length,
            D = l.length;
        for (let $ = 0, Q = Math.min(S, D); $ < Q; ++$)
            if (u[$] !== l[$]) {
                S = u[$], D = l[$];
                break
            }
        return S < D ? -1 : D < S ? 1 : 0
    }, a.isEncoding = function(u) {
        switch (String(u).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
        }
    }, a.concat = function(u, l) {
        if (!Array.isArray(u)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (u.length === 0) return a.alloc(0);
        let S;
        if (l === void 0)
            for (l = 0, S = 0; S < u.length; ++S) l += u[S].length;
        const D = a.allocUnsafe(l);
        let $ = 0;
        for (S = 0; S < u.length; ++S) {
            let Q = u[S];
            if (Xe(Q, Uint8Array)) $ + Q.length > D.length ? (a.isBuffer(Q) || (Q = a.from(Q)), Q.copy(D, $)) : Uint8Array.prototype.set.call(D, Q, $);
            else if (a.isBuffer(Q)) Q.copy(D, $);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            $ += Q.length
        }
        return D
    };

    function R(v, u) {
        if (a.isBuffer(v)) return v.length;
        if (ArrayBuffer.isView(v) || Xe(v, ArrayBuffer)) return v.byteLength;
        if (typeof v != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof v);
        const l = v.length,
            S = arguments.length > 2 && arguments[2] === !0;
        if (!S && l === 0) return 0;
        let D = !1;
        for (;;) switch (u) {
            case "ascii":
            case "latin1":
            case "binary":
                return l;
            case "utf8":
            case "utf-8":
                return It(v).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return l * 2;
            case "hex":
                return l >>> 1;
            case "base64":
                return Ct(v).length;
            default:
                if (D) return S ? -1 : It(v).length;
                u = ("" + u).toLowerCase(), D = !0
        }
    }
    a.byteLength = R;

    function q(v, u, l) {
        let S = !1;
        if ((u === void 0 || u < 0) && (u = 0), u > this.length || ((l === void 0 || l > this.length) && (l = this.length), l <= 0) || (l >>>= 0, u >>>= 0, l <= u)) return "";
        for (v || (v = "utf8");;) switch (v) {
            case "hex":
                return M(this, u, l);
            case "utf8":
            case "utf-8":
                return f(this, u, l);
            case "ascii":
                return C(this, u, l);
            case "latin1":
            case "binary":
                return _(this, u, l);
            case "base64":
                return p(this, u, l);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return m(this, u, l);
            default:
                if (S) throw new TypeError("Unknown encoding: " + v);
                v = (v + "").toLowerCase(), S = !0
        }
    }
    a.prototype._isBuffer = !0;

    function W(v, u, l) {
        const S = v[u];
        v[u] = v[l], v[l] = S
    }
    a.prototype.swap16 = function() {
        const u = this.length;
        if (u % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let l = 0; l < u; l += 2) W(this, l, l + 1);
        return this
    }, a.prototype.swap32 = function() {
        const u = this.length;
        if (u % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let l = 0; l < u; l += 4) W(this, l, l + 3), W(this, l + 1, l + 2);
        return this
    }, a.prototype.swap64 = function() {
        const u = this.length;
        if (u % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let l = 0; l < u; l += 8) W(this, l, l + 7), W(this, l + 1, l + 6), W(this, l + 2, l + 5), W(this, l + 3, l + 4);
        return this
    }, a.prototype.toString = function() {
        const u = this.length;
        return u === 0 ? "" : arguments.length === 0 ? f(this, 0, u) : q.apply(this, arguments)
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(u) {
        if (!a.isBuffer(u)) throw new TypeError("Argument must be a Buffer");
        return this === u ? !0 : a.compare(this, u) === 0
    }, a.prototype.inspect = function() {
        let u = "";
        const l = t.INSPECT_MAX_BYTES;
        return u = this.toString("hex", 0, l).replace(/(.{2})/g, "$1 ").trim(), this.length > l && (u += " ... "), "<Buffer " + u + ">"
    }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(u, l, S, D, $) {
        if (Xe(u, Uint8Array) && (u = a.from(u, u.offset, u.byteLength)), !a.isBuffer(u)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof u);
        if (l === void 0 && (l = 0), S === void 0 && (S = u ? u.length : 0), D === void 0 && (D = 0), $ === void 0 && ($ = this.length), l < 0 || S > u.length || D < 0 || $ > this.length) throw new RangeError("out of range index");
        if (D >= $ && l >= S) return 0;
        if (D >= $) return -1;
        if (l >= S) return 1;
        if (l >>>= 0, S >>>= 0, D >>>= 0, $ >>>= 0, this === u) return 0;
        let Q = $ - D,
            he = S - l;
        const Be = Math.min(Q, he),
            ge = this.slice(D, $),
            Te = u.slice(l, S);
        for (let Se = 0; Se < Be; ++Se)
            if (ge[Se] !== Te[Se]) {
                Q = ge[Se], he = Te[Se];
                break
            }
        return Q < he ? -1 : he < Q ? 1 : 0
    };

    function Y(v, u, l, S, D) {
        if (v.length === 0) return -1;
        if (typeof l == "string" ? (S = l, l = 0) : l > 2147483647 ? l = 2147483647 : l < -2147483648 && (l = -2147483648), l = +l, St(l) && (l = D ? 0 : v.length - 1), l < 0 && (l = v.length + l), l >= v.length) {
            if (D) return -1;
            l = v.length - 1
        } else if (l < 0)
            if (D) l = 0;
            else return -1;
        if (typeof u == "string" && (u = a.from(u, S)), a.isBuffer(u)) return u.length === 0 ? -1 : G(v, u, l, S, D);
        if (typeof u == "number") return u = u & 255, typeof Uint8Array.prototype.indexOf == "function" ? D ? Uint8Array.prototype.indexOf.call(v, u, l) : Uint8Array.prototype.lastIndexOf.call(v, u, l) : G(v, [u], l, S, D);
        throw new TypeError("val must be string, number or Buffer")
    }

    function G(v, u, l, S, D) {
        let $ = 1,
            Q = v.length,
            he = u.length;
        if (S !== void 0 && (S = String(S).toLowerCase(), S === "ucs2" || S === "ucs-2" || S === "utf16le" || S === "utf-16le")) {
            if (v.length < 2 || u.length < 2) return -1;
            $ = 2, Q /= 2, he /= 2, l /= 2
        }

        function Be(Te, Se) {
            return $ === 1 ? Te[Se] : Te.readUInt16BE(Se * $)
        }
        let ge;
        if (D) {
            let Te = -1;
            for (ge = l; ge < Q; ge++)
                if (Be(v, ge) === Be(u, Te === -1 ? 0 : ge - Te)) {
                    if (Te === -1 && (Te = ge), ge - Te + 1 === he) return Te * $
                } else Te !== -1 && (ge -= ge - Te), Te = -1
        } else
            for (l + he > Q && (l = Q - he), ge = l; ge >= 0; ge--) {
                let Te = !0;
                for (let Se = 0; Se < he; Se++)
                    if (Be(v, ge + Se) !== Be(u, Se)) {
                        Te = !1;
                        break
                    }
                if (Te) return ge
            }
        return -1
    }
    a.prototype.includes = function(u, l, S) {
        return this.indexOf(u, l, S) !== -1
    }, a.prototype.indexOf = function(u, l, S) {
        return Y(this, u, l, S, !0)
    }, a.prototype.lastIndexOf = function(u, l, S) {
        return Y(this, u, l, S, !1)
    };

    function J(v, u, l, S) {
        l = Number(l) || 0;
        const D = v.length - l;
        S ? (S = Number(S), S > D && (S = D)) : S = D;
        const $ = u.length;
        S > $ / 2 && (S = $ / 2);
        let Q;
        for (Q = 0; Q < S; ++Q) {
            const he = parseInt(u.substr(Q * 2, 2), 16);
            if (St(he)) return Q;
            v[l + Q] = he
        }
        return Q
    }

    function pe(v, u, l, S) {
        return Ye(It(u, v.length - l), v, l, S)
    }

    function we(v, u, l, S) {
        return Ye(it(u), v, l, S)
    }

    function H(v, u, l, S) {
        return Ye(Ct(u), v, l, S)
    }

    function w(v, u, l, S) {
        return Ye(At(u, v.length - l), v, l, S)
    }
    a.prototype.write = function(u, l, S, D) {
        if (l === void 0) D = "utf8", S = this.length, l = 0;
        else if (S === void 0 && typeof l == "string") D = l, S = this.length, l = 0;
        else if (isFinite(l)) l = l >>> 0, isFinite(S) ? (S = S >>> 0, D === void 0 && (D = "utf8")) : (D = S, S = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const $ = this.length - l;
        if ((S === void 0 || S > $) && (S = $), u.length > 0 && (S < 0 || l < 0) || l > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        D || (D = "utf8");
        let Q = !1;
        for (;;) switch (D) {
            case "hex":
                return J(this, u, l, S);
            case "utf8":
            case "utf-8":
                return pe(this, u, l, S);
            case "ascii":
            case "latin1":
            case "binary":
                return we(this, u, l, S);
            case "base64":
                return H(this, u, l, S);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return w(this, u, l, S);
            default:
                if (Q) throw new TypeError("Unknown encoding: " + D);
                D = ("" + D).toLowerCase(), Q = !0
        }
    }, a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    };

    function p(v, u, l) {
        return u === 0 && l === v.length ? e.fromByteArray(v) : e.fromByteArray(v.slice(u, l))
    }

    function f(v, u, l) {
        l = Math.min(v.length, l);
        const S = [];
        let D = u;
        for (; D < l;) {
            const $ = v[D];
            let Q = null,
                he = $ > 239 ? 4 : $ > 223 ? 3 : $ > 191 ? 2 : 1;
            if (D + he <= l) {
                let Be, ge, Te, Se;
                switch (he) {
                    case 1:
                        $ < 128 && (Q = $);
                        break;
                    case 2:
                        Be = v[D + 1], (Be & 192) === 128 && (Se = ($ & 31) << 6 | Be & 63, Se > 127 && (Q = Se));
                        break;
                    case 3:
                        Be = v[D + 1], ge = v[D + 2], (Be & 192) === 128 && (ge & 192) === 128 && (Se = ($ & 15) << 12 | (Be & 63) << 6 | ge & 63, Se > 2047 && (Se < 55296 || Se > 57343) && (Q = Se));
                        break;
                    case 4:
                        Be = v[D + 1], ge = v[D + 2], Te = v[D + 3], (Be & 192) === 128 && (ge & 192) === 128 && (Te & 192) === 128 && (Se = ($ & 15) << 18 | (Be & 63) << 12 | (ge & 63) << 6 | Te & 63, Se > 65535 && Se < 1114112 && (Q = Se))
                }
            }
            Q === null ? (Q = 65533, he = 1) : Q > 65535 && (Q -= 65536, S.push(Q >>> 10 & 1023 | 55296), Q = 56320 | Q & 1023), S.push(Q), D += he
        }
        return b(S)
    }
    const h = 4096;

    function b(v) {
        const u = v.length;
        if (u <= h) return String.fromCharCode.apply(String, v);
        let l = "",
            S = 0;
        for (; S < u;) l += String.fromCharCode.apply(String, v.slice(S, S += h));
        return l
    }

    function C(v, u, l) {
        let S = "";
        l = Math.min(v.length, l);
        for (let D = u; D < l; ++D) S += String.fromCharCode(v[D] & 127);
        return S
    }

    function _(v, u, l) {
        let S = "";
        l = Math.min(v.length, l);
        for (let D = u; D < l; ++D) S += String.fromCharCode(v[D]);
        return S
    }

    function M(v, u, l) {
        const S = v.length;
        (!u || u < 0) && (u = 0), (!l || l < 0 || l > S) && (l = S);
        let D = "";
        for (let $ = u; $ < l; ++$) D += Ze[v[$]];
        return D
    }

    function m(v, u, l) {
        const S = v.slice(u, l);
        let D = "";
        for (let $ = 0; $ < S.length - 1; $ += 2) D += String.fromCharCode(S[$] + S[$ + 1] * 256);
        return D
    }
    a.prototype.slice = function(u, l) {
        const S = this.length;
        u = ~~u, l = l === void 0 ? S : ~~l, u < 0 ? (u += S, u < 0 && (u = 0)) : u > S && (u = S), l < 0 ? (l += S, l < 0 && (l = 0)) : l > S && (l = S), l < u && (l = u);
        const D = this.subarray(u, l);
        return Object.setPrototypeOf(D, a.prototype), D
    };

    function A(v, u, l) {
        if (v % 1 !== 0 || v < 0) throw new RangeError("offset is not uint");
        if (v + u > l) throw new RangeError("Trying to access beyond buffer length")
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(u, l, S) {
        u = u >>> 0, l = l >>> 0, S || A(u, l, this.length);
        let D = this[u],
            $ = 1,
            Q = 0;
        for (; ++Q < l && ($ *= 256);) D += this[u + Q] * $;
        return D
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(u, l, S) {
        u = u >>> 0, l = l >>> 0, S || A(u, l, this.length);
        let D = this[u + --l],
            $ = 1;
        for (; l > 0 && ($ *= 256);) D += this[u + --l] * $;
        return D
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(u, l) {
        return u = u >>> 0, l || A(u, 1, this.length), this[u]
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(u, l) {
        return u = u >>> 0, l || A(u, 2, this.length), this[u] | this[u + 1] << 8
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(u, l) {
        return u = u >>> 0, l || A(u, 2, this.length), this[u] << 8 | this[u + 1]
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), (this[u] | this[u + 1] << 8 | this[u + 2] << 16) + this[u + 3] * 16777216
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), this[u] * 16777216 + (this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3])
    }, a.prototype.readBigUInt64LE = ft(function(u) {
        u = u >>> 0, We(u, "offset");
        const l = this[u],
            S = this[u + 7];
        (l === void 0 || S === void 0) && Ie(u, this.length - 8);
        const D = l + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24,
            $ = this[++u] + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + S * 2 ** 24;
        return BigInt(D) + (BigInt($) << BigInt(32))
    }), a.prototype.readBigUInt64BE = ft(function(u) {
        u = u >>> 0, We(u, "offset");
        const l = this[u],
            S = this[u + 7];
        (l === void 0 || S === void 0) && Ie(u, this.length - 8);
        const D = l * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u],
            $ = this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + S;
        return (BigInt(D) << BigInt(32)) + BigInt($)
    }), a.prototype.readIntLE = function(u, l, S) {
        u = u >>> 0, l = l >>> 0, S || A(u, l, this.length);
        let D = this[u],
            $ = 1,
            Q = 0;
        for (; ++Q < l && ($ *= 256);) D += this[u + Q] * $;
        return $ *= 128, D >= $ && (D -= Math.pow(2, 8 * l)), D
    }, a.prototype.readIntBE = function(u, l, S) {
        u = u >>> 0, l = l >>> 0, S || A(u, l, this.length);
        let D = l,
            $ = 1,
            Q = this[u + --D];
        for (; D > 0 && ($ *= 256);) Q += this[u + --D] * $;
        return $ *= 128, Q >= $ && (Q -= Math.pow(2, 8 * l)), Q
    }, a.prototype.readInt8 = function(u, l) {
        return u = u >>> 0, l || A(u, 1, this.length), this[u] & 128 ? (255 - this[u] + 1) * -1 : this[u]
    }, a.prototype.readInt16LE = function(u, l) {
        u = u >>> 0, l || A(u, 2, this.length);
        const S = this[u] | this[u + 1] << 8;
        return S & 32768 ? S | 4294901760 : S
    }, a.prototype.readInt16BE = function(u, l) {
        u = u >>> 0, l || A(u, 2, this.length);
        const S = this[u + 1] | this[u] << 8;
        return S & 32768 ? S | 4294901760 : S
    }, a.prototype.readInt32LE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), this[u] | this[u + 1] << 8 | this[u + 2] << 16 | this[u + 3] << 24
    }, a.prototype.readInt32BE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), this[u] << 24 | this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3]
    }, a.prototype.readBigInt64LE = ft(function(u) {
        u = u >>> 0, We(u, "offset");
        const l = this[u],
            S = this[u + 7];
        (l === void 0 || S === void 0) && Ie(u, this.length - 8);
        const D = this[u + 4] + this[u + 5] * 2 ** 8 + this[u + 6] * 2 ** 16 + (S << 24);
        return (BigInt(D) << BigInt(32)) + BigInt(l + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24)
    }), a.prototype.readBigInt64BE = ft(function(u) {
        u = u >>> 0, We(u, "offset");
        const l = this[u],
            S = this[u + 7];
        (l === void 0 || S === void 0) && Ie(u, this.length - 8);
        const D = (l << 24) + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u];
        return (BigInt(D) << BigInt(32)) + BigInt(this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + S)
    }), a.prototype.readFloatLE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), r.read(this, u, !0, 23, 4)
    }, a.prototype.readFloatBE = function(u, l) {
        return u = u >>> 0, l || A(u, 4, this.length), r.read(this, u, !1, 23, 4)
    }, a.prototype.readDoubleLE = function(u, l) {
        return u = u >>> 0, l || A(u, 8, this.length), r.read(this, u, !0, 52, 8)
    }, a.prototype.readDoubleBE = function(u, l) {
        return u = u >>> 0, l || A(u, 8, this.length), r.read(this, u, !1, 52, 8)
    };

    function x(v, u, l, S, D, $) {
        if (!a.isBuffer(v)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (u > D || u < $) throw new RangeError('"value" argument is out of bounds');
        if (l + S > v.length) throw new RangeError("Index out of range")
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(u, l, S, D) {
        if (u = +u, l = l >>> 0, S = S >>> 0, !D) {
            const he = Math.pow(2, 8 * S) - 1;
            x(this, u, l, S, he, 0)
        }
        let $ = 1,
            Q = 0;
        for (this[l] = u & 255; ++Q < S && ($ *= 256);) this[l + Q] = u / $ & 255;
        return l + S
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(u, l, S, D) {
        if (u = +u, l = l >>> 0, S = S >>> 0, !D) {
            const he = Math.pow(2, 8 * S) - 1;
            x(this, u, l, S, he, 0)
        }
        let $ = S - 1,
            Q = 1;
        for (this[l + $] = u & 255; --$ >= 0 && (Q *= 256);) this[l + $] = u / Q & 255;
        return l + S
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 1, 255, 0), this[l] = u & 255, l + 1
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 2, 65535, 0), this[l] = u & 255, this[l + 1] = u >>> 8, l + 2
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 2, 65535, 0), this[l] = u >>> 8, this[l + 1] = u & 255, l + 2
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 4, 4294967295, 0), this[l + 3] = u >>> 24, this[l + 2] = u >>> 16, this[l + 1] = u >>> 8, this[l] = u & 255, l + 4
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 4, 4294967295, 0), this[l] = u >>> 24, this[l + 1] = u >>> 16, this[l + 2] = u >>> 8, this[l + 3] = u & 255, l + 4
    };

    function z(v, u, l, S, D) {
        ve(u, S, D, v, l, 7);
        let $ = Number(u & BigInt(4294967295));
        v[l++] = $, $ = $ >> 8, v[l++] = $, $ = $ >> 8, v[l++] = $, $ = $ >> 8, v[l++] = $;
        let Q = Number(u >> BigInt(32) & BigInt(4294967295));
        return v[l++] = Q, Q = Q >> 8, v[l++] = Q, Q = Q >> 8, v[l++] = Q, Q = Q >> 8, v[l++] = Q, l
    }

    function oe(v, u, l, S, D) {
        ve(u, S, D, v, l, 7);
        let $ = Number(u & BigInt(4294967295));
        v[l + 7] = $, $ = $ >> 8, v[l + 6] = $, $ = $ >> 8, v[l + 5] = $, $ = $ >> 8, v[l + 4] = $;
        let Q = Number(u >> BigInt(32) & BigInt(4294967295));
        return v[l + 3] = Q, Q = Q >> 8, v[l + 2] = Q, Q = Q >> 8, v[l + 1] = Q, Q = Q >> 8, v[l] = Q, l + 8
    }
    a.prototype.writeBigUInt64LE = ft(function(u, l = 0) {
        return z(this, u, l, BigInt(0), BigInt("0xffffffffffffffff"))
    }), a.prototype.writeBigUInt64BE = ft(function(u, l = 0) {
        return oe(this, u, l, BigInt(0), BigInt("0xffffffffffffffff"))
    }), a.prototype.writeIntLE = function(u, l, S, D) {
        if (u = +u, l = l >>> 0, !D) {
            const Be = Math.pow(2, 8 * S - 1);
            x(this, u, l, S, Be - 1, -Be)
        }
        let $ = 0,
            Q = 1,
            he = 0;
        for (this[l] = u & 255; ++$ < S && (Q *= 256);) u < 0 && he === 0 && this[l + $ - 1] !== 0 && (he = 1), this[l + $] = (u / Q >> 0) - he & 255;
        return l + S
    }, a.prototype.writeIntBE = function(u, l, S, D) {
        if (u = +u, l = l >>> 0, !D) {
            const Be = Math.pow(2, 8 * S - 1);
            x(this, u, l, S, Be - 1, -Be)
        }
        let $ = S - 1,
            Q = 1,
            he = 0;
        for (this[l + $] = u & 255; --$ >= 0 && (Q *= 256);) u < 0 && he === 0 && this[l + $ + 1] !== 0 && (he = 1), this[l + $] = (u / Q >> 0) - he & 255;
        return l + S
    }, a.prototype.writeInt8 = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 1, 127, -128), u < 0 && (u = 255 + u + 1), this[l] = u & 255, l + 1
    }, a.prototype.writeInt16LE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 2, 32767, -32768), this[l] = u & 255, this[l + 1] = u >>> 8, l + 2
    }, a.prototype.writeInt16BE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 2, 32767, -32768), this[l] = u >>> 8, this[l + 1] = u & 255, l + 2
    }, a.prototype.writeInt32LE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 4, 2147483647, -2147483648), this[l] = u & 255, this[l + 1] = u >>> 8, this[l + 2] = u >>> 16, this[l + 3] = u >>> 24, l + 4
    }, a.prototype.writeInt32BE = function(u, l, S) {
        return u = +u, l = l >>> 0, S || x(this, u, l, 4, 2147483647, -2147483648), u < 0 && (u = 4294967295 + u + 1), this[l] = u >>> 24, this[l + 1] = u >>> 16, this[l + 2] = u >>> 8, this[l + 3] = u & 255, l + 4
    }, a.prototype.writeBigInt64LE = ft(function(u, l = 0) {
        return z(this, u, l, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }), a.prototype.writeBigInt64BE = ft(function(u, l = 0) {
        return oe(this, u, l, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });

    function k(v, u, l, S, D, $) {
        if (l + S > v.length) throw new RangeError("Index out of range");
        if (l < 0) throw new RangeError("Index out of range")
    }

    function X(v, u, l, S, D) {
        return u = +u, l = l >>> 0, D || k(v, u, l, 4), r.write(v, u, l, S, 23, 4), l + 4
    }
    a.prototype.writeFloatLE = function(u, l, S) {
        return X(this, u, l, !0, S)
    }, a.prototype.writeFloatBE = function(u, l, S) {
        return X(this, u, l, !1, S)
    };

    function re(v, u, l, S, D) {
        return u = +u, l = l >>> 0, D || k(v, u, l, 8), r.write(v, u, l, S, 52, 8), l + 8
    }
    a.prototype.writeDoubleLE = function(u, l, S) {
        return re(this, u, l, !0, S)
    }, a.prototype.writeDoubleBE = function(u, l, S) {
        return re(this, u, l, !1, S)
    }, a.prototype.copy = function(u, l, S, D) {
        if (!a.isBuffer(u)) throw new TypeError("argument should be a Buffer");
        if (S || (S = 0), !D && D !== 0 && (D = this.length), l >= u.length && (l = u.length), l || (l = 0), D > 0 && D < S && (D = S), D === S || u.length === 0 || this.length === 0) return 0;
        if (l < 0) throw new RangeError("targetStart out of bounds");
        if (S < 0 || S >= this.length) throw new RangeError("Index out of range");
        if (D < 0) throw new RangeError("sourceEnd out of bounds");
        D > this.length && (D = this.length), u.length - l < D - S && (D = u.length - l + S);
        const $ = D - S;
        return this === u && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(l, S, D) : Uint8Array.prototype.set.call(u, this.subarray(S, D), l), $
    }, a.prototype.fill = function(u, l, S, D) {
        if (typeof u == "string") {
            if (typeof l == "string" ? (D = l, l = 0, S = this.length) : typeof S == "string" && (D = S, S = this.length), D !== void 0 && typeof D != "string") throw new TypeError("encoding must be a string");
            if (typeof D == "string" && !a.isEncoding(D)) throw new TypeError("Unknown encoding: " + D);
            if (u.length === 1) {
                const Q = u.charCodeAt(0);
                (D === "utf8" && Q < 128 || D === "latin1") && (u = Q)
            }
        } else typeof u == "number" ? u = u & 255 : typeof u == "boolean" && (u = Number(u));
        if (l < 0 || this.length < l || this.length < S) throw new RangeError("Out of range index");
        if (S <= l) return this;
        l = l >>> 0, S = S === void 0 ? this.length : S >>> 0, u || (u = 0);
        let $;
        if (typeof u == "number")
            for ($ = l; $ < S; ++$) this[$] = u;
        else {
            const Q = a.isBuffer(u) ? u : a.from(u, D),
                he = Q.length;
            if (he === 0) throw new TypeError('The value "' + u + '" is invalid for argument "value"');
            for ($ = 0; $ < S - l; ++$) this[$ + l] = Q[$ % he]
        }
        return this
    };
    const ae = {};

    function le(v, u, l) {
        ae[v] = class extends l {
            constructor() {
                super(), Object.defineProperty(this, "message", {
                    value: u.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${v}]`, this.stack, delete this.name
            }
            get code() {
                return v
            }
            set code(D) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: D,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${v}]: ${this.message}`
            }
        }
    }
    le("ERR_BUFFER_OUT_OF_BOUNDS", function(v) {
        return v ? `${v} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError), le("ERR_INVALID_ARG_TYPE", function(v, u) {
        return `The "${v}" argument must be of type number. Received type ${typeof u}`
    }, TypeError), le("ERR_OUT_OF_RANGE", function(v, u, l) {
        let S = `The value of "${v}" is out of range.`,
            D = l;
        return Number.isInteger(l) && Math.abs(l) > 2 ** 32 ? D = Me(String(l)) : typeof l == "bigint" && (D = String(l), (l > BigInt(2) ** BigInt(32) || l < -(BigInt(2) ** BigInt(32))) && (D = Me(D)), D += "n"), S += ` It must be ${u}. Received ${D}`, S
    }, RangeError);

    function Me(v) {
        let u = "",
            l = v.length;
        const S = v[0] === "-" ? 1 : 0;
        for (; l >= S + 4; l -= 3) u = `_${v.slice(l-3,l)}${u}`;
        return `${v.slice(0,l)}${u}`
    }

    function Re(v, u, l) {
        We(u, "offset"), (v[u] === void 0 || v[u + l] === void 0) && Ie(u, v.length - (l + 1))
    }

    function ve(v, u, l, S, D, $) {
        if (v > l || v < u) {
            const Q = typeof u == "bigint" ? "n" : "";
            let he;
            throw $ > 3 ? u === 0 || u === BigInt(0) ? he = `>= 0${Q} and < 2${Q} ** ${($+1)*8}${Q}` : he = `>= -(2${Q} ** ${($+1)*8-1}${Q}) and < 2 ** ${($+1)*8-1}${Q}` : he = `>= ${u}${Q} and <= ${l}${Q}`, new ae.ERR_OUT_OF_RANGE("value", he, v)
        }
        Re(S, D, $)
    }

    function We(v, u) {
        if (typeof v != "number") throw new ae.ERR_INVALID_ARG_TYPE(u, "number", v)
    }

    function Ie(v, u, l) {
        throw Math.floor(v) !== v ? (We(v, l), new ae.ERR_OUT_OF_RANGE(l || "offset", "an integer", v)) : u < 0 ? new ae.ERR_BUFFER_OUT_OF_BOUNDS : new ae.ERR_OUT_OF_RANGE(l || "offset", `>= ${l?1:0} and <= ${u}`, v)
    }
    const Ue = /[^+/0-9A-Za-z-_]/g;

    function Ut(v) {
        if (v = v.split("=")[0], v = v.trim().replace(Ue, ""), v.length < 2) return "";
        for (; v.length % 4 !== 0;) v = v + "=";
        return v
    }

    function It(v, u) {
        u = u || 1 / 0;
        let l;
        const S = v.length;
        let D = null;
        const $ = [];
        for (let Q = 0; Q < S; ++Q) {
            if (l = v.charCodeAt(Q), l > 55295 && l < 57344) {
                if (!D) {
                    if (l > 56319) {
                        (u -= 3) > -1 && $.push(239, 191, 189);
                        continue
                    } else if (Q + 1 === S) {
                        (u -= 3) > -1 && $.push(239, 191, 189);
                        continue
                    }
                    D = l;
                    continue
                }
                if (l < 56320) {
                    (u -= 3) > -1 && $.push(239, 191, 189), D = l;
                    continue
                }
                l = (D - 55296 << 10 | l - 56320) + 65536
            } else D && (u -= 3) > -1 && $.push(239, 191, 189);
            if (D = null, l < 128) {
                if ((u -= 1) < 0) break;
                $.push(l)
            } else if (l < 2048) {
                if ((u -= 2) < 0) break;
                $.push(l >> 6 | 192, l & 63 | 128)
            } else if (l < 65536) {
                if ((u -= 3) < 0) break;
                $.push(l >> 12 | 224, l >> 6 & 63 | 128, l & 63 | 128)
            } else if (l < 1114112) {
                if ((u -= 4) < 0) break;
                $.push(l >> 18 | 240, l >> 12 & 63 | 128, l >> 6 & 63 | 128, l & 63 | 128)
            } else throw new Error("Invalid code point")
        }
        return $
    }

    function it(v) {
        const u = [];
        for (let l = 0; l < v.length; ++l) u.push(v.charCodeAt(l) & 255);
        return u
    }

    function At(v, u) {
        let l, S, D;
        const $ = [];
        for (let Q = 0; Q < v.length && !((u -= 2) < 0); ++Q) l = v.charCodeAt(Q), S = l >> 8, D = l % 256, $.push(D), $.push(S);
        return $
    }

    function Ct(v) {
        return e.toByteArray(Ut(v))
    }

    function Ye(v, u, l, S) {
        let D;
        for (D = 0; D < S && !(D + l >= u.length || D >= v.length); ++D) u[D + l] = v[D];
        return D
    }

    function Xe(v, u) {
        return v instanceof u || v != null && v.constructor != null && v.constructor.name != null && v.constructor.name === u.name
    }

    function St(v) {
        return v !== v
    }
    const Ze = function() {
        const v = "0123456789abcdef",
            u = new Array(256);
        for (let l = 0; l < 16; ++l) {
            const S = l * 16;
            for (let D = 0; D < 16; ++D) u[S + D] = v[l] + v[D]
        }
        return u
    }();

    function ft(v) {
        return typeof BigInt == "undefined" ? Ot : v
    }

    function Ot() {
        throw new Error("BigInt not supported")
    }
})(f1); /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t, e) {
    var r = f1,
        n = r.Buffer;

    function i(o, a) {
        for (var c in o) a[c] = o[c]
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (i(r, e), e.Buffer = s);

    function s(o, a, c) {
        return n(o, a, c)
    }
    s.prototype = Object.create(n.prototype), i(n, s), s.from = function(o, a, c) {
        if (typeof o == "number") throw new TypeError("Argument must not be a number");
        return n(o, a, c)
    }, s.alloc = function(o, a, c) {
        if (typeof o != "number") throw new TypeError("Argument must be a number");
        var d = n(o);
        return a !== void 0 ? typeof c == "string" ? d.fill(a, c) : d.fill(a) : d.fill(0), d
    }, s.allocUnsafe = function(o) {
        if (typeof o != "number") throw new TypeError("Argument must be a number");
        return n(o)
    }, s.allocUnsafeSlow = function(o) {
        if (typeof o != "number") throw new TypeError("Argument must be a number");
        return r.SlowBuffer(o)
    }
})(pl, pl.exports);
var sf = pl.exports.Buffer;

function oA(t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), r = 0; r < e.length; r++) e[r] = 255;
    for (var n = 0; n < t.length; n++) {
        var i = t.charAt(n),
            s = i.charCodeAt(0);
        if (e[s] !== 255) throw new TypeError(i + " is ambiguous");
        e[s] = n
    }
    var o = t.length,
        a = t.charAt(0),
        c = Math.log(o) / Math.log(256),
        d = Math.log(256) / Math.log(o);

    function y(E) {
        if ((Array.isArray(E) || E instanceof Uint8Array) && (E = sf.from(E)), !sf.isBuffer(E)) throw new TypeError("Expected Buffer");
        if (E.length === 0) return "";
        for (var T = 0, j = 0, V = 0, P = E.length; V !== P && E[V] === 0;) V++, T++;
        for (var O = (P - V) * d + 1 >>> 0, R = new Uint8Array(O); V !== P;) {
            for (var q = E[V], W = 0, Y = O - 1;
                (q !== 0 || W < j) && Y !== -1; Y--, W++) q += 256 * R[Y] >>> 0, R[Y] = q % o >>> 0, q = q / o >>> 0;
            if (q !== 0) throw new Error("Non-zero carry");
            j = W, V++
        }
        for (var G = O - j; G !== O && R[G] === 0;) G++;
        for (var J = a.repeat(T); G < O; ++G) J += t.charAt(R[G]);
        return J
    }

    function I(E) {
        if (typeof E != "string") throw new TypeError("Expected String");
        if (E.length === 0) return sf.alloc(0);
        for (var T = 0, j = 0, V = 0; E[T] === a;) j++, T++;
        for (var P = (E.length - T) * c + 1 >>> 0, O = new Uint8Array(P); E[T];) {
            var R = e[E.charCodeAt(T)];
            if (R === 255) return;
            for (var q = 0, W = P - 1;
                (R !== 0 || q < V) && W !== -1; W--, q++) R += o * O[W] >>> 0, O[W] = R % 256 >>> 0, R = R / 256 >>> 0;
            if (R !== 0) throw new Error("Non-zero carry");
            V = q, T++
        }
        for (var Y = P - V; Y !== P && O[Y] === 0;) Y++;
        var G = sf.allocUnsafe(j + (P - Y));
        G.fill(0, 0, j);
        for (var J = j; Y !== P;) G[J++] = O[Y++];
        return G
    }

    function N(E) {
        var T = I(E);
        if (T) return T;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: y,
        decodeUnsafe: I,
        decode: N
    }
}
var aA = oA,
    uA = aA,
    lA = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
    Ln = uA(lA),
    Yr = {},
    of = pl.exports.Buffer;

function fA(t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), r = 0; r < e.length; r++) e[r] = 255;
    for (var n = 0; n < t.length; n++) {
        var i = t.charAt(n),
            s = i.charCodeAt(0);
        if (e[s] !== 255) throw new TypeError(i + " is ambiguous");
        e[s] = n
    }
    var o = t.length,
        a = t.charAt(0),
        c = Math.log(o) / Math.log(256),
        d = Math.log(256) / Math.log(o);

    function y(E) {
        if ((Array.isArray(E) || E instanceof Uint8Array) && (E = of .from(E)), ! of .isBuffer(E)) throw new TypeError("Expected Buffer");
        if (E.length === 0) return "";
        for (var T = 0, j = 0, V = 0, P = E.length; V !== P && E[V] === 0;) V++, T++;
        for (var O = (P - V) * d + 1 >>> 0, R = new Uint8Array(O); V !== P;) {
            for (var q = E[V], W = 0, Y = O - 1;
                (q !== 0 || W < j) && Y !== -1; Y--, W++) q += 256 * R[Y] >>> 0, R[Y] = q % o >>> 0, q = q / o >>> 0;
            if (q !== 0) throw new Error("Non-zero carry");
            j = W, V++
        }
        for (var G = O - j; G !== O && R[G] === 0;) G++;
        for (var J = a.repeat(T); G < O; ++G) J += t.charAt(R[G]);
        return J
    }

    function I(E) {
        if (typeof E != "string") throw new TypeError("Expected String");
        if (E.length === 0) return of.alloc(0);
        for (var T = 0, j = 0, V = 0; E[T] === a;) j++, T++;
        for (var P = (E.length - T) * c + 1 >>> 0, O = new Uint8Array(P); E[T];) {
            var R = e[E.charCodeAt(T)];
            if (R === 255) return;
            for (var q = 0, W = P - 1;
                (R !== 0 || q < V) && W !== -1; W--, q++) R += o * O[W] >>> 0, O[W] = R % 256 >>> 0, R = R / 256 >>> 0;
            if (R !== 0) throw new Error("Non-zero carry");
            V = q, T++
        }
        for (var Y = P - V; Y !== P && O[Y] === 0;) Y++;
        var G = of .allocUnsafe(j + (P - Y));
        G.fill(0, 0, j);
        for (var J = j; Y !== P;) G[J++] = O[Y++];
        return G
    }

    function N(E) {
        var T = I(E);
        if (T) return T;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: y,
        decodeUnsafe: I,
        decode: N
    }
}
var cA = fA,
    hA = cA,
    dA = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
    pA = hA(dA);

function as(t, e, r) {
    return e <= t && t <= r
}

function Yc(t) {
    if (t === void 0) return {};
    if (t === Object(t)) return t;
    throw TypeError("Could not convert argument to dictionary")
}

function mA(t) {
    for (var e = String(t), r = e.length, n = 0, i = []; n < r;) {
        var s = e.charCodeAt(n);
        if (s < 55296 || s > 57343) i.push(s);
        else if (56320 <= s && s <= 57343) i.push(65533);
        else if (55296 <= s && s <= 56319)
            if (n === r - 1) i.push(65533);
            else {
                var o = t.charCodeAt(n + 1);
                if (56320 <= o && o <= 57343) {
                    var a = s & 1023,
                        c = o & 1023;
                    i.push(65536 + (a << 10) + c), n += 1
                } else i.push(65533)
            }
        n += 1
    }
    return i
}

function vA(t) {
    for (var e = "", r = 0; r < t.length; ++r) {
        var n = t[r];
        n <= 65535 ? e += String.fromCharCode(n) : (n -= 65536, e += String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320))
    }
    return e
}
var dc = -1;

function c1(t) {
    this.tokens = [].slice.call(t)
}
c1.prototype = {
    endOfStream: function() {
        return !this.tokens.length
    },
    read: function() {
        return this.tokens.length ? this.tokens.shift() : dc
    },
    prepend: function(t) {
        if (Array.isArray(t))
            for (var e = t; e.length;) this.tokens.unshift(e.pop());
        else this.tokens.unshift(t)
    },
    push: function(t) {
        if (Array.isArray(t))
            for (var e = t; e.length;) this.tokens.push(e.shift());
        else this.tokens.push(t)
    }
};
var Ea = -1;

function f0(t, e) {
    if (t) throw TypeError("Decoder error");
    return e || 65533
}
var pc = "utf-8";

function mc(t, e) {
    if (!(this instanceof mc)) return new mc(t, e);
    if (t = t !== void 0 ? String(t).toLowerCase() : pc, t !== pc) throw new Error("Encoding not supported. Only utf-8 is supported");
    e = Yc(e), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = Boolean(e.fatal), this._ignoreBOM = Boolean(e.ignoreBOM), Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }), Object.defineProperty(this, "fatal", {
        value: this._fatal
    }), Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    })
}
mc.prototype = {
    decode: function(e, r) {
        var n;
        typeof e == "object" && e instanceof ArrayBuffer ? n = new Uint8Array(e) : typeof e == "object" && "buffer" in e && e.buffer instanceof ArrayBuffer ? n = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : n = new Uint8Array(0), r = Yc(r), this._streaming || (this._decoder = new gA({
            fatal: this._fatal
        }), this._BOMseen = !1), this._streaming = Boolean(r.stream);
        for (var i = new c1(n), s = [], o; !i.endOfStream() && (o = this._decoder.handler(i, i.read()), o !== Ea);) o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o));
        if (!this._streaming) {
            do {
                if (o = this._decoder.handler(i, i.read()), o === Ea) break;
                o !== null && (Array.isArray(o) ? s.push.apply(s, o) : s.push(o))
            } while (!i.endOfStream());
            this._decoder = null
        }
        return s.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (s[0] === 65279 ? (this._BOMseen = !0, s.shift()) : this._BOMseen = !0), vA(s)
    }
};

function vc(t, e) {
    if (!(this instanceof vc)) return new vc(t, e);
    if (t = t !== void 0 ? String(t).toLowerCase() : pc, t !== pc) throw new Error("Encoding not supported. Only utf-8 is supported");
    e = Yc(e), this._streaming = !1, this._encoder = null, this._options = {
        fatal: Boolean(e.fatal)
    }, Object.defineProperty(this, "encoding", {
        value: "utf-8"
    })
}
vc.prototype = {
    encode: function(e, r) {
        e = e ? String(e) : "", r = Yc(r), this._streaming || (this._encoder = new yA(this._options)), this._streaming = Boolean(r.stream);
        for (var n = [], i = new c1(mA(e)), s; !i.endOfStream() && (s = this._encoder.handler(i, i.read()), s !== Ea);) Array.isArray(s) ? n.push.apply(n, s) : n.push(s);
        if (!this._streaming) {
            for (; s = this._encoder.handler(i, i.read()), s !== Ea;) Array.isArray(s) ? n.push.apply(n, s) : n.push(s);
            this._encoder = null
        }
        return new Uint8Array(n)
    }
};

function gA(t) {
    var e = t.fatal,
        r = 0,
        n = 0,
        i = 0,
        s = 128,
        o = 191;
    this.handler = function(a, c) {
        if (c === dc && i !== 0) return i = 0, f0(e);
        if (c === dc) return Ea;
        if (i === 0) {
            if (as(c, 0, 127)) return c;
            if (as(c, 194, 223)) i = 1, r = c - 192;
            else if (as(c, 224, 239)) c === 224 && (s = 160), c === 237 && (o = 159), i = 2, r = c - 224;
            else if (as(c, 240, 244)) c === 240 && (s = 144), c === 244 && (o = 143), i = 3, r = c - 240;
            else return f0(e);
            return r = r << 6 * i, null
        }
        if (!as(c, s, o)) return r = i = n = 0, s = 128, o = 191, a.prepend(c), f0(e);
        if (s = 128, o = 191, n += 1, r += c - 128 << 6 * (i - n), n !== i) return null;
        var d = r;
        return r = i = n = 0, d
    }
}

function yA(t) {
    t.fatal, this.handler = function(e, r) {
        if (r === dc) return Ea;
        if (as(r, 0, 127)) return r;
        var n, i;
        as(r, 128, 2047) ? (n = 1, i = 192) : as(r, 2048, 65535) ? (n = 2, i = 224) : as(r, 65536, 1114111) && (n = 3, i = 240);
        for (var s = [(r >> 6 * n) + i]; n > 0;) {
            var o = r >> 6 * (n - 1);
            s.push(128 | o & 63), n -= 1
        }
        return s
    }
}
var wA = Object.freeze(Object.defineProperty({
        __proto__: null,
        TextEncoder: vc,
        TextDecoder: mc
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    xA = mp(wA),
    bA = zn && zn.__createBinding || (Object.create ? function(t, e, r, n) {
        n === void 0 && (n = r), Object.defineProperty(t, n, {
            enumerable: !0,
            get: function() {
                return e[r]
            }
        })
    } : function(t, e, r, n) {
        n === void 0 && (n = r), t[n] = e[r]
    }),
    AA = zn && zn.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
            enumerable: !0,
            value: e
        })
    } : function(t, e) {
        t.default = e
    }),
    Zi = zn && zn.__decorate || function(t, e, r, n) {
        var i = arguments.length,
            s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n,
            o;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, n);
        else
            for (var a = t.length - 1; a >= 0; a--)(o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, r, s) : o(e, r)) || s);
        return i > 3 && s && Object.defineProperty(e, r, s), s
    },
    SA = zn && zn.__importStar || function(t) {
        if (t && t.__esModule) return t;
        var e = {};
        if (t != null)
            for (var r in t) r !== "default" && Object.hasOwnProperty.call(t, r) && bA(e, t, r);
        return AA(e, t), e
    },
    r2 = zn && zn.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    };
Object.defineProperty(Yr, "__esModule", {
    value: !0
});
var n2 = Yr.deserializeUnchecked = l2 = Yr.deserialize = u2 = Yr.serialize = Yr.BinaryReader = Yr.BinaryWriter = Yr.BorshError = Yr.baseDecode = Yr.baseEncode = void 0;
const js = r2(l1.exports),
    i2 = r2(pA),
    MA = SA(xA),
    EA = typeof TextDecoder != "function" ? MA.TextDecoder : TextDecoder,
    _A = new EA("utf-8", {
        fatal: !0
    });

function IA(t) {
    return typeof t == "string" && (t = Buffer.from(t, "utf8")), i2.default.encode(Buffer.from(t))
}
Yr.baseEncode = IA;

function CA(t) {
    return Buffer.from(i2.default.decode(t))
}
Yr.baseDecode = CA;
const c0 = 1024;
class gn extends Error {
    constructor(e) {
        super(e), this.fieldPath = [], this.originalMessage = e
    }
    addToFieldPath(e) {
        this.fieldPath.splice(0, 0, e), this.message = this.originalMessage + ": " + this.fieldPath.join(".")
    }
}
Yr.BorshError = gn;
class s2 {
    constructor() {
        this.buf = Buffer.alloc(c0), this.length = 0
    }
    maybeResize() {
        this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(c0)]))
    }
    writeU8(e) {
        this.maybeResize(), this.buf.writeUInt8(e, this.length), this.length += 1
    }
    writeU16(e) {
        this.maybeResize(), this.buf.writeUInt16LE(e, this.length), this.length += 2
    }
    writeU32(e) {
        this.maybeResize(), this.buf.writeUInt32LE(e, this.length), this.length += 4
    }
    writeU64(e) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new js.default(e).toArray("le", 8)))
    }
    writeU128(e) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new js.default(e).toArray("le", 16)))
    }
    writeU256(e) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new js.default(e).toArray("le", 32)))
    }
    writeU512(e) {
        this.maybeResize(), this.writeBuffer(Buffer.from(new js.default(e).toArray("le", 64)))
    }
    writeBuffer(e) {
        this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), e, Buffer.alloc(c0)]), this.length += e.length
    }
    writeString(e) {
        this.maybeResize();
        const r = Buffer.from(e, "utf8");
        this.writeU32(r.length), this.writeBuffer(r)
    }
    writeFixedArray(e) {
        this.writeBuffer(Buffer.from(e))
    }
    writeArray(e, r) {
        this.maybeResize(), this.writeU32(e.length);
        for (const n of e) this.maybeResize(), r(n)
    }
    toArray() {
        return this.buf.subarray(0, this.length)
    }
}
Yr.BinaryWriter = s2;

function Ji(t, e, r) {
    const n = r.value;
    r.value = function(...i) {
        try {
            return n.apply(this, i)
        } catch (s) {
            if (s instanceof RangeError) {
                const o = s.code;
                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(o) >= 0) throw new gn("Reached the end of buffer when deserializing")
            }
            throw s
        }
    }
}
class Qn {
    constructor(e) {
        this.buf = e, this.offset = 0
    }
    readU8() {
        const e = this.buf.readUInt8(this.offset);
        return this.offset += 1, e
    }
    readU16() {
        const e = this.buf.readUInt16LE(this.offset);
        return this.offset += 2, e
    }
    readU32() {
        const e = this.buf.readUInt32LE(this.offset);
        return this.offset += 4, e
    }
    readU64() {
        const e = this.readBuffer(8);
        return new js.default(e, "le")
    }
    readU128() {
        const e = this.readBuffer(16);
        return new js.default(e, "le")
    }
    readU256() {
        const e = this.readBuffer(32);
        return new js.default(e, "le")
    }
    readU512() {
        const e = this.readBuffer(64);
        return new js.default(e, "le")
    }
    readBuffer(e) {
        if (this.offset + e > this.buf.length) throw new gn(`Expected buffer length ${e} isn't within bounds`);
        const r = this.buf.slice(this.offset, this.offset + e);
        return this.offset += e, r
    }
    readString() {
        const e = this.readU32(),
            r = this.readBuffer(e);
        try {
            return _A.decode(r)
        } catch (n) {
            throw new gn(`Error decoding UTF-8 string: ${n}`)
        }
    }
    readFixedArray(e) {
        return new Uint8Array(this.readBuffer(e))
    }
    readArray(e) {
        const r = this.readU32(),
            n = Array();
        for (let i = 0; i < r; ++i) n.push(e());
        return n
    }
}
Zi([Ji], Qn.prototype, "readU8", null);
Zi([Ji], Qn.prototype, "readU16", null);
Zi([Ji], Qn.prototype, "readU32", null);
Zi([Ji], Qn.prototype, "readU64", null);
Zi([Ji], Qn.prototype, "readU128", null);
Zi([Ji], Qn.prototype, "readU256", null);
Zi([Ji], Qn.prototype, "readU512", null);
Zi([Ji], Qn.prototype, "readString", null);
Zi([Ji], Qn.prototype, "readFixedArray", null);
Zi([Ji], Qn.prototype, "readArray", null);
Yr.BinaryReader = Qn;

function o2(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
}

function vo(t, e, r, n, i) {
    try {
        if (typeof n == "string") i[`write${o2(n)}`](r);
        else if (n instanceof Array)
            if (typeof n[0] == "number") {
                if (r.length !== n[0]) throw new gn(`Expecting byte array of length ${n[0]}, but got ${r.length} bytes`);
                i.writeFixedArray(r)
            } else if (n.length === 2 && typeof n[1] == "number") {
            if (r.length !== n[1]) throw new gn(`Expecting byte array of length ${n[1]}, but got ${r.length} bytes`);
            for (let s = 0; s < n[1]; s++) vo(t, null, r[s], n[0], i)
        } else i.writeArray(r, s => {
            vo(t, e, s, n[0], i)
        });
        else if (n.kind !== void 0) switch (n.kind) {
            case "option":
                {
                    r == null ? i.writeU8(0) : (i.writeU8(1), vo(t, e, r, n.type, i));
                    break
                }
            case "map":
                {
                    i.writeU32(r.size),
                    r.forEach((s, o) => {
                        vo(t, e, o, n.key, i), vo(t, e, s, n.value, i)
                    });
                    break
                }
            default:
                throw new gn(`FieldType ${n} unrecognized`)
        } else a2(t, r, i)
    } catch (s) {
        throw s instanceof gn && s.addToFieldPath(e), s
    }
}

function a2(t, e, r) {
    if (typeof e.borshSerialize == "function") {
        e.borshSerialize(r);
        return
    }
    const n = t.get(e.constructor);
    if (!n) throw new gn(`Class ${e.constructor.name} is missing in schema`);
    if (n.kind === "struct") n.fields.map(([i, s]) => {
        vo(t, i, e[i], s, r)
    });
    else if (n.kind === "enum") {
        const i = e[n.field];
        for (let s = 0; s < n.values.length; ++s) {
            const [o, a] = n.values[s];
            if (o === i) {
                r.writeU8(s), vo(t, o, e[o], a, r);
                break
            }
        }
    } else throw new gn(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)
}

function BA(t, e, r = s2) {
    const n = new r;
    return a2(t, e, n), n.toArray()
}
var u2 = Yr.serialize = BA;

function go(t, e, r, n) {
    try {
        if (typeof r == "string") return n[`read${o2(r)}`]();
        if (r instanceof Array) {
            if (typeof r[0] == "number") return n.readFixedArray(r[0]);
            if (typeof r[1] == "number") {
                const i = [];
                for (let s = 0; s < r[1]; s++) i.push(go(t, null, r[0], n));
                return i
            } else return n.readArray(() => go(t, e, r[0], n))
        }
        if (r.kind === "option") return n.readU8() ? go(t, e, r.type, n) : void 0;
        if (r.kind === "map") {
            let i = new Map;
            const s = n.readU32();
            for (let o = 0; o < s; o++) {
                const a = go(t, e, r.key, n),
                    c = go(t, e, r.value, n);
                i.set(a, c)
            }
            return i
        }
        return h1(t, r, n)
    } catch (i) {
        throw i instanceof gn && i.addToFieldPath(e), i
    }
}

function h1(t, e, r) {
    if (typeof e.borshDeserialize == "function") return e.borshDeserialize(r);
    const n = t.get(e);
    if (!n) throw new gn(`Class ${e.name} is missing in schema`);
    if (n.kind === "struct") {
        const i = {};
        for (const [s, o] of t.get(e).fields) i[s] = go(t, s, o, r);
        return new e(i)
    }
    if (n.kind === "enum") {
        const i = r.readU8();
        if (i >= n.values.length) throw new gn(`Enum index: ${i} is out of range`);
        const [s, o] = n.values[i], a = go(t, s, o, r);
        return new e({
            [s]: a
        })
    }
    throw new gn(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)
}

function kA(t, e, r, n = Qn) {
    const i = new n(r),
        s = h1(t, e, i);
    if (i.offset < r.length) throw new gn(`Unexpected ${r.length-i.offset} bytes after deserialized data`);
    return s
}
var l2 = Yr.deserialize = kA;

function NA(t, e, r, n = Qn) {
    const i = new n(r);
    return h1(t, e, i)
}
n2 = Yr.deserializeUnchecked = NA;
var ne = {};
Object.defineProperty(ne, "__esModule", {
    value: !0
});
ne.s16 = ne.s8 = ne.nu64be = ne.u48be = ne.u40be = ne.u32be = ne.u24be = ne.u16be = hn = ne.nu64 = ne.u48 = ne.u40 = yt = ne.u32 = ne.u24 = Kn = ne.u16 = Rr = ne.u8 = Vu = ne.offset = ne.greedy = ne.Constant = ne.UTF8 = ne.CString = ne.Blob = ne.Boolean = ne.BitField = ne.BitStructure = ne.VariantLayout = ne.Union = ne.UnionLayoutDiscriminator = ne.UnionDiscriminator = ne.Structure = ne.Sequence = ne.DoubleBE = ne.Double = ne.FloatBE = ne.Float = ne.NearInt64BE = ne.NearInt64 = ne.NearUInt64BE = ne.NearUInt64 = ne.IntBE = ne.Int = ne.UIntBE = ne.UInt = ne.OffsetLayout = ne.GreedyCount = ne.ExternalLayout = ne.bindConstructorLayout = ne.nameWithProperty = ne.Layout = ne.uint8ArrayToBuffer = ne.checkUint8Array = void 0;
ne.constant = ne.utf8 = ne.cstr = Xn = ne.blob = ne.unionLayoutDiscriminator = ne.union = $s = ne.seq = ne.bits = pt = ne.struct = ne.f64be = ne.f64 = ne.f32be = ne.f32 = ne.ns64be = ne.s48be = ne.s40be = ne.s32be = ne.s24be = ne.s16be = Pn = ne.ns64 = ne.s48 = ne.s40 = ne.s32 = ne.s24 = void 0;
const d1 = f1;

function Ha(t) {
    if (!(t instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array")
}
ne.checkUint8Array = Ha;

function Kt(t) {
    return Ha(t), d1.Buffer.from(t.buffer, t.byteOffset, t.length)
}
ne.uint8ArrayToBuffer = Kt;
class or {
    constructor(e, r) {
        if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
        this.span = e, this.property = r
    }
    makeDestinationObject() {
        return {}
    }
    getSpan(e, r) {
        if (0 > this.span) throw new RangeError("indeterminate span");
        return this.span
    }
    replicate(e) {
        const r = Object.create(this.constructor.prototype);
        return Object.assign(r, this), r.property = e, r
    }
    fromArray(e) {}
}
ne.Layout = or;

function p1(t, e) {
    return e.property ? t + "[" + e.property + "]" : t
}
ne.nameWithProperty = p1;

function TA(t, e) {
    if (typeof t != "function") throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(t, "layout_")) throw new Error("Class is already bound to a layout");
    if (!(e && e instanceof or)) throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call(e, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
    t.layout_ = e, e.boundConstructor_ = t, e.makeDestinationObject = () => new t, Object.defineProperty(t.prototype, "encode", {
        value(r, n) {
            return e.encode(this, r, n)
        },
        writable: !0
    }), Object.defineProperty(t, "decode", {
        value(r, n) {
            return e.decode(r, n)
        },
        writable: !0
    })
}
ne.bindConstructorLayout = TA;
class Mn extends or {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
}
ne.ExternalLayout = Mn;
class f2 extends Mn {
    constructor(e = 1, r) {
        if (!Number.isInteger(e) || 0 >= e) throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, r), this.elementSpan = e
    }
    isCount() {
        return !0
    }
    decode(e, r = 0) {
        Ha(e);
        const n = e.length - r;
        return Math.floor(n / this.elementSpan)
    }
    encode(e, r, n) {
        return 0
    }
}
ne.GreedyCount = f2;
class m1 extends Mn {
    constructor(e, r = 0, n) {
        if (!(e instanceof or)) throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(r)) throw new TypeError("offset must be integer or undefined");
        super(e.span, n || e.property), this.layout = e, this.offset = r
    }
    isCount() {
        return this.layout instanceof si || this.layout instanceof Ei
    }
    decode(e, r = 0) {
        return this.layout.decode(e, r + this.offset)
    }
    encode(e, r, n = 0) {
        return this.layout.encode(e, r, n + this.offset)
    }
}
ne.OffsetLayout = m1;
class si extends or {
    constructor(e, r) {
        if (super(e, r), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, r = 0) {
        return Kt(e).readUIntLE(r, this.span)
    }
    encode(e, r, n = 0) {
        return Kt(r).writeUIntLE(e, n, this.span), this.span
    }
}
ne.UInt = si;
class Ei extends or {
    constructor(e, r) {
        if (super(e, r), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, r = 0) {
        return Kt(e).readUIntBE(r, this.span)
    }
    encode(e, r, n = 0) {
        return Kt(r).writeUIntBE(e, n, this.span), this.span
    }
}
ne.UIntBE = Ei;
class Po extends or {
    constructor(e, r) {
        if (super(e, r), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, r = 0) {
        return Kt(e).readIntLE(r, this.span)
    }
    encode(e, r, n = 0) {
        return Kt(r).writeIntLE(e, n, this.span), this.span
    }
}
ne.Int = Po;
class Qa extends or {
    constructor(e, r) {
        if (super(e, r), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
    }
    decode(e, r = 0) {
        return Kt(e).readIntBE(r, this.span)
    }
    encode(e, r, n = 0) {
        return Kt(r).writeIntBE(e, n, this.span), this.span
    }
}
ne.IntBE = Qa;
const zd = Math.pow(2, 32);

function Kc(t) {
    const e = Math.floor(t / zd),
        r = t - e * zd;
    return {
        hi32: e,
        lo32: r
    }
}

function Zc(t, e) {
    return t * zd + e
}
class c2 extends or {
    constructor(e) {
        super(8, e)
    }
    decode(e, r = 0) {
        const n = Kt(e),
            i = n.readUInt32LE(r),
            s = n.readUInt32LE(r + 4);
        return Zc(s, i)
    }
    encode(e, r, n = 0) {
        const i = Kc(e),
            s = Kt(r);
        return s.writeUInt32LE(i.lo32, n), s.writeUInt32LE(i.hi32, n + 4), 8
    }
}
ne.NearUInt64 = c2;
class h2 extends or {
    constructor(e) {
        super(8, e)
    }
    decode(e, r = 0) {
        const n = Kt(e),
            i = n.readUInt32BE(r),
            s = n.readUInt32BE(r + 4);
        return Zc(i, s)
    }
    encode(e, r, n = 0) {
        const i = Kc(e),
            s = Kt(r);
        return s.writeUInt32BE(i.hi32, n), s.writeUInt32BE(i.lo32, n + 4), 8
    }
}
ne.NearUInt64BE = h2;
class d2 extends or {
    constructor(e) {
        super(8, e)
    }
    decode(e, r = 0) {
        const n = Kt(e),
            i = n.readUInt32LE(r),
            s = n.readInt32LE(r + 4);
        return Zc(s, i)
    }
    encode(e, r, n = 0) {
        const i = Kc(e),
            s = Kt(r);
        return s.writeUInt32LE(i.lo32, n), s.writeInt32LE(i.hi32, n + 4), 8
    }
}
ne.NearInt64 = d2;
class p2 extends or {
    constructor(e) {
        super(8, e)
    }
    decode(e, r = 0) {
        const n = Kt(e),
            i = n.readInt32BE(r),
            s = n.readUInt32BE(r + 4);
        return Zc(i, s)
    }
    encode(e, r, n = 0) {
        const i = Kc(e),
            s = Kt(r);
        return s.writeInt32BE(i.hi32, n), s.writeUInt32BE(i.lo32, n + 4), 8
    }
}
ne.NearInt64BE = p2;
class m2 extends or {
    constructor(e) {
        super(4, e)
    }
    decode(e, r = 0) {
        return Kt(e).readFloatLE(r)
    }
    encode(e, r, n = 0) {
        return Kt(r).writeFloatLE(e, n), 4
    }
}
ne.Float = m2;
class v2 extends or {
    constructor(e) {
        super(4, e)
    }
    decode(e, r = 0) {
        return Kt(e).readFloatBE(r)
    }
    encode(e, r, n = 0) {
        return Kt(r).writeFloatBE(e, n), 4
    }
}
ne.FloatBE = v2;
class g2 extends or {
    constructor(e) {
        super(8, e)
    }
    decode(e, r = 0) {
        return Kt(e).readDoubleLE(r)
    }
    encode(e, r, n = 0) {
        return Kt(r).writeDoubleLE(e, n), 8
    }
}
ne.Double = g2;
class y2 extends or {
    constructor(e) {
        super(8, e)
    }
    decode(e, r = 0) {
        return Kt(e).readDoubleBE(r)
    }
    encode(e, r, n = 0) {
        return Kt(r).writeDoubleBE(e, n), 8
    }
}
ne.DoubleBE = y2;
class w2 extends or {
    constructor(e, r, n) {
        if (!(e instanceof or)) throw new TypeError("elementLayout must be a Layout");
        if (!(r instanceof Mn && r.isCount() || Number.isInteger(r) && 0 <= r)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let i = -1;
        !(r instanceof Mn) && 0 < e.span && (i = r * e.span), super(i, n), this.elementLayout = e, this.count = r
    }
    getSpan(e, r = 0) {
        if (0 <= this.span) return this.span;
        let n = 0,
            i = this.count;
        if (i instanceof Mn && (i = i.decode(e, r)), 0 < this.elementLayout.span) n = i * this.elementLayout.span;
        else {
            let s = 0;
            for (; s < i;) n += this.elementLayout.getSpan(e, r + n), ++s
        }
        return n
    }
    decode(e, r = 0) {
        const n = [];
        let i = 0,
            s = this.count;
        for (s instanceof Mn && (s = s.decode(e, r)); i < s;) n.push(this.elementLayout.decode(e, r)), r += this.elementLayout.getSpan(e, r), i += 1;
        return n
    }
    encode(e, r, n = 0) {
        const i = this.elementLayout,
            s = e.reduce((o, a) => o + i.encode(a, r, n + o), 0);
        return this.count instanceof Mn && this.count.encode(e.length, r, n), s
    }
}
ne.Sequence = w2;
class x2 extends or {
    constructor(e, r, n) {
        if (!(Array.isArray(e) && e.reduce((s, o) => s && o instanceof or, !0))) throw new TypeError("fields must be array of Layout instances");
        typeof r == "boolean" && n === void 0 && (n = r, r = void 0);
        for (const s of e)
            if (0 > s.span && s.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
        let i = -1;
        try {
            i = e.reduce((s, o) => s + o.getSpan(), 0)
        } catch {}
        super(i, r), this.fields = e, this.decodePrefixes = !!n
    }
    getSpan(e, r = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        try {
            n = this.fields.reduce((i, s) => {
                const o = s.getSpan(e, r);
                return r += o, i + o
            }, 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return n
    }
    decode(e, r = 0) {
        Ha(e);
        const n = this.makeDestinationObject();
        for (const i of this.fields)
            if (i.property !== void 0 && (n[i.property] = i.decode(e, r)), r += i.getSpan(e, r), this.decodePrefixes && e.length === r) break;
        return n
    }
    encode(e, r, n = 0) {
        const i = n;
        let s = 0,
            o = 0;
        for (const a of this.fields) {
            let c = a.span;
            if (o = 0 < c ? c : 0, a.property !== void 0) {
                const d = e[a.property];
                d !== void 0 && (o = a.encode(d, r, n), 0 > c && (c = a.getSpan(r, n)))
            }
            s = n, n += c
        }
        return s + o - i
    }
    fromArray(e) {
        const r = this.makeDestinationObject();
        for (const n of this.fields) n.property !== void 0 && 0 < e.length && (r[n.property] = e.shift());
        return r
    }
    layoutFor(e) {
        if (typeof e != "string") throw new TypeError("property must be string");
        for (const r of this.fields)
            if (r.property === e) return r
    }
    offsetOf(e) {
        if (typeof e != "string") throw new TypeError("property must be string");
        let r = 0;
        for (const n of this.fields) {
            if (n.property === e) return r;
            0 > n.span ? r = -1 : 0 <= r && (r += n.span)
        }
    }
}
ne.Structure = x2;
class v1 {
    constructor(e) {
        this.property = e
    }
    decode(e, r) {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode(e, r, n) {
        throw new Error("UnionDiscriminator is abstract")
    }
}
ne.UnionDiscriminator = v1;
class gc extends v1 {
    constructor(e, r) {
        if (!(e instanceof Mn && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(r || e.property || "variant"), this.layout = e
    }
    decode(e, r) {
        return this.layout.decode(e, r)
    }
    encode(e, r, n) {
        return this.layout.encode(e, r, n)
    }
}
ne.UnionLayoutDiscriminator = gc;
class g1 extends or {
    constructor(e, r, n) {
        let i;
        if (e instanceof si || e instanceof Ei) i = new gc(new m1(e));
        else if (e instanceof Mn && e.isCount()) i = new gc(e);
        else if (e instanceof v1) i = e;
        else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (r === void 0 && (r = null), !(r === null || r instanceof or)) throw new TypeError("defaultLayout must be null or a Layout");
        if (r !== null) {
            if (0 > r.span) throw new Error("defaultLayout must have constant span");
            r.property === void 0 && (r = r.replicate("content"))
        }
        let s = -1;
        r && (s = r.span, 0 <= s && (e instanceof si || e instanceof Ei) && (s += i.layout.span)), super(s, n), this.discriminator = i, this.usesPrefixDiscriminator = e instanceof si || e instanceof Ei, this.defaultLayout = r, this.registry = {};
        let o = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(a) {
            return o(a)
        }, this.configGetSourceVariant = function(a) {
            o = a.bind(this)
        }
    }
    getSpan(e, r = 0) {
        if (0 <= this.span) return this.span;
        const n = this.getVariant(e, r);
        if (!n) throw new Error("unable to determine span for unrecognized variant");
        return n.getSpan(e, r)
    }
    defaultGetSourceVariant(e) {
        if (Object.prototype.hasOwnProperty.call(e, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property)) return;
            const r = this.registry[e[this.discriminator.property]];
            if (r && (!r.layout || r.property && Object.prototype.hasOwnProperty.call(e, r.property))) return r
        } else
            for (const r in this.registry) {
                const n = this.registry[r];
                if (n.property && Object.prototype.hasOwnProperty.call(e, n.property)) return n
            }
        throw new Error("unable to infer src variant")
    }
    decode(e, r = 0) {
        let n;
        const i = this.discriminator,
            s = i.decode(e, r),
            o = this.registry[s];
        if (o === void 0) {
            const a = this.defaultLayout;
            let c = 0;
            this.usesPrefixDiscriminator && (c = i.layout.span), n = this.makeDestinationObject(), n[i.property] = s, n[a.property] = a.decode(e, r + c)
        } else n = o.decode(e, r);
        return n
    }
    encode(e, r, n = 0) {
        const i = this.getSourceVariant(e);
        if (i === void 0) {
            const s = this.discriminator,
                o = this.defaultLayout;
            let a = 0;
            return this.usesPrefixDiscriminator && (a = s.layout.span), s.encode(e[s.property], r, n), a + o.encode(e[o.property], r, n + a)
        }
        return i.encode(e, r, n)
    }
    addVariant(e, r, n) {
        const i = new b2(this, e, r, n);
        return this.registry[e] = i, i
    }
    getVariant(e, r = 0) {
        let n;
        return e instanceof Uint8Array ? n = this.discriminator.decode(e, r) : n = e, this.registry[n]
    }
}
ne.Union = g1;
class b2 extends or {
    constructor(e, r, n, i) {
        if (!(e instanceof g1)) throw new TypeError("union must be a Union");
        if (!Number.isInteger(r) || 0 > r) throw new TypeError("variant must be a (non-negative) integer");
        if (typeof n == "string" && i === void 0 && (i = n, n = null), n) {
            if (!(n instanceof or)) throw new TypeError("layout must be a Layout");
            if (e.defaultLayout !== null && 0 <= n.span && n.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
            if (typeof i != "string") throw new TypeError("variant must have a String property")
        }
        let s = e.span;
        0 > e.span && (s = n ? n.span : 0, 0 <= s && e.usesPrefixDiscriminator && (s += e.discriminator.layout.span)), super(s, i), this.union = e, this.variant = r, this.layout = n || null
    }
    getSpan(e, r = 0) {
        if (0 <= this.span) return this.span;
        let n = 0;
        this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span);
        let i = 0;
        return this.layout && (i = this.layout.getSpan(e, r + n)), n + i
    }
    decode(e, r = 0) {
        const n = this.makeDestinationObject();
        if (this !== this.union.getVariant(e, r)) throw new Error("variant mismatch");
        let i = 0;
        return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(e, r + i) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n
    }
    encode(e, r, n = 0) {
        let i = 0;
        if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(e, this.property)) throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, r, n);
        let s = i;
        if (this.layout && (this.layout.encode(e[this.property], r, n + i), s += this.layout.getSpan(r, n + i), 0 <= this.union.span && s > this.union.span)) throw new Error("encoded variant overruns containing union");
        return s
    }
    fromArray(e) {
        if (this.layout) return this.layout.fromArray(e)
    }
}
ne.VariantLayout = b2;

function Yo(t) {
    return 0 > t && (t += 4294967296), t
}
class y1 extends or {
    constructor(e, r, n) {
        if (!(e instanceof si || e instanceof Ei)) throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof r == "string" && n === void 0 && (n = r, r = !1), 4 < e.span) throw new RangeError("word cannot exceed 32 bits");
        super(e.span, n), this.word = e, this.msb = !!r, this.fields = [];
        let i = 0;
        this._packedSetValue = function(s) {
            return i = Yo(s), this
        }, this._packedGetValue = function() {
            return i
        }
    }
    decode(e, r = 0) {
        const n = this.makeDestinationObject(),
            i = this.word.decode(e, r);
        this._packedSetValue(i);
        for (const s of this.fields) s.property !== void 0 && (n[s.property] = s.decode(e));
        return n
    }
    encode(e, r, n = 0) {
        const i = this.word.decode(r, n);
        this._packedSetValue(i);
        for (const s of this.fields)
            if (s.property !== void 0) {
                const o = e[s.property];
                o !== void 0 && s.encode(o)
            }
        return this.word.encode(this._packedGetValue(), r, n)
    }
    addField(e, r) {
        const n = new w1(this, e, r);
        return this.fields.push(n), n
    }
    addBoolean(e) {
        const r = new A2(this, e);
        return this.fields.push(r), r
    }
    fieldFor(e) {
        if (typeof e != "string") throw new TypeError("property must be string");
        for (const r of this.fields)
            if (r.property === e) return r
    }
}
ne.BitStructure = y1;
class w1 {
    constructor(e, r, n) {
        if (!(e instanceof y1)) throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(r) || 0 >= r) throw new TypeError("bits must be positive integer");
        const i = 8 * e.span,
            s = e.fields.reduce((o, a) => o + a.bits, 0);
        if (r + s > i) throw new Error("bits too long for span remainder (" + (i - s) + " of " + i + " remain)");
        this.container = e, this.bits = r, this.valueMask = (1 << r) - 1, r === 32 && (this.valueMask = 4294967295), this.start = s, this.container.msb && (this.start = i - s - r), this.wordMask = Yo(this.valueMask << this.start), this.property = n
    }
    decode(e, r) {
        const n = this.container._packedGetValue();
        return Yo(n & this.wordMask) >>> this.start
    }
    encode(e) {
        if (typeof e != "number" || !Number.isInteger(e) || e !== Yo(e & this.valueMask)) throw new TypeError(p1("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const r = this.container._packedGetValue(),
            n = Yo(e << this.start);
        this.container._packedSetValue(Yo(r & ~this.wordMask) | n)
    }
}
ne.BitField = w1;
class A2 extends w1 {
    constructor(e, r) {
        super(e, 1, r)
    }
    decode(e, r) {
        return !!super.decode(e, r)
    }
    encode(e) {
        typeof e == "boolean" && (e = +e), super.encode(e)
    }
}
ne.Boolean = A2;
class S2 extends or {
    constructor(e, r) {
        if (!(e instanceof Mn && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let n = -1;
        e instanceof Mn || (n = e), super(n, r), this.length = e
    }
    getSpan(e, r) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(e, r)), n
    }
    decode(e, r = 0) {
        let n = this.span;
        return 0 > n && (n = this.length.decode(e, r)), Kt(e).slice(r, r + n)
    }
    encode(e, r, n) {
        let i = this.length;
        if (this.length instanceof Mn && (i = e.length), !(e instanceof Uint8Array && i === e.length)) throw new TypeError(p1("Blob.encode", this) + " requires (length " + i + ") Uint8Array as src");
        if (n + i > r.length) throw new RangeError("encoding overruns Uint8Array");
        const s = Kt(e);
        return Kt(r).write(s.toString("hex"), n, i, "hex"), this.length instanceof Mn && this.length.encode(i, r, n), i
    }
}
ne.Blob = S2;
class M2 extends or {
    constructor(e) {
        super(-1, e)
    }
    getSpan(e, r = 0) {
        Ha(e);
        let n = r;
        for (; n < e.length && e[n] !== 0;) n += 1;
        return 1 + n - r
    }
    decode(e, r = 0) {
        const n = this.getSpan(e, r);
        return Kt(e).slice(r, r + n - 1).toString("utf-8")
    }
    encode(e, r, n = 0) {
        typeof e != "string" && (e = String(e));
        const i = d1.Buffer.from(e, "utf8"),
            s = i.length;
        if (n + s > r.length) throw new RangeError("encoding overruns Buffer");
        const o = Kt(r);
        return i.copy(o, n), o[n + s] = 0, s + 1
    }
}
ne.CString = M2;
class E2 extends or {
    constructor(e, r) {
        if (typeof e == "string" && r === void 0 && (r = e, e = void 0), e === void 0) e = -1;
        else if (!Number.isInteger(e)) throw new TypeError("maxSpan must be an integer");
        super(-1, r), this.maxSpan = e
    }
    getSpan(e, r = 0) {
        return Ha(e), e.length - r
    }
    decode(e, r = 0) {
        const n = this.getSpan(e, r);
        if (0 <= this.maxSpan && this.maxSpan < n) throw new RangeError("text length exceeds maxSpan");
        return Kt(e).slice(r, r + n).toString("utf-8")
    }
    encode(e, r, n = 0) {
        typeof e != "string" && (e = String(e));
        const i = d1.Buffer.from(e, "utf8"),
            s = i.length;
        if (0 <= this.maxSpan && this.maxSpan < s) throw new RangeError("text length exceeds maxSpan");
        if (n + s > r.length) throw new RangeError("encoding overruns Buffer");
        return i.copy(Kt(r), n), s
    }
}
ne.UTF8 = E2;
class _2 extends or {
    constructor(e, r) {
        super(0, r), this.value = e
    }
    decode(e, r) {
        return this.value
    }
    encode(e, r, n) {
        return 0
    }
}
ne.Constant = _2;
ne.greedy = (t, e) => new f2(t, e);
var Vu = ne.offset = (t, e, r) => new m1(t, e, r),
    Rr = ne.u8 = t => new si(1, t),
    Kn = ne.u16 = t => new si(2, t);
ne.u24 = t => new si(3, t);
var yt = ne.u32 = t => new si(4, t);
ne.u40 = t => new si(5, t);
ne.u48 = t => new si(6, t);
var hn = ne.nu64 = t => new c2(t);
ne.u16be = t => new Ei(2, t);
ne.u24be = t => new Ei(3, t);
ne.u32be = t => new Ei(4, t);
ne.u40be = t => new Ei(5, t);
ne.u48be = t => new Ei(6, t);
ne.nu64be = t => new h2(t);
ne.s8 = t => new Po(1, t);
ne.s16 = t => new Po(2, t);
ne.s24 = t => new Po(3, t);
ne.s32 = t => new Po(4, t);
ne.s40 = t => new Po(5, t);
ne.s48 = t => new Po(6, t);
var Pn = ne.ns64 = t => new d2(t);
ne.s16be = t => new Qa(2, t);
ne.s24be = t => new Qa(3, t);
ne.s32be = t => new Qa(4, t);
ne.s40be = t => new Qa(5, t);
ne.s48be = t => new Qa(6, t);
ne.ns64be = t => new p2(t);
ne.f32 = t => new m2(t);
ne.f32be = t => new v2(t);
ne.f64 = t => new g2(t);
ne.f64be = t => new y2(t);
var pt = ne.struct = (t, e, r) => new x2(t, e, r);
ne.bits = (t, e, r) => new y1(t, e, r);
var $s = ne.seq = (t, e, r) => new w2(t, e, r);
ne.union = (t, e, r) => new g1(t, e, r);
ne.unionLayoutDiscriminator = (t, e) => new gc(t, e);
var Xn = ne.blob = (t, e) => new S2(t, e);
ne.cstr = t => new M2(t);
ne.utf8 = (t, e) => new E2(t, e);
ne.constant = (t, e) => new _2(t, e);
var Sl = {};
Object.defineProperty(Sl, "__esModule", {
    value: !0
});

function OA(t) {
    {
        const e = Buffer.from(t);
        e.reverse();
        const r = e.toString("hex");
        return r.length === 0 ? BigInt(0) : BigInt(`0x${r}`)
    }
}
var RA = Sl.toBigIntLE = OA;

function DA(t) {
    {
        const e = t.toString("hex");
        return e.length === 0 ? BigInt(0) : BigInt(`0x${e}`)
    }
}
Sl.toBigIntBE = DA;

function PA(t, e) {
    {
        const r = t.toString(16),
            n = Buffer.from(r.padStart(e * 2, "0").slice(0, e * 2), "hex");
        return n.reverse(), n
    }
}
var LA = Sl.toBufferLE = PA;

function FA(t, e) {
    {
        const r = t.toString(16);
        return Buffer.from(r.padStart(e * 2, "0").slice(0, e * 2), "hex")
    }
}
Sl.toBufferBE = FA;
class UA extends TypeError {
    constructor(e, r) {
        let n;
        const c = e,
            {
                message: i
            } = c,
            s = Wn(c, ["message"]),
            {
                path: o
            } = e,
            a = o.length === 0 ? i : "At path: " + o.join(".") + " -- " + i;
        super(a), Object.assign(this, s), this.name = this.constructor.name, this.failures = () => {
            var d;
            return (d = n) != null ? d : n = [e, ...r()]
        }
    }
}

function zA(t) {
    return Js(t) && typeof t[Symbol.iterator] == "function"
}

function Js(t) {
    return typeof t == "object" && t != null
}

function Ii(t) {
    return typeof t == "string" ? JSON.stringify(t) : "" + t
}

function jA(t) {
    const {
        done: e,
        value: r
    } = t.next();
    return e ? void 0 : r
}

function $A(t, e, r, n) {
    if (t === !0) return;
    t === !1 ? t = {} : typeof t == "string" && (t = {
        message: t
    });
    const {
        path: i,
        branch: s
    } = e, {
        type: o
    } = r, {
        refinement: a,
        message: c = "Expected a value of type `" + o + "`" + (a ? " with refinement `" + a + "`" : "") + ", but received: `" + Ii(n) + "`"
    } = t;
    return xt(Ce({
        value: n,
        type: o,
        refinement: a,
        key: i[i.length - 1],
        path: i,
        branch: s
    }, t), {
        message: c
    })
}

function* vv(t, e, r, n) {
    zA(t) || (t = [t]);
    for (const i of t) {
        const s = $A(i, e, r, n);
        s && (yield s)
    }
}

function* x1(t, e, r = {}) {
    const {
        path: n = [],
        branch: i = [t],
        coerce: s = !1,
        mask: o = !1
    } = r, a = {
        path: n,
        branch: i
    };
    if (s && (t = e.coercer(t, a), o && e.type !== "type" && Js(e.schema) && Js(t) && !Array.isArray(t)))
        for (const d in t) e.schema[d] === void 0 && delete t[d];
    let c = !0;
    for (const d of e.validator(t, a)) c = !1, yield [d, void 0];
    for (let [d, y, I] of e.entries(t, a)) {
        const N = x1(y, I, {
            path: d === void 0 ? n : [...n, d],
            branch: d === void 0 ? i : [...i, y],
            coerce: s,
            mask: o
        });
        for (const E of N) E[0] ? (c = !1, yield [E[0], void 0]) : s && (y = E[1], d === void 0 ? t = y : t instanceof Map ? t.set(d, y) : t instanceof Set ? t.add(y) : Js(t) && (t[d] = y))
    }
    if (c)
        for (const d of e.refiner(t, a)) c = !1, yield [d, void 0];
    c && (yield [void 0, t])
}
class Xi {
    constructor(e) {
        const {
            type: r,
            schema: n,
            validator: i,
            refiner: s,
            coercer: o = c => c,
            entries: a = function*() {}
        } = e;
        this.type = r, this.schema = n, this.entries = a, this.coercer = o, i ? this.validator = (c, d) => {
            const y = i(c, d);
            return vv(y, d, this, c)
        } : this.validator = () => [], s ? this.refiner = (c, d) => {
            const y = s(c, d);
            return vv(y, d, this, c)
        } : this.refiner = () => []
    }
    assert(e) {
        return HA(e, this)
    }
    create(e) {
        return je(e, this)
    }
    is(e) {
        return I2(e, this)
    }
    mask(e) {
        return QA(e, this)
    }
    validate(e, r = {}) {
        return Ml(e, this, r)
    }
}

function HA(t, e) {
    const r = Ml(t, e);
    if (r[0]) throw r[0]
}

function je(t, e) {
    const r = Ml(t, e, {
        coerce: !0
    });
    if (r[0]) throw r[0];
    return r[1]
}

function QA(t, e) {
    const r = Ml(t, e, {
        coerce: !0,
        mask: !0
    });
    if (r[0]) throw r[0];
    return r[1]
}

function I2(t, e) {
    return !Ml(t, e)[0]
}

function Ml(t, e, r = {}) {
    const n = x1(t, e, r),
        i = jA(n);
    if (i[0]) return [new UA(i[0], function*() {
        for (const o of n) o[0] && (yield o[0])
    }), void 0]; {
        const s = i[1];
        return [void 0, s]
    }
}

function Lo(t, e) {
    return new Xi({
        type: t,
        schema: null,
        validator: e
    })
}

function qA() {
    return Lo("any", () => !0)
}

function nt(t) {
    return new Xi({
        type: "array",
        schema: t,
        * entries(e) {
            if (t && Array.isArray(e))
                for (const [r, n] of e.entries()) yield [r, n, t]
        },
        coercer(e) {
            return Array.isArray(e) ? e.slice() : e
        },
        validator(e) {
            return Array.isArray(e) || "Expected an array value, but received: " + Ii(e)
        }
    })
}

function gs() {
    return Lo("boolean", t => typeof t == "boolean")
}

function b1(t) {
    return Lo("instance", e => e instanceof t || "Expected a `" + t.name + "` instance, but received: " + Ii(e))
}

function jr(t) {
    const e = Ii(t),
        r = typeof t;
    return new Xi({
        type: "literal",
        schema: r === "string" || r === "number" || r === "boolean" ? t : null,
        validator(n) {
            return n === t || "Expected the literal `" + e + "`, but received: " + Ii(n)
        }
    })
}

function WA() {
    return Lo("never", () => !1)
}

function lt(t) {
    return new Xi(xt(Ce({}, t), {
        validator: (e, r) => e === null || t.validator(e, r),
        refiner: (e, r) => e === null || t.refiner(e, r)
    }))
}

function ue() {
    return Lo("number", t => typeof t == "number" && !isNaN(t) || "Expected a number, but received: " + Ii(t))
}

function ar(t) {
    return new Xi(xt(Ce({}, t), {
        validator: (e, r) => e === void 0 || t.validator(e, r),
        refiner: (e, r) => e === void 0 || t.refiner(e, r)
    }))
}

function C2(t, e) {
    return new Xi({
        type: "record",
        schema: null,
        * entries(r) {
            if (Js(r))
                for (const n in r) {
                    const i = r[n];
                    yield [n, n, t], yield [n, i, e]
                }
        },
        validator(r) {
            return Js(r) || "Expected an object, but received: " + Ii(r)
        }
    })
}

function Fe() {
    return Lo("string", t => typeof t == "string" || "Expected a string, but received: " + Ii(t))
}

function B2(t) {
    const e = WA();
    return new Xi({
        type: "tuple",
        schema: null,
        * entries(r) {
            if (Array.isArray(r)) {
                const n = Math.max(t.length, r.length);
                for (let i = 0; i < n; i++) yield [i, r[i], t[i] || e]
            }
        },
        validator(r) {
            return Array.isArray(r) || "Expected an array, but received: " + Ii(r)
        }
    })
}

function Ee(t) {
    const e = Object.keys(t);
    return new Xi({
        type: "type",
        schema: t,
        * entries(r) {
            if (Js(r))
                for (const n of e) yield [n, r[n], t[n]]
        },
        validator(r) {
            return Js(r) || "Expected an object, but received: " + Ii(r)
        }
    })
}

function ui(t) {
    const e = t.map(r => r.type).join(" | ");
    return new Xi({
        type: "union",
        schema: null,
        validator(r, n) {
            const i = [];
            for (const s of t) {
                const [...o] = x1(r, s, n), [a] = o;
                if (a[0])
                    for (const [c] of o) c && i.push(c);
                else return []
            }
            return ["Expected the value to satisfy a union of `" + e + "`, but received: " + Ii(r), ...i]
        }
    })
}

function El() {
    return Lo("unknown", () => !0)
}

function _l(t, e, r) {
    return new Xi(xt(Ce({}, t), {
        coercer: (n, i) => I2(n, e) ? t.coercer(r(n, i), i) : t.coercer(n, i)
    }))
}
var A1 = {},
    Jc = {
        exports: {}
    };
(function(t) {
    function e(r) {
        return r && r.__esModule ? r : {
            default: r
        }
    }
    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
})(Jc);
var Xc = {
    exports: {}
};
(function(t) {
    function e(n, i) {
        for (var s = 0; s < i.length; s++) {
            var o = i[s];
            o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(n, o.key, o)
        }
    }

    function r(n, i, s) {
        return i && e(n.prototype, i), s && e(n, s), Object.defineProperty(n, "prototype", {
            writable: !1
        }), n
    }
    t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports
})(Xc);
var eh = {
    exports: {}
};
(function(t) {
    function e(r, n) {
        if (!(r instanceof n)) throw new TypeError("Cannot call a class as a function")
    }
    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
})(eh);
var th = {
        exports: {}
    },
    k2 = {
        exports: {}
    };
(function(t) {
    function e(r, n) {
        return t.exports = e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(s, o) {
            return s.__proto__ = o, s
        }, t.exports.__esModule = !0, t.exports.default = t.exports, e(r, n)
    }
    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
})(k2);
(function(t) {
    var e = k2.exports;

    function r(n, i) {
        if (typeof i != "function" && i !== null) throw new TypeError("Super expression must either be null or a function");
        n.prototype = Object.create(i && i.prototype, {
            constructor: {
                value: n,
                writable: !0,
                configurable: !0
            }
        }), Object.defineProperty(n, "prototype", {
            writable: !1
        }), i && e(n, i)
    }
    t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports
})(th);
var rh = {
        exports: {}
    },
    nh = {
        exports: {}
    };
(function(t) {
    function e(r) {
        return t.exports = e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
            return typeof n
        } : function(n) {
            return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
        }, t.exports.__esModule = !0, t.exports.default = t.exports, e(r)
    }
    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
})(nh);
var N2 = {
    exports: {}
};
(function(t) {
    function e(r) {
        if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return r
    }
    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
})(N2);
(function(t) {
    var e = nh.exports.default,
        r = N2.exports;

    function n(i, s) {
        if (s && (e(s) === "object" || typeof s == "function")) return s;
        if (s !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
        return r(i)
    }
    t.exports = n, t.exports.__esModule = !0, t.exports.default = t.exports
})(rh);
var ih = {
    exports: {}
};
(function(t) {
    function e(r) {
        return t.exports = e = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(i) {
            return i.__proto__ || Object.getPrototypeOf(i)
        }, t.exports.__esModule = !0, t.exports.default = t.exports, e(r)
    }
    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports
})(ih);
var T2 = {},
    sh = {
        exports: {}
    };
(function(t) {
    var e = Object.prototype.hasOwnProperty,
        r = "~";

    function n() {}
    Object.create && (n.prototype = Object.create(null), new n().__proto__ || (r = !1));

    function i(c, d, y) {
        this.fn = c, this.context = d, this.once = y || !1
    }

    function s(c, d, y, I, N) {
        if (typeof y != "function") throw new TypeError("The listener must be a function");
        var E = new i(y, I || c, N),
            T = r ? r + d : d;
        return c._events[T] ? c._events[T].fn ? c._events[T] = [c._events[T], E] : c._events[T].push(E) : (c._events[T] = E, c._eventsCount++), c
    }

    function o(c, d) {
        --c._eventsCount === 0 ? c._events = new n : delete c._events[d]
    }

    function a() {
        this._events = new n, this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var d = [],
            y, I;
        if (this._eventsCount === 0) return d;
        for (I in y = this._events) e.call(y, I) && d.push(r ? I.slice(1) : I);
        return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(y)) : d
    }, a.prototype.listeners = function(d) {
        var y = r ? r + d : d,
            I = this._events[y];
        if (!I) return [];
        if (I.fn) return [I.fn];
        for (var N = 0, E = I.length, T = new Array(E); N < E; N++) T[N] = I[N].fn;
        return T
    }, a.prototype.listenerCount = function(d) {
        var y = r ? r + d : d,
            I = this._events[y];
        return I ? I.fn ? 1 : I.length : 0
    }, a.prototype.emit = function(d, y, I, N, E, T) {
        var j = r ? r + d : d;
        if (!this._events[j]) return !1;
        var V = this._events[j],
            P = arguments.length,
            O, R;
        if (V.fn) {
            switch (V.once && this.removeListener(d, V.fn, void 0, !0), P) {
                case 1:
                    return V.fn.call(V.context), !0;
                case 2:
                    return V.fn.call(V.context, y), !0;
                case 3:
                    return V.fn.call(V.context, y, I), !0;
                case 4:
                    return V.fn.call(V.context, y, I, N), !0;
                case 5:
                    return V.fn.call(V.context, y, I, N, E), !0;
                case 6:
                    return V.fn.call(V.context, y, I, N, E, T), !0
            }
            for (R = 1, O = new Array(P - 1); R < P; R++) O[R - 1] = arguments[R];
            V.fn.apply(V.context, O)
        } else {
            var q = V.length,
                W;
            for (R = 0; R < q; R++) switch (V[R].once && this.removeListener(d, V[R].fn, void 0, !0), P) {
                case 1:
                    V[R].fn.call(V[R].context);
                    break;
                case 2:
                    V[R].fn.call(V[R].context, y);
                    break;
                case 3:
                    V[R].fn.call(V[R].context, y, I);
                    break;
                case 4:
                    V[R].fn.call(V[R].context, y, I, N);
                    break;
                default:
                    if (!O)
                        for (W = 1, O = new Array(P - 1); W < P; W++) O[W - 1] = arguments[W];
                    V[R].fn.apply(V[R].context, O)
            }
        }
        return !0
    }, a.prototype.on = function(d, y, I) {
        return s(this, d, y, I, !1)
    }, a.prototype.once = function(d, y, I) {
        return s(this, d, y, I, !0)
    }, a.prototype.removeListener = function(d, y, I, N) {
        var E = r ? r + d : d;
        if (!this._events[E]) return this;
        if (!y) return o(this, E), this;
        var T = this._events[E];
        if (T.fn) T.fn === y && (!N || T.once) && (!I || T.context === I) && o(this, E);
        else {
            for (var j = 0, V = [], P = T.length; j < P; j++)(T[j].fn !== y || N && !T[j].once || I && T[j].context !== I) && V.push(T[j]);
            V.length ? this._events[E] = V.length === 1 ? V[0] : V : o(this, E)
        }
        return this
    }, a.prototype.removeAllListeners = function(d) {
        var y;
        return d ? (y = r ? r + d : d, this._events[y] && o(this, y)) : (this._events = new n, this._eventsCount = 0), this
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a
})(sh);
var VA = sh.exports;
(function(t) {
    var e = Jc.exports;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.default = I;
    var r = e(eh.exports),
        n = e(Xc.exports),
        i = e(th.exports),
        s = e(rh.exports),
        o = e(ih.exports),
        a = sh.exports;

    function c(N) {
        var E = d();
        return function() {
            var j = (0, o.default)(N),
                V;
            if (E) {
                var P = (0, o.default)(this).constructor;
                V = Reflect.construct(j, arguments, P)
            } else V = j.apply(this, arguments);
            return (0, s.default)(this, V)
        }
    }

    function d() {
        if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
        } catch {
            return !1
        }
    }
    var y = function(N) {
        (0, i.default)(T, N);
        var E = c(T);

        function T(j, V, P) {
            var O;
            return (0, r.default)(this, T), O = E.call(this), O.socket = new window.WebSocket(j, P), O.socket.onopen = function() {
                return O.emit("open")
            }, O.socket.onmessage = function(R) {
                return O.emit("message", R.data)
            }, O.socket.onerror = function(R) {
                return O.emit("error", R)
            }, O.socket.onclose = function(R) {
                O.emit("close", R.code, R.reason)
            }, O
        }
        return (0, n.default)(T, [{
            key: "send",
            value: function(V, P, O) {
                var R = O || P;
                try {
                    this.socket.send(V), R()
                } catch (q) {
                    R(q)
                }
            }
        }, {
            key: "close",
            value: function(V, P) {
                this.socket.close(V, P)
            }
        }, {
            key: "addEventListener",
            value: function(V, P, O) {
                this.socket.addEventListener(V, P, O)
            }
        }]), T
    }(a.EventEmitter);

    function I(N, E) {
        return new y(N, E)
    }
})(T2);
var O2 = {},
    R2 = {
        exports: {}
    };
(function(t) {
    var e = nh.exports.default;

    function r() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
        t.exports = r = function() {
            return n
        }, t.exports.__esModule = !0, t.exports.default = t.exports;
        var n = {},
            i = Object.prototype,
            s = i.hasOwnProperty,
            o = typeof Symbol == "function" ? Symbol : {},
            a = o.iterator || "@@iterator",
            c = o.asyncIterator || "@@asyncIterator",
            d = o.toStringTag || "@@toStringTag";

        function y(p, f, h) {
            return Object.defineProperty(p, f, {
                value: h,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }), p[f]
        }
        try {
            y({}, "")
        } catch {
            y = function(h, b, C) {
                return h[b] = C
            }
        }

        function I(p, f, h, b) {
            var C = f && f.prototype instanceof T ? f : T,
                _ = Object.create(C.prototype),
                M = new we(b || []);
            return _._invoke = function(m, A, x) {
                var z = "suspendedStart";
                return function(oe, k) {
                    if (z === "executing") throw new Error("Generator is already running");
                    if (z === "completed") {
                        if (oe === "throw") throw k;
                        return w()
                    }
                    for (x.method = oe, x.arg = k;;) {
                        var X = x.delegate;
                        if (X) {
                            var re = G(X, x);
                            if (re) {
                                if (re === E) continue;
                                return re
                            }
                        }
                        if (x.method === "next") x.sent = x._sent = x.arg;
                        else if (x.method === "throw") {
                            if (z === "suspendedStart") throw z = "completed", x.arg;
                            x.dispatchException(x.arg)
                        } else x.method === "return" && x.abrupt("return", x.arg);
                        z = "executing";
                        var ae = N(m, A, x);
                        if (ae.type === "normal") {
                            if (z = x.done ? "completed" : "suspendedYield", ae.arg === E) continue;
                            return {
                                value: ae.arg,
                                done: x.done
                            }
                        }
                        ae.type === "throw" && (z = "completed", x.method = "throw", x.arg = ae.arg)
                    }
                }
            }(p, h, M), _
        }

        function N(p, f, h) {
            try {
                return {
                    type: "normal",
                    arg: p.call(f, h)
                }
            } catch (b) {
                return {
                    type: "throw",
                    arg: b
                }
            }
        }
        n.wrap = I;
        var E = {};

        function T() {}

        function j() {}

        function V() {}
        var P = {};
        y(P, a, function() {
            return this
        });
        var O = Object.getPrototypeOf,
            R = O && O(O(H([])));
        R && R !== i && s.call(R, a) && (P = R);
        var q = V.prototype = T.prototype = Object.create(P);

        function W(p) {
            ["next", "throw", "return"].forEach(function(f) {
                y(p, f, function(h) {
                    return this._invoke(f, h)
                })
            })
        }

        function Y(p, f) {
            function h(C, _, M, m) {
                var A = N(p[C], p, _);
                if (A.type !== "throw") {
                    var x = A.arg,
                        z = x.value;
                    return z && e(z) == "object" && s.call(z, "__await") ? f.resolve(z.__await).then(function(oe) {
                        h("next", oe, M, m)
                    }, function(oe) {
                        h("throw", oe, M, m)
                    }) : f.resolve(z).then(function(oe) {
                        x.value = oe, M(x)
                    }, function(oe) {
                        return h("throw", oe, M, m)
                    })
                }
                m(A.arg)
            }
            var b;
            this._invoke = function(C, _) {
                function M() {
                    return new f(function(m, A) {
                        h(C, _, m, A)
                    })
                }
                return b = b ? b.then(M, M) : M()
            }
        }

        function G(p, f) {
            var h = p.iterator[f.method];
            if (h === void 0) {
                if (f.delegate = null, f.method === "throw") {
                    if (p.iterator.return && (f.method = "return", f.arg = void 0, G(p, f), f.method === "throw")) return E;
                    f.method = "throw", f.arg = new TypeError("The iterator does not provide a 'throw' method")
                }
                return E
            }
            var b = N(h, p.iterator, f.arg);
            if (b.type === "throw") return f.method = "throw", f.arg = b.arg, f.delegate = null, E;
            var C = b.arg;
            return C ? C.done ? (f[p.resultName] = C.value, f.next = p.nextLoc, f.method !== "return" && (f.method = "next", f.arg = void 0), f.delegate = null, E) : C : (f.method = "throw", f.arg = new TypeError("iterator result is not an object"), f.delegate = null, E)
        }

        function J(p) {
            var f = {
                tryLoc: p[0]
            };
            1 in p && (f.catchLoc = p[1]), 2 in p && (f.finallyLoc = p[2], f.afterLoc = p[3]), this.tryEntries.push(f)
        }

        function pe(p) {
            var f = p.completion || {};
            f.type = "normal", delete f.arg, p.completion = f
        }

        function we(p) {
            this.tryEntries = [{
                tryLoc: "root"
            }], p.forEach(J, this), this.reset(!0)
        }

        function H(p) {
            if (p) {
                var f = p[a];
                if (f) return f.call(p);
                if (typeof p.next == "function") return p;
                if (!isNaN(p.length)) {
                    var h = -1,
                        b = function C() {
                            for (; ++h < p.length;)
                                if (s.call(p, h)) return C.value = p[h], C.done = !1, C;
                            return C.value = void 0, C.done = !0, C
                        };
                    return b.next = b
                }
            }
            return {
                next: w
            }
        }

        function w() {
            return {
                value: void 0,
                done: !0
            }
        }
        return j.prototype = V, y(q, "constructor", V), y(V, "constructor", j), j.displayName = y(V, d, "GeneratorFunction"), n.isGeneratorFunction = function(p) {
            var f = typeof p == "function" && p.constructor;
            return !!f && (f === j || (f.displayName || f.name) === "GeneratorFunction")
        }, n.mark = function(p) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(p, V) : (p.__proto__ = V, y(p, d, "GeneratorFunction")), p.prototype = Object.create(q), p
        }, n.awrap = function(p) {
            return {
                __await: p
            }
        }, W(Y.prototype), y(Y.prototype, c, function() {
            return this
        }), n.AsyncIterator = Y, n.async = function(p, f, h, b, C) {
            C === void 0 && (C = Promise);
            var _ = new Y(I(p, f, h, b), C);
            return n.isGeneratorFunction(f) ? _ : _.next().then(function(M) {
                return M.done ? M.value : _.next()
            })
        }, W(q), y(q, d, "Generator"), y(q, a, function() {
            return this
        }), y(q, "toString", function() {
            return "[object Generator]"
        }), n.keys = function(p) {
            var f = [];
            for (var h in p) f.push(h);
            return f.reverse(),
                function b() {
                    for (; f.length;) {
                        var C = f.pop();
                        if (C in p) return b.value = C, b.done = !1, b
                    }
                    return b.done = !0, b
                }
        }, n.values = H, we.prototype = {
            constructor: we,
            reset: function(f) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(pe), !f)
                    for (var h in this) h.charAt(0) === "t" && s.call(this, h) && !isNaN(+h.slice(1)) && (this[h] = void 0)
            },
            stop: function() {
                this.done = !0;
                var f = this.tryEntries[0].completion;
                if (f.type === "throw") throw f.arg;
                return this.rval
            },
            dispatchException: function(f) {
                if (this.done) throw f;
                var h = this;

                function b(x, z) {
                    return M.type = "throw", M.arg = f, h.next = x, z && (h.method = "next", h.arg = void 0), !!z
                }
                for (var C = this.tryEntries.length - 1; C >= 0; --C) {
                    var _ = this.tryEntries[C],
                        M = _.completion;
                    if (_.tryLoc === "root") return b("end");
                    if (_.tryLoc <= this.prev) {
                        var m = s.call(_, "catchLoc"),
                            A = s.call(_, "finallyLoc");
                        if (m && A) {
                            if (this.prev < _.catchLoc) return b(_.catchLoc, !0);
                            if (this.prev < _.finallyLoc) return b(_.finallyLoc)
                        } else if (m) {
                            if (this.prev < _.catchLoc) return b(_.catchLoc, !0)
                        } else {
                            if (!A) throw new Error("try statement without catch or finally");
                            if (this.prev < _.finallyLoc) return b(_.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function(f, h) {
                for (var b = this.tryEntries.length - 1; b >= 0; --b) {
                    var C = this.tryEntries[b];
                    if (C.tryLoc <= this.prev && s.call(C, "finallyLoc") && this.prev < C.finallyLoc) {
                        var _ = C;
                        break
                    }
                }
                _ && (f === "break" || f === "continue") && _.tryLoc <= h && h <= _.finallyLoc && (_ = null);
                var M = _ ? _.completion : {};
                return M.type = f, M.arg = h, _ ? (this.method = "next", this.next = _.finallyLoc, E) : this.complete(M)
            },
            complete: function(f, h) {
                if (f.type === "throw") throw f.arg;
                return f.type === "break" || f.type === "continue" ? this.next = f.arg : f.type === "return" ? (this.rval = this.arg = f.arg, this.method = "return", this.next = "end") : f.type === "normal" && h && (this.next = h), E
            },
            finish: function(f) {
                for (var h = this.tryEntries.length - 1; h >= 0; --h) {
                    var b = this.tryEntries[h];
                    if (b.finallyLoc === f) return this.complete(b.completion, b.afterLoc), pe(b), E
                }
            },
            catch: function(f) {
                for (var h = this.tryEntries.length - 1; h >= 0; --h) {
                    var b = this.tryEntries[h];
                    if (b.tryLoc === f) {
                        var C = b.completion;
                        if (C.type === "throw") {
                            var _ = C.arg;
                            pe(b)
                        }
                        return _
                    }
                }
                throw new Error("illegal catch attempt")
            },
            delegateYield: function(f, h, b) {
                return this.delegate = {
                    iterator: H(f),
                    resultName: h,
                    nextLoc: b
                }, this.method === "next" && (this.arg = void 0), E
            }
        }, n
    }
    t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports
})(R2);
var kf = R2.exports(),
    GA = kf;
try {
    regeneratorRuntime = kf
} catch {
    typeof globalThis == "object" ? globalThis.regeneratorRuntime = kf : Function("r", "regeneratorRuntime = r")(kf)
}
var D2 = {
    exports: {}
};
(function(t) {
    function e(n, i, s, o, a, c, d) {
        try {
            var y = n[c](d),
                I = y.value
        } catch (N) {
            s(N);
            return
        }
        y.done ? i(I) : Promise.resolve(I).then(o, a)
    }

    function r(n) {
        return function() {
            var i = this,
                s = arguments;
            return new Promise(function(o, a) {
                var c = n.apply(i, s);

                function d(I) {
                    e(c, o, a, d, y, "next", I)
                }

                function y(I) {
                    e(c, o, a, d, y, "throw", I)
                }
                d(void 0)
            })
        }
    }
    t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports
})(D2);
(function(t) {
    var e = Jc.exports;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.default = void 0;
    var r = e(GA),
        n = e(D2.exports),
        i = e(nh.exports),
        s = e(eh.exports),
        o = e(Xc.exports),
        a = e(th.exports),
        c = e(rh.exports),
        d = e(ih.exports),
        y = sh.exports;

    function I(j) {
        var V = N();
        return function() {
            var O = (0, d.default)(j),
                R;
            if (V) {
                var q = (0, d.default)(this).constructor;
                R = Reflect.construct(O, arguments, q)
            } else R = O.apply(this, arguments);
            return (0, c.default)(this, R)
        }
    }

    function N() {
        if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
        } catch {
            return !1
        }
    }
    var E = function(j, V) {
            var P = {};
            for (var O in j) Object.prototype.hasOwnProperty.call(j, O) && V.indexOf(O) < 0 && (P[O] = j[O]);
            if (j != null && typeof Object.getOwnPropertySymbols == "function")
                for (var R = 0, O = Object.getOwnPropertySymbols(j); R < O.length; R++) V.indexOf(O[R]) < 0 && Object.prototype.propertyIsEnumerable.call(j, O[R]) && (P[O[R]] = j[O[R]]);
            return P
        },
        T = function(j) {
            (0, a.default)(P, j);
            var V = I(P);

            function P(O) {
                var R, q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080",
                    W = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                    Y = arguments.length > 3 ? arguments[3] : void 0;
                (0, s.default)(this, P);
                var G = W.autoconnect,
                    J = G === void 0 ? !0 : G,
                    pe = W.reconnect,
                    we = pe === void 0 ? !0 : pe,
                    H = W.reconnect_interval,
                    w = H === void 0 ? 1e3 : H,
                    p = W.max_reconnects,
                    f = p === void 0 ? 5 : p,
                    h = E(W, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
                return R = V.call(this), R.webSocketFactory = O, R.queue = {}, R.rpc_id = 0, R.address = q, R.autoconnect = J, R.ready = !1, R.reconnect = we, R.reconnect_interval = w, R.max_reconnects = f, R.rest_options = h, R.current_reconnects = 0, R.generate_request_id = Y || function() {
                    return ++R.rpc_id
                }, R.autoconnect && R._connect(R.address, Object.assign({
                    autoconnect: R.autoconnect,
                    reconnect: R.reconnect,
                    reconnect_interval: R.reconnect_interval,
                    max_reconnects: R.max_reconnects
                }, R.rest_options)), R
            }
            return (0, o.default)(P, [{
                key: "connect",
                value: function() {
                    this.socket || this._connect(this.address, Object.assign({
                        autoconnect: this.autoconnect,
                        reconnect: this.reconnect,
                        reconnect_interval: this.reconnect_interval,
                        max_reconnects: this.max_reconnects
                    }, this.rest_options))
                }
            }, {
                key: "call",
                value: function(R, q, W, Y) {
                    var G = this;
                    return !Y && (0, i.default)(W) === "object" && (Y = W, W = null), new Promise(function(J, pe) {
                        if (!G.ready) return pe(new Error("socket not ready"));
                        var we = G.generate_request_id(R, q),
                            H = {
                                jsonrpc: "2.0",
                                method: R,
                                params: q || null,
                                id: we
                            };
                        G.socket.send(JSON.stringify(H), Y, function(w) {
                            if (w) return pe(w);
                            G.queue[we] = {
                                promise: [J, pe]
                            }, W && (G.queue[we].timeout = setTimeout(function() {
                                delete G.queue[we], pe(new Error("reply timeout"))
                            }, W))
                        })
                    })
                }
            }, {
                key: "login",
                value: function() {
                    var O = (0, n.default)(r.default.mark(function q(W) {
                        var Y;
                        return r.default.wrap(function(J) {
                            for (;;) switch (J.prev = J.next) {
                                case 0:
                                    return J.next = 2, this.call("rpc.login", W);
                                case 2:
                                    if (Y = J.sent, Y) {
                                        J.next = 5;
                                        break
                                    }
                                    throw new Error("authentication failed");
                                case 5:
                                    return J.abrupt("return", Y);
                                case 6:
                                case "end":
                                    return J.stop()
                            }
                        }, q, this)
                    }));

                    function R(q) {
                        return O.apply(this, arguments)
                    }
                    return R
                }()
            }, {
                key: "listMethods",
                value: function() {
                    var O = (0, n.default)(r.default.mark(function q() {
                        return r.default.wrap(function(Y) {
                            for (;;) switch (Y.prev = Y.next) {
                                case 0:
                                    return Y.next = 2, this.call("__listMethods");
                                case 2:
                                    return Y.abrupt("return", Y.sent);
                                case 3:
                                case "end":
                                    return Y.stop()
                            }
                        }, q, this)
                    }));

                    function R() {
                        return O.apply(this, arguments)
                    }
                    return R
                }()
            }, {
                key: "notify",
                value: function(R, q) {
                    var W = this;
                    return new Promise(function(Y, G) {
                        if (!W.ready) return G(new Error("socket not ready"));
                        var J = {
                            jsonrpc: "2.0",
                            method: R,
                            params: q || null
                        };
                        W.socket.send(JSON.stringify(J), function(pe) {
                            if (pe) return G(pe);
                            Y()
                        })
                    })
                }
            }, {
                key: "subscribe",
                value: function() {
                    var O = (0, n.default)(r.default.mark(function q(W) {
                        var Y;
                        return r.default.wrap(function(J) {
                            for (;;) switch (J.prev = J.next) {
                                case 0:
                                    return typeof W == "string" && (W = [W]), J.next = 3, this.call("rpc.on", W);
                                case 3:
                                    if (Y = J.sent, !(typeof W == "string" && Y[W] !== "ok")) {
                                        J.next = 6;
                                        break
                                    }
                                    throw new Error("Failed subscribing to an event '" + W + "' with: " + Y[W]);
                                case 6:
                                    return J.abrupt("return", Y);
                                case 7:
                                case "end":
                                    return J.stop()
                            }
                        }, q, this)
                    }));

                    function R(q) {
                        return O.apply(this, arguments)
                    }
                    return R
                }()
            }, {
                key: "unsubscribe",
                value: function() {
                    var O = (0, n.default)(r.default.mark(function q(W) {
                        var Y;
                        return r.default.wrap(function(J) {
                            for (;;) switch (J.prev = J.next) {
                                case 0:
                                    return typeof W == "string" && (W = [W]), J.next = 3, this.call("rpc.off", W);
                                case 3:
                                    if (Y = J.sent, !(typeof W == "string" && Y[W] !== "ok")) {
                                        J.next = 6;
                                        break
                                    }
                                    throw new Error("Failed unsubscribing from an event with: " + Y);
                                case 6:
                                    return J.abrupt("return", Y);
                                case 7:
                                case "end":
                                    return J.stop()
                            }
                        }, q, this)
                    }));

                    function R(q) {
                        return O.apply(this, arguments)
                    }
                    return R
                }()
            }, {
                key: "close",
                value: function(R, q) {
                    this.socket.close(R || 1e3, q)
                }
            }, {
                key: "_connect",
                value: function(R, q) {
                    var W = this;
                    this.socket = this.webSocketFactory(R, q), this.socket.addEventListener("open", function() {
                        W.ready = !0, W.emit("open"), W.current_reconnects = 0
                    }), this.socket.addEventListener("message", function(Y) {
                        var G = Y.data;
                        G instanceof ArrayBuffer && (G = Buffer.from(G).toString());
                        try {
                            G = JSON.parse(G)
                        } catch {
                            return
                        }
                        if (G.notification && W.listeners(G.notification).length) {
                            if (!Object.keys(G.params).length) return W.emit(G.notification);
                            var J = [G.notification];
                            if (G.params.constructor === Object) J.push(G.params);
                            else
                                for (var pe = 0; pe < G.params.length; pe++) J.push(G.params[pe]);
                            return Promise.resolve().then(function() {
                                W.emit.apply(W, J)
                            })
                        }
                        if (!W.queue[G.id]) return G.method && G.params ? Promise.resolve().then(function() {
                            W.emit(G.method, G.params)
                        }) : void 0;
                        "error" in G == "result" in G && W.queue[G.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), W.queue[G.id].timeout && clearTimeout(W.queue[G.id].timeout), G.error ? W.queue[G.id].promise[1](G.error) : W.queue[G.id].promise[0](G.result), delete W.queue[G.id]
                    }), this.socket.addEventListener("error", function(Y) {
                        return W.emit("error", Y)
                    }), this.socket.addEventListener("close", function(Y) {
                        var G = Y.code,
                            J = Y.reason;
                        W.ready && setTimeout(function() {
                            return W.emit("close", G, J)
                        }, 0), W.ready = !1, W.socket = void 0, G !== 1e3 && (W.current_reconnects++, W.reconnect && (W.max_reconnects > W.current_reconnects || W.max_reconnects === 0) && setTimeout(function() {
                            return W._connect(R, q)
                        }, W.reconnect_interval))
                    })
                }
            }]), P
        }(y.EventEmitter);
    t.default = T
})(O2);
var Fo = Jc.exports;
Object.defineProperty(A1, "__esModule", {
    value: !0
});
var P2 = A1.Client = void 0,
    YA = Fo(Xc.exports),
    KA = Fo(eh.exports),
    ZA = Fo(th.exports),
    JA = Fo(rh.exports),
    gv = Fo(ih.exports),
    XA = Fo(T2),
    eS = Fo(O2);

function tS(t) {
    var e = rS();
    return function() {
        var n = (0, gv.default)(t),
            i;
        if (e) {
            var s = (0, gv.default)(this).constructor;
            i = Reflect.construct(n, arguments, s)
        } else i = n.apply(this, arguments);
        return (0, JA.default)(this, i)
    }
}

function rS() {
    if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
    } catch {
        return !1
    }
}
var nS = function(t) {
    (0, ZA.default)(r, t);
    var e = tS(r);

    function r() {
        var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ws://localhost:8080",
            i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            s = i.autoconnect,
            o = s === void 0 ? !0 : s,
            a = i.reconnect,
            c = a === void 0 ? !0 : a,
            d = i.reconnect_interval,
            y = d === void 0 ? 1e3 : d,
            I = i.max_reconnects,
            N = I === void 0 ? 5 : I,
            E = arguments.length > 2 ? arguments[2] : void 0;
        return (0, KA.default)(this, r), e.call(this, XA.default, n, {
            autoconnect: o,
            reconnect: c,
            reconnect_interval: y,
            max_reconnects: N
        }, E)
    }
    return (0, YA.default)(r)
}(eS.default);
P2 = A1.Client = nS;
var af, iS = new Uint8Array(16);

function L2() {
    if (!af && (af = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !af)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return af(iS)
}
var sS = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function oh(t) {
    return typeof t == "string" && sS.test(t)
}
var Wr = [];
for (var h0 = 0; h0 < 256; ++h0) Wr.push((h0 + 256).toString(16).substr(1));

function ah(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        r = (Wr[t[e + 0]] + Wr[t[e + 1]] + Wr[t[e + 2]] + Wr[t[e + 3]] + "-" + Wr[t[e + 4]] + Wr[t[e + 5]] + "-" + Wr[t[e + 6]] + Wr[t[e + 7]] + "-" + Wr[t[e + 8]] + Wr[t[e + 9]] + "-" + Wr[t[e + 10]] + Wr[t[e + 11]] + Wr[t[e + 12]] + Wr[t[e + 13]] + Wr[t[e + 14]] + Wr[t[e + 15]]).toLowerCase();
    if (!oh(r)) throw TypeError("Stringified UUID is invalid");
    return r
}
var yv, d0, p0 = 0,
    m0 = 0;

function oS(t, e, r) {
    var n = e && r || 0,
        i = e || new Array(16);
    t = t || {};
    var s = t.node || yv,
        o = t.clockseq !== void 0 ? t.clockseq : d0;
    if (s == null || o == null) {
        var a = t.random || (t.rng || L2)();
        s == null && (s = yv = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]), o == null && (o = d0 = (a[6] << 8 | a[7]) & 16383)
    }
    var c = t.msecs !== void 0 ? t.msecs : Date.now(),
        d = t.nsecs !== void 0 ? t.nsecs : m0 + 1,
        y = c - p0 + (d - m0) / 1e4;
    if (y < 0 && t.clockseq === void 0 && (o = o + 1 & 16383), (y < 0 || c > p0) && t.nsecs === void 0 && (d = 0), d >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    p0 = c, m0 = d, d0 = o, c += 122192928e5;
    var I = ((c & 268435455) * 1e4 + d) % 4294967296;
    i[n++] = I >>> 24 & 255, i[n++] = I >>> 16 & 255, i[n++] = I >>> 8 & 255, i[n++] = I & 255;
    var N = c / 4294967296 * 1e4 & 268435455;
    i[n++] = N >>> 8 & 255, i[n++] = N & 255, i[n++] = N >>> 24 & 15 | 16, i[n++] = N >>> 16 & 255, i[n++] = o >>> 8 | 128, i[n++] = o & 255;
    for (var E = 0; E < 6; ++E) i[n + E] = s[E];
    return e || ah(i)
}

function F2(t) {
    if (!oh(t)) throw TypeError("Invalid UUID");
    var e, r = new Uint8Array(16);
    return r[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, r[1] = e >>> 16 & 255, r[2] = e >>> 8 & 255, r[3] = e & 255, r[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, r[5] = e & 255, r[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, r[7] = e & 255, r[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, r[9] = e & 255, r[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = e / 4294967296 & 255, r[12] = e >>> 24 & 255, r[13] = e >>> 16 & 255, r[14] = e >>> 8 & 255, r[15] = e & 255, r
}

function aS(t) {
    t = unescape(encodeURIComponent(t));
    for (var e = [], r = 0; r < t.length; ++r) e.push(t.charCodeAt(r));
    return e
}
var uS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    lS = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";

function U2(t, e, r) {
    function n(i, s, o, a) {
        if (typeof i == "string" && (i = aS(i)), typeof s == "string" && (s = F2(s)), s.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var c = new Uint8Array(16 + i.length);
        if (c.set(s), c.set(i, s.length), c = r(c), c[6] = c[6] & 15 | e, c[8] = c[8] & 63 | 128, o) {
            a = a || 0;
            for (var d = 0; d < 16; ++d) o[a + d] = c[d];
            return o
        }
        return ah(c)
    }
    try {
        n.name = t
    } catch {}
    return n.DNS = uS, n.URL = lS, n
}

function fS(t) {
    if (typeof t == "string") {
        var e = unescape(encodeURIComponent(t));
        t = new Uint8Array(e.length);
        for (var r = 0; r < e.length; ++r) t[r] = e.charCodeAt(r)
    }
    return cS(hS(dS(t), t.length * 8))
}

function cS(t) {
    for (var e = [], r = t.length * 32, n = "0123456789abcdef", i = 0; i < r; i += 8) {
        var s = t[i >> 5] >>> i % 32 & 255,
            o = parseInt(n.charAt(s >>> 4 & 15) + n.charAt(s & 15), 16);
        e.push(o)
    }
    return e
}

function z2(t) {
    return (t + 64 >>> 9 << 4) + 14 + 1
}

function hS(t, e) {
    t[e >> 5] |= 128 << e % 32, t[z2(e) - 1] = e;
    for (var r = 1732584193, n = -271733879, i = -1732584194, s = 271733878, o = 0; o < t.length; o += 16) {
        var a = r,
            c = n,
            d = i,
            y = s;
        r = un(r, n, i, s, t[o], 7, -680876936), s = un(s, r, n, i, t[o + 1], 12, -389564586), i = un(i, s, r, n, t[o + 2], 17, 606105819), n = un(n, i, s, r, t[o + 3], 22, -1044525330), r = un(r, n, i, s, t[o + 4], 7, -176418897), s = un(s, r, n, i, t[o + 5], 12, 1200080426), i = un(i, s, r, n, t[o + 6], 17, -1473231341), n = un(n, i, s, r, t[o + 7], 22, -45705983), r = un(r, n, i, s, t[o + 8], 7, 1770035416), s = un(s, r, n, i, t[o + 9], 12, -1958414417), i = un(i, s, r, n, t[o + 10], 17, -42063), n = un(n, i, s, r, t[o + 11], 22, -1990404162), r = un(r, n, i, s, t[o + 12], 7, 1804603682), s = un(s, r, n, i, t[o + 13], 12, -40341101), i = un(i, s, r, n, t[o + 14], 17, -1502002290), n = un(n, i, s, r, t[o + 15], 22, 1236535329), r = ln(r, n, i, s, t[o + 1], 5, -165796510), s = ln(s, r, n, i, t[o + 6], 9, -1069501632), i = ln(i, s, r, n, t[o + 11], 14, 643717713), n = ln(n, i, s, r, t[o], 20, -373897302), r = ln(r, n, i, s, t[o + 5], 5, -701558691), s = ln(s, r, n, i, t[o + 10], 9, 38016083), i = ln(i, s, r, n, t[o + 15], 14, -660478335), n = ln(n, i, s, r, t[o + 4], 20, -405537848), r = ln(r, n, i, s, t[o + 9], 5, 568446438), s = ln(s, r, n, i, t[o + 14], 9, -1019803690), i = ln(i, s, r, n, t[o + 3], 14, -187363961), n = ln(n, i, s, r, t[o + 8], 20, 1163531501), r = ln(r, n, i, s, t[o + 13], 5, -1444681467), s = ln(s, r, n, i, t[o + 2], 9, -51403784), i = ln(i, s, r, n, t[o + 7], 14, 1735328473), n = ln(n, i, s, r, t[o + 12], 20, -1926607734), r = fn(r, n, i, s, t[o + 5], 4, -378558), s = fn(s, r, n, i, t[o + 8], 11, -2022574463), i = fn(i, s, r, n, t[o + 11], 16, 1839030562), n = fn(n, i, s, r, t[o + 14], 23, -35309556), r = fn(r, n, i, s, t[o + 1], 4, -1530992060), s = fn(s, r, n, i, t[o + 4], 11, 1272893353), i = fn(i, s, r, n, t[o + 7], 16, -155497632), n = fn(n, i, s, r, t[o + 10], 23, -1094730640), r = fn(r, n, i, s, t[o + 13], 4, 681279174), s = fn(s, r, n, i, t[o], 11, -358537222), i = fn(i, s, r, n, t[o + 3], 16, -722521979), n = fn(n, i, s, r, t[o + 6], 23, 76029189), r = fn(r, n, i, s, t[o + 9], 4, -640364487), s = fn(s, r, n, i, t[o + 12], 11, -421815835), i = fn(i, s, r, n, t[o + 15], 16, 530742520), n = fn(n, i, s, r, t[o + 2], 23, -995338651), r = cn(r, n, i, s, t[o], 6, -198630844), s = cn(s, r, n, i, t[o + 7], 10, 1126891415), i = cn(i, s, r, n, t[o + 14], 15, -1416354905), n = cn(n, i, s, r, t[o + 5], 21, -57434055), r = cn(r, n, i, s, t[o + 12], 6, 1700485571), s = cn(s, r, n, i, t[o + 3], 10, -1894986606), i = cn(i, s, r, n, t[o + 10], 15, -1051523), n = cn(n, i, s, r, t[o + 1], 21, -2054922799), r = cn(r, n, i, s, t[o + 8], 6, 1873313359), s = cn(s, r, n, i, t[o + 15], 10, -30611744), i = cn(i, s, r, n, t[o + 6], 15, -1560198380), n = cn(n, i, s, r, t[o + 13], 21, 1309151649), r = cn(r, n, i, s, t[o + 4], 6, -145523070), s = cn(s, r, n, i, t[o + 11], 10, -1120210379), i = cn(i, s, r, n, t[o + 2], 15, 718787259), n = cn(n, i, s, r, t[o + 9], 21, -343485551), r = Hs(r, a), n = Hs(n, c), i = Hs(i, d), s = Hs(s, y)
    }
    return [r, n, i, s]
}

function dS(t) {
    if (t.length === 0) return [];
    for (var e = t.length * 8, r = new Uint32Array(z2(e)), n = 0; n < e; n += 8) r[n >> 5] |= (t[n / 8] & 255) << n % 32;
    return r
}

function Hs(t, e) {
    var r = (t & 65535) + (e & 65535),
        n = (t >> 16) + (e >> 16) + (r >> 16);
    return n << 16 | r & 65535
}

function pS(t, e) {
    return t << e | t >>> 32 - e
}

function uh(t, e, r, n, i, s) {
    return Hs(pS(Hs(Hs(e, t), Hs(n, s)), i), r)
}

function un(t, e, r, n, i, s, o) {
    return uh(e & r | ~e & n, t, e, i, s, o)
}

function ln(t, e, r, n, i, s, o) {
    return uh(e & n | r & ~n, t, e, i, s, o)
}

function fn(t, e, r, n, i, s, o) {
    return uh(e ^ r ^ n, t, e, i, s, o)
}

function cn(t, e, r, n, i, s, o) {
    return uh(r ^ (e | ~n), t, e, i, s, o)
}
var mS = U2("v3", 48, fS),
    vS = mS;

function gS(t, e, r) {
    t = t || {};
    var n = t.random || (t.rng || L2)();
    if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, e) {
        r = r || 0;
        for (var i = 0; i < 16; ++i) e[r + i] = n[i];
        return e
    }
    return ah(n)
}

function yS(t, e, r, n) {
    switch (t) {
        case 0:
            return e & r ^ ~e & n;
        case 1:
            return e ^ r ^ n;
        case 2:
            return e & r ^ e & n ^ r & n;
        case 3:
            return e ^ r ^ n
    }
}

function v0(t, e) {
    return t << e | t >>> 32 - e
}

function wS(t) {
    var e = [1518500249, 1859775393, 2400959708, 3395469782],
        r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof t == "string") {
        var n = unescape(encodeURIComponent(t));
        t = [];
        for (var i = 0; i < n.length; ++i) t.push(n.charCodeAt(i))
    } else Array.isArray(t) || (t = Array.prototype.slice.call(t));
    t.push(128);
    for (var s = t.length / 4 + 2, o = Math.ceil(s / 16), a = new Array(o), c = 0; c < o; ++c) {
        for (var d = new Uint32Array(16), y = 0; y < 16; ++y) d[y] = t[c * 64 + y * 4] << 24 | t[c * 64 + y * 4 + 1] << 16 | t[c * 64 + y * 4 + 2] << 8 | t[c * 64 + y * 4 + 3];
        a[c] = d
    }
    a[o - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32), a[o - 1][14] = Math.floor(a[o - 1][14]), a[o - 1][15] = (t.length - 1) * 8 & 4294967295;
    for (var I = 0; I < o; ++I) {
        for (var N = new Uint32Array(80), E = 0; E < 16; ++E) N[E] = a[I][E];
        for (var T = 16; T < 80; ++T) N[T] = v0(N[T - 3] ^ N[T - 8] ^ N[T - 14] ^ N[T - 16], 1);
        for (var j = r[0], V = r[1], P = r[2], O = r[3], R = r[4], q = 0; q < 80; ++q) {
            var W = Math.floor(q / 20),
                Y = v0(j, 5) + yS(W, V, P, O) + R + e[W] + N[q] >>> 0;
            R = O, O = P, P = v0(V, 30) >>> 0, V = j, j = Y
        }
        r[0] = r[0] + j >>> 0, r[1] = r[1] + V >>> 0, r[2] = r[2] + P >>> 0, r[3] = r[3] + O >>> 0, r[4] = r[4] + R >>> 0
    }
    return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, r[0] & 255, r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, r[1] & 255, r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, r[2] & 255, r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, r[3] & 255, r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, r[4] & 255]
}
var xS = U2("v5", 80, wS),
    bS = xS,
    AS = "00000000-0000-0000-0000-000000000000";

function SS(t) {
    if (!oh(t)) throw TypeError("Invalid UUID");
    return parseInt(t.substr(14, 1), 16)
}
var MS = Object.freeze(Object.defineProperty({
        __proto__: null,
        v1: oS,
        v3: vS,
        v4: gS,
        v5: bS,
        NIL: AS,
        version: SS,
        validate: oh,
        stringify: ah,
        parse: F2
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    j2 = mp(MS);
const ES = j2.v4,
    _S = function(t, e, r, n) {
        if (typeof t != "string") throw new TypeError(t + " must be a string");
        n = n || {};
        const i = typeof n.version == "number" ? n.version : 2;
        if (i !== 1 && i !== 2) throw new TypeError(i + " must be 1 or 2");
        const s = {
            method: t
        };
        if (i === 2 && (s.jsonrpc = "2.0"), e) {
            if (typeof e != "object" && !Array.isArray(e)) throw new TypeError(e + " must be an object, array or omitted");
            s.params = e
        }
        if (typeof r == "undefined") {
            const o = typeof n.generator == "function" ? n.generator : function() {
                return ES()
            };
            s.id = o(s, n)
        } else i === 2 && r === null ? n.notificationIdNull && (s.id = null) : s.id = r;
        return s
    };
var IS = _S;
const CS = j2.v4,
    BS = IS,
    ml = function(t, e) {
        if (!(this instanceof ml)) return new ml(t, e);
        e || (e = {}), this.options = {
            reviver: typeof e.reviver != "undefined" ? e.reviver : null,
            replacer: typeof e.replacer != "undefined" ? e.replacer : null,
            generator: typeof e.generator != "undefined" ? e.generator : function() {
                return CS()
            },
            version: typeof e.version != "undefined" ? e.version : 2,
            notificationIdNull: typeof e.notificationIdNull == "boolean" ? e.notificationIdNull : !1
        }, this.callServer = t
    };
var kS = ml;
ml.prototype.request = function(t, e, r, n) {
    const i = this;
    let s = null;
    const o = Array.isArray(t) && typeof e == "function";
    if (this.options.version === 1 && o) throw new TypeError("JSON-RPC 1.0 does not support batching");
    if (o || !o && t && typeof t == "object" && typeof e == "function") n = e, s = t;
    else {
        typeof r == "function" && (n = r, r = void 0);
        const d = typeof n == "function";
        try {
            s = BS(t, e, r, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull
            })
        } catch (y) {
            if (d) return n(y);
            throw y
        }
        if (!d) return s
    }
    let c;
    try {
        c = JSON.stringify(s, this.options.replacer)
    } catch (d) {
        return n(d)
    }
    return this.callServer(c, function(d, y) {
        i._parseResponse(d, y, n)
    }), s
};
ml.prototype._parseResponse = function(t, e, r) {
    if (t) {
        r(t);
        return
    }
    if (!e) return r();
    let n;
    try {
        n = JSON.parse(e, this.options.reviver)
    } catch (i) {
        return r(i)
    }
    if (r.length === 3)
        if (Array.isArray(n)) {
            const i = function(o) {
                    return typeof o.error != "undefined"
                },
                s = function(o) {
                    return !i(o)
                };
            return r(null, n.filter(i), n.filter(s))
        } else return r(null, n.error, n.result);
    r(null, n)
};
var $2 = {};
const NS = "elliptic",
    TS = "6.5.4",
    OS = "EC cryptography",
    RS = "lib/elliptic.js",
    DS = ["lib"],
    PS = {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
    },
    LS = {
        type: "git",
        url: "git@github.com:indutny/elliptic"
    },
    FS = ["EC", "Elliptic", "curve", "Cryptography"],
    US = "Fedor Indutny <fedor@indutny.com>",
    zS = "MIT",
    jS = {
        url: "https://github.com/indutny/elliptic/issues"
    },
    $S = "https://github.com/indutny/elliptic",
    HS = {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
    },
    QS = {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
    };
var qS = {
        name: NS,
        version: TS,
        description: OS,
        main: RS,
        files: DS,
        scripts: PS,
        repository: LS,
        keywords: FS,
        author: US,
        license: zS,
        bugs: jS,
        homepage: $S,
        devDependencies: HS,
        dependencies: QS
    },
    qn = {},
    es = {
        exports: {}
    };
(function(t) {
    (function(e, r) {
        function n(H, w) {
            if (!H) throw new Error(w || "Assertion failed")
        }

        function i(H, w) {
            H.super_ = w;
            var p = function() {};
            p.prototype = w.prototype, H.prototype = new p, H.prototype.constructor = H
        }

        function s(H, w, p) {
            if (s.isBN(H)) return H;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, H !== null && ((w === "le" || w === "be") && (p = w, w = 10), this._init(H || 0, w || 10, p || "be"))
        }
        typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
        var o;
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? o = window.Buffer : o = require("buffer").Buffer
        } catch {}
        s.isBN = function(w) {
            return w instanceof s ? !0 : w !== null && typeof w == "object" && w.constructor.wordSize === s.wordSize && Array.isArray(w.words)
        }, s.max = function(w, p) {
            return w.cmp(p) > 0 ? w : p
        }, s.min = function(w, p) {
            return w.cmp(p) < 0 ? w : p
        }, s.prototype._init = function(w, p, f) {
            if (typeof w == "number") return this._initNumber(w, p, f);
            if (typeof w == "object") return this._initArray(w, p, f);
            p === "hex" && (p = 16), n(p === (p | 0) && p >= 2 && p <= 36), w = w.toString().replace(/\s+/g, "");
            var h = 0;
            w[0] === "-" && (h++, this.negative = 1), h < w.length && (p === 16 ? this._parseHex(w, h, f) : (this._parseBase(w, p, h), f === "le" && this._initArray(this.toArray(), p, f)))
        }, s.prototype._initNumber = function(w, p, f) {
            w < 0 && (this.negative = 1, w = -w), w < 67108864 ? (this.words = [w & 67108863], this.length = 1) : w < 4503599627370496 ? (this.words = [w & 67108863, w / 67108864 & 67108863], this.length = 2) : (n(w < 9007199254740992), this.words = [w & 67108863, w / 67108864 & 67108863, 1], this.length = 3), f === "le" && this._initArray(this.toArray(), p, f)
        }, s.prototype._initArray = function(w, p, f) {
            if (n(typeof w.length == "number"), w.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(w.length / 3), this.words = new Array(this.length);
            for (var h = 0; h < this.length; h++) this.words[h] = 0;
            var b, C, _ = 0;
            if (f === "be")
                for (h = w.length - 1, b = 0; h >= 0; h -= 3) C = w[h] | w[h - 1] << 8 | w[h - 2] << 16, this.words[b] |= C << _ & 67108863, this.words[b + 1] = C >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, b++);
            else if (f === "le")
                for (h = 0, b = 0; h < w.length; h += 3) C = w[h] | w[h + 1] << 8 | w[h + 2] << 16, this.words[b] |= C << _ & 67108863, this.words[b + 1] = C >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, b++);
            return this.strip()
        };

        function a(H, w) {
            var p = H.charCodeAt(w);
            return p >= 65 && p <= 70 ? p - 55 : p >= 97 && p <= 102 ? p - 87 : p - 48 & 15
        }

        function c(H, w, p) {
            var f = a(H, p);
            return p - 1 >= w && (f |= a(H, p - 1) << 4), f
        }
        s.prototype._parseHex = function(w, p, f) {
            this.length = Math.ceil((w.length - p) / 6), this.words = new Array(this.length);
            for (var h = 0; h < this.length; h++) this.words[h] = 0;
            var b = 0,
                C = 0,
                _;
            if (f === "be")
                for (h = w.length - 1; h >= p; h -= 2) _ = c(w, p, h) << b, this.words[C] |= _ & 67108863, b >= 18 ? (b -= 18, C += 1, this.words[C] |= _ >>> 26) : b += 8;
            else {
                var M = w.length - p;
                for (h = M % 2 === 0 ? p + 1 : p; h < w.length; h += 2) _ = c(w, p, h) << b, this.words[C] |= _ & 67108863, b >= 18 ? (b -= 18, C += 1, this.words[C] |= _ >>> 26) : b += 8
            }
            this.strip()
        };

        function d(H, w, p, f) {
            for (var h = 0, b = Math.min(H.length, p), C = w; C < b; C++) {
                var _ = H.charCodeAt(C) - 48;
                h *= f, _ >= 49 ? h += _ - 49 + 10 : _ >= 17 ? h += _ - 17 + 10 : h += _
            }
            return h
        }
        s.prototype._parseBase = function(w, p, f) {
            this.words = [0], this.length = 1;
            for (var h = 0, b = 1; b <= 67108863; b *= p) h++;
            h--, b = b / p | 0;
            for (var C = w.length - f, _ = C % h, M = Math.min(C, C - _) + f, m = 0, A = f; A < M; A += h) m = d(w, A, A + h, p), this.imuln(b), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
            if (_ !== 0) {
                var x = 1;
                for (m = d(w, A, w.length, p), A = 0; A < _; A++) x *= p;
                this.imuln(x), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m)
            }
            this.strip()
        }, s.prototype.copy = function(w) {
            w.words = new Array(this.length);
            for (var p = 0; p < this.length; p++) w.words[p] = this.words[p];
            w.length = this.length, w.negative = this.negative, w.red = this.red
        }, s.prototype.clone = function() {
            var w = new s(null);
            return this.copy(w), w
        }, s.prototype._expand = function(w) {
            for (; this.length < w;) this.words[this.length++] = 0;
            return this
        }, s.prototype.strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
            return this._normSign()
        }, s.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        }, s.prototype.inspect = function() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        };
        var y = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            I = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            N = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        s.prototype.toString = function(w, p) {
            w = w || 10, p = p | 0 || 1;
            var f;
            if (w === 16 || w === "hex") {
                f = "";
                for (var h = 0, b = 0, C = 0; C < this.length; C++) {
                    var _ = this.words[C],
                        M = ((_ << h | b) & 16777215).toString(16);
                    b = _ >>> 24 - h & 16777215, b !== 0 || C !== this.length - 1 ? f = y[6 - M.length] + M + f : f = M + f, h += 2, h >= 26 && (h -= 26, C--)
                }
                for (b !== 0 && (f = b.toString(16) + f); f.length % p !== 0;) f = "0" + f;
                return this.negative !== 0 && (f = "-" + f), f
            }
            if (w === (w | 0) && w >= 2 && w <= 36) {
                var m = I[w],
                    A = N[w];
                f = "";
                var x = this.clone();
                for (x.negative = 0; !x.isZero();) {
                    var z = x.modn(A).toString(w);
                    x = x.idivn(A), x.isZero() ? f = z + f : f = y[m - z.length] + z + f
                }
                for (this.isZero() && (f = "0" + f); f.length % p !== 0;) f = "0" + f;
                return this.negative !== 0 && (f = "-" + f), f
            }
            n(!1, "Base should be between 2 and 36")
        }, s.prototype.toNumber = function() {
            var w = this.words[0];
            return this.length === 2 ? w += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? w += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -w : w
        }, s.prototype.toJSON = function() {
            return this.toString(16)
        }, s.prototype.toBuffer = function(w, p) {
            return n(typeof o != "undefined"), this.toArrayLike(o, w, p)
        }, s.prototype.toArray = function(w, p) {
            return this.toArrayLike(Array, w, p)
        }, s.prototype.toArrayLike = function(w, p, f) {
            var h = this.byteLength(),
                b = f || Math.max(1, h);
            n(h <= b, "byte array longer than desired length"), n(b > 0, "Requested array length <= 0"), this.strip();
            var C = p === "le",
                _ = new w(b),
                M, m, A = this.clone();
            if (C) {
                for (m = 0; !A.isZero(); m++) M = A.andln(255), A.iushrn(8), _[m] = M;
                for (; m < b; m++) _[m] = 0
            } else {
                for (m = 0; m < b - h; m++) _[m] = 0;
                for (m = 0; !A.isZero(); m++) M = A.andln(255), A.iushrn(8), _[b - m - 1] = M
            }
            return _
        }, Math.clz32 ? s.prototype._countBits = function(w) {
            return 32 - Math.clz32(w)
        } : s.prototype._countBits = function(w) {
            var p = w,
                f = 0;
            return p >= 4096 && (f += 13, p >>>= 13), p >= 64 && (f += 7, p >>>= 7), p >= 8 && (f += 4, p >>>= 4), p >= 2 && (f += 2, p >>>= 2), f + p
        }, s.prototype._zeroBits = function(w) {
            if (w === 0) return 26;
            var p = w,
                f = 0;
            return (p & 8191) === 0 && (f += 13, p >>>= 13), (p & 127) === 0 && (f += 7, p >>>= 7), (p & 15) === 0 && (f += 4, p >>>= 4), (p & 3) === 0 && (f += 2, p >>>= 2), (p & 1) === 0 && f++, f
        }, s.prototype.bitLength = function() {
            var w = this.words[this.length - 1],
                p = this._countBits(w);
            return (this.length - 1) * 26 + p
        };

        function E(H) {
            for (var w = new Array(H.bitLength()), p = 0; p < w.length; p++) {
                var f = p / 26 | 0,
                    h = p % 26;
                w[p] = (H.words[f] & 1 << h) >>> h
            }
            return w
        }
        s.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var w = 0, p = 0; p < this.length; p++) {
                var f = this._zeroBits(this.words[p]);
                if (w += f, f !== 26) break
            }
            return w
        }, s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }, s.prototype.toTwos = function(w) {
            return this.negative !== 0 ? this.abs().inotn(w).iaddn(1) : this.clone()
        }, s.prototype.fromTwos = function(w) {
            return this.testn(w - 1) ? this.notn(w).iaddn(1).ineg() : this.clone()
        }, s.prototype.isNeg = function() {
            return this.negative !== 0
        }, s.prototype.neg = function() {
            return this.clone().ineg()
        }, s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this
        }, s.prototype.iuor = function(w) {
            for (; this.length < w.length;) this.words[this.length++] = 0;
            for (var p = 0; p < w.length; p++) this.words[p] = this.words[p] | w.words[p];
            return this.strip()
        }, s.prototype.ior = function(w) {
            return n((this.negative | w.negative) === 0), this.iuor(w)
        }, s.prototype.or = function(w) {
            return this.length > w.length ? this.clone().ior(w) : w.clone().ior(this)
        }, s.prototype.uor = function(w) {
            return this.length > w.length ? this.clone().iuor(w) : w.clone().iuor(this)
        }, s.prototype.iuand = function(w) {
            var p;
            this.length > w.length ? p = w : p = this;
            for (var f = 0; f < p.length; f++) this.words[f] = this.words[f] & w.words[f];
            return this.length = p.length, this.strip()
        }, s.prototype.iand = function(w) {
            return n((this.negative | w.negative) === 0), this.iuand(w)
        }, s.prototype.and = function(w) {
            return this.length > w.length ? this.clone().iand(w) : w.clone().iand(this)
        }, s.prototype.uand = function(w) {
            return this.length > w.length ? this.clone().iuand(w) : w.clone().iuand(this)
        }, s.prototype.iuxor = function(w) {
            var p, f;
            this.length > w.length ? (p = this, f = w) : (p = w, f = this);
            for (var h = 0; h < f.length; h++) this.words[h] = p.words[h] ^ f.words[h];
            if (this !== p)
                for (; h < p.length; h++) this.words[h] = p.words[h];
            return this.length = p.length, this.strip()
        }, s.prototype.ixor = function(w) {
            return n((this.negative | w.negative) === 0), this.iuxor(w)
        }, s.prototype.xor = function(w) {
            return this.length > w.length ? this.clone().ixor(w) : w.clone().ixor(this)
        }, s.prototype.uxor = function(w) {
            return this.length > w.length ? this.clone().iuxor(w) : w.clone().iuxor(this)
        }, s.prototype.inotn = function(w) {
            n(typeof w == "number" && w >= 0);
            var p = Math.ceil(w / 26) | 0,
                f = w % 26;
            this._expand(p), f > 0 && p--;
            for (var h = 0; h < p; h++) this.words[h] = ~this.words[h] & 67108863;
            return f > 0 && (this.words[h] = ~this.words[h] & 67108863 >> 26 - f), this.strip()
        }, s.prototype.notn = function(w) {
            return this.clone().inotn(w)
        }, s.prototype.setn = function(w, p) {
            n(typeof w == "number" && w >= 0);
            var f = w / 26 | 0,
                h = w % 26;
            return this._expand(f + 1), p ? this.words[f] = this.words[f] | 1 << h : this.words[f] = this.words[f] & ~(1 << h), this.strip()
        }, s.prototype.iadd = function(w) {
            var p;
            if (this.negative !== 0 && w.negative === 0) return this.negative = 0, p = this.isub(w), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && w.negative !== 0) return w.negative = 0, p = this.isub(w), w.negative = 1, p._normSign();
            var f, h;
            this.length > w.length ? (f = this, h = w) : (f = w, h = this);
            for (var b = 0, C = 0; C < h.length; C++) p = (f.words[C] | 0) + (h.words[C] | 0) + b, this.words[C] = p & 67108863, b = p >>> 26;
            for (; b !== 0 && C < f.length; C++) p = (f.words[C] | 0) + b, this.words[C] = p & 67108863, b = p >>> 26;
            if (this.length = f.length, b !== 0) this.words[this.length] = b, this.length++;
            else if (f !== this)
                for (; C < f.length; C++) this.words[C] = f.words[C];
            return this
        }, s.prototype.add = function(w) {
            var p;
            return w.negative !== 0 && this.negative === 0 ? (w.negative = 0, p = this.sub(w), w.negative ^= 1, p) : w.negative === 0 && this.negative !== 0 ? (this.negative = 0, p = w.sub(this), this.negative = 1, p) : this.length > w.length ? this.clone().iadd(w) : w.clone().iadd(this)
        }, s.prototype.isub = function(w) {
            if (w.negative !== 0) {
                w.negative = 0;
                var p = this.iadd(w);
                return w.negative = 1, p._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(w), this.negative = 1, this._normSign();
            var f = this.cmp(w);
            if (f === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var h, b;
            f > 0 ? (h = this, b = w) : (h = w, b = this);
            for (var C = 0, _ = 0; _ < b.length; _++) p = (h.words[_] | 0) - (b.words[_] | 0) + C, C = p >> 26, this.words[_] = p & 67108863;
            for (; C !== 0 && _ < h.length; _++) p = (h.words[_] | 0) + C, C = p >> 26, this.words[_] = p & 67108863;
            if (C === 0 && _ < h.length && h !== this)
                for (; _ < h.length; _++) this.words[_] = h.words[_];
            return this.length = Math.max(this.length, _), h !== this && (this.negative = 1), this.strip()
        }, s.prototype.sub = function(w) {
            return this.clone().isub(w)
        };

        function T(H, w, p) {
            p.negative = w.negative ^ H.negative;
            var f = H.length + w.length | 0;
            p.length = f, f = f - 1 | 0;
            var h = H.words[0] | 0,
                b = w.words[0] | 0,
                C = h * b,
                _ = C & 67108863,
                M = C / 67108864 | 0;
            p.words[0] = _;
            for (var m = 1; m < f; m++) {
                for (var A = M >>> 26, x = M & 67108863, z = Math.min(m, w.length - 1), oe = Math.max(0, m - H.length + 1); oe <= z; oe++) {
                    var k = m - oe | 0;
                    h = H.words[k] | 0, b = w.words[oe] | 0, C = h * b + x, A += C / 67108864 | 0, x = C & 67108863
                }
                p.words[m] = x | 0, M = A | 0
            }
            return M !== 0 ? p.words[m] = M | 0 : p.length--, p.strip()
        }
        var j = function(w, p, f) {
            var h = w.words,
                b = p.words,
                C = f.words,
                _ = 0,
                M, m, A, x = h[0] | 0,
                z = x & 8191,
                oe = x >>> 13,
                k = h[1] | 0,
                X = k & 8191,
                re = k >>> 13,
                ae = h[2] | 0,
                le = ae & 8191,
                Me = ae >>> 13,
                Re = h[3] | 0,
                ve = Re & 8191,
                We = Re >>> 13,
                Ie = h[4] | 0,
                Ue = Ie & 8191,
                Ut = Ie >>> 13,
                It = h[5] | 0,
                it = It & 8191,
                At = It >>> 13,
                Ct = h[6] | 0,
                Ye = Ct & 8191,
                Xe = Ct >>> 13,
                St = h[7] | 0,
                Ze = St & 8191,
                ft = St >>> 13,
                Ot = h[8] | 0,
                v = Ot & 8191,
                u = Ot >>> 13,
                l = h[9] | 0,
                S = l & 8191,
                D = l >>> 13,
                $ = b[0] | 0,
                Q = $ & 8191,
                he = $ >>> 13,
                Be = b[1] | 0,
                ge = Be & 8191,
                Te = Be >>> 13,
                Se = b[2] | 0,
                ot = Se & 8191,
                Gt = Se >>> 13,
                Zt = b[3] | 0,
                ht = Zt & 8191,
                tr = Zt >>> 13,
                Nt = b[4] | 0,
                et = Nt & 8191,
                Lt = Nt >>> 13,
                Yt = b[5] | 0,
                ct = Yt & 8191,
                Jt = Yt >>> 13,
                rr = b[6] | 0,
                Ve = rr & 8191,
                Xt = rr >>> 13,
                B = b[7] | 0,
                L = B & 8191,
                F = B >>> 13,
                g = b[8] | 0,
                U = g & 8191,
                Z = g >>> 13,
                ee = b[9] | 0,
                te = ee & 8191,
                fe = ee >>> 13;
            f.negative = w.negative ^ p.negative, f.length = 19, M = Math.imul(z, Q), m = Math.imul(z, he), m = m + Math.imul(oe, Q) | 0, A = Math.imul(oe, he);
            var Ae = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, M = Math.imul(X, Q), m = Math.imul(X, he), m = m + Math.imul(re, Q) | 0, A = Math.imul(re, he), M = M + Math.imul(z, ge) | 0, m = m + Math.imul(z, Te) | 0, m = m + Math.imul(oe, ge) | 0, A = A + Math.imul(oe, Te) | 0;
            var ye = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, M = Math.imul(le, Q), m = Math.imul(le, he), m = m + Math.imul(Me, Q) | 0, A = Math.imul(Me, he), M = M + Math.imul(X, ge) | 0, m = m + Math.imul(X, Te) | 0, m = m + Math.imul(re, ge) | 0, A = A + Math.imul(re, Te) | 0, M = M + Math.imul(z, ot) | 0, m = m + Math.imul(z, Gt) | 0, m = m + Math.imul(oe, ot) | 0, A = A + Math.imul(oe, Gt) | 0;
            var dt = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, M = Math.imul(ve, Q), m = Math.imul(ve, he), m = m + Math.imul(We, Q) | 0, A = Math.imul(We, he), M = M + Math.imul(le, ge) | 0, m = m + Math.imul(le, Te) | 0, m = m + Math.imul(Me, ge) | 0, A = A + Math.imul(Me, Te) | 0, M = M + Math.imul(X, ot) | 0, m = m + Math.imul(X, Gt) | 0, m = m + Math.imul(re, ot) | 0, A = A + Math.imul(re, Gt) | 0, M = M + Math.imul(z, ht) | 0, m = m + Math.imul(z, tr) | 0, m = m + Math.imul(oe, ht) | 0, A = A + Math.imul(oe, tr) | 0;
            var Ne = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, M = Math.imul(Ue, Q), m = Math.imul(Ue, he), m = m + Math.imul(Ut, Q) | 0, A = Math.imul(Ut, he), M = M + Math.imul(ve, ge) | 0, m = m + Math.imul(ve, Te) | 0, m = m + Math.imul(We, ge) | 0, A = A + Math.imul(We, Te) | 0, M = M + Math.imul(le, ot) | 0, m = m + Math.imul(le, Gt) | 0, m = m + Math.imul(Me, ot) | 0, A = A + Math.imul(Me, Gt) | 0, M = M + Math.imul(X, ht) | 0, m = m + Math.imul(X, tr) | 0, m = m + Math.imul(re, ht) | 0, A = A + Math.imul(re, tr) | 0, M = M + Math.imul(z, et) | 0, m = m + Math.imul(z, Lt) | 0, m = m + Math.imul(oe, et) | 0, A = A + Math.imul(oe, Lt) | 0;
            var Ge = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, M = Math.imul(it, Q), m = Math.imul(it, he), m = m + Math.imul(At, Q) | 0, A = Math.imul(At, he), M = M + Math.imul(Ue, ge) | 0, m = m + Math.imul(Ue, Te) | 0, m = m + Math.imul(Ut, ge) | 0, A = A + Math.imul(Ut, Te) | 0, M = M + Math.imul(ve, ot) | 0, m = m + Math.imul(ve, Gt) | 0, m = m + Math.imul(We, ot) | 0, A = A + Math.imul(We, Gt) | 0, M = M + Math.imul(le, ht) | 0, m = m + Math.imul(le, tr) | 0, m = m + Math.imul(Me, ht) | 0, A = A + Math.imul(Me, tr) | 0, M = M + Math.imul(X, et) | 0, m = m + Math.imul(X, Lt) | 0, m = m + Math.imul(re, et) | 0, A = A + Math.imul(re, Lt) | 0, M = M + Math.imul(z, ct) | 0, m = m + Math.imul(z, Jt) | 0, m = m + Math.imul(oe, ct) | 0, A = A + Math.imul(oe, Jt) | 0;
            var Ke = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, M = Math.imul(Ye, Q), m = Math.imul(Ye, he), m = m + Math.imul(Xe, Q) | 0, A = Math.imul(Xe, he), M = M + Math.imul(it, ge) | 0, m = m + Math.imul(it, Te) | 0, m = m + Math.imul(At, ge) | 0, A = A + Math.imul(At, Te) | 0, M = M + Math.imul(Ue, ot) | 0, m = m + Math.imul(Ue, Gt) | 0, m = m + Math.imul(Ut, ot) | 0, A = A + Math.imul(Ut, Gt) | 0, M = M + Math.imul(ve, ht) | 0, m = m + Math.imul(ve, tr) | 0, m = m + Math.imul(We, ht) | 0, A = A + Math.imul(We, tr) | 0, M = M + Math.imul(le, et) | 0, m = m + Math.imul(le, Lt) | 0, m = m + Math.imul(Me, et) | 0, A = A + Math.imul(Me, Lt) | 0, M = M + Math.imul(X, ct) | 0, m = m + Math.imul(X, Jt) | 0, m = m + Math.imul(re, ct) | 0, A = A + Math.imul(re, Jt) | 0, M = M + Math.imul(z, Ve) | 0, m = m + Math.imul(z, Xt) | 0, m = m + Math.imul(oe, Ve) | 0, A = A + Math.imul(oe, Xt) | 0;
            var Je = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, M = Math.imul(Ze, Q), m = Math.imul(Ze, he), m = m + Math.imul(ft, Q) | 0, A = Math.imul(ft, he), M = M + Math.imul(Ye, ge) | 0, m = m + Math.imul(Ye, Te) | 0, m = m + Math.imul(Xe, ge) | 0, A = A + Math.imul(Xe, Te) | 0, M = M + Math.imul(it, ot) | 0, m = m + Math.imul(it, Gt) | 0, m = m + Math.imul(At, ot) | 0, A = A + Math.imul(At, Gt) | 0, M = M + Math.imul(Ue, ht) | 0, m = m + Math.imul(Ue, tr) | 0, m = m + Math.imul(Ut, ht) | 0, A = A + Math.imul(Ut, tr) | 0, M = M + Math.imul(ve, et) | 0, m = m + Math.imul(ve, Lt) | 0, m = m + Math.imul(We, et) | 0, A = A + Math.imul(We, Lt) | 0, M = M + Math.imul(le, ct) | 0, m = m + Math.imul(le, Jt) | 0, m = m + Math.imul(Me, ct) | 0, A = A + Math.imul(Me, Jt) | 0, M = M + Math.imul(X, Ve) | 0, m = m + Math.imul(X, Xt) | 0, m = m + Math.imul(re, Ve) | 0, A = A + Math.imul(re, Xt) | 0, M = M + Math.imul(z, L) | 0, m = m + Math.imul(z, F) | 0, m = m + Math.imul(oe, L) | 0, A = A + Math.imul(oe, F) | 0;
            var ut = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, M = Math.imul(v, Q), m = Math.imul(v, he), m = m + Math.imul(u, Q) | 0, A = Math.imul(u, he), M = M + Math.imul(Ze, ge) | 0, m = m + Math.imul(Ze, Te) | 0, m = m + Math.imul(ft, ge) | 0, A = A + Math.imul(ft, Te) | 0, M = M + Math.imul(Ye, ot) | 0, m = m + Math.imul(Ye, Gt) | 0, m = m + Math.imul(Xe, ot) | 0, A = A + Math.imul(Xe, Gt) | 0, M = M + Math.imul(it, ht) | 0, m = m + Math.imul(it, tr) | 0, m = m + Math.imul(At, ht) | 0, A = A + Math.imul(At, tr) | 0, M = M + Math.imul(Ue, et) | 0, m = m + Math.imul(Ue, Lt) | 0, m = m + Math.imul(Ut, et) | 0, A = A + Math.imul(Ut, Lt) | 0, M = M + Math.imul(ve, ct) | 0, m = m + Math.imul(ve, Jt) | 0, m = m + Math.imul(We, ct) | 0, A = A + Math.imul(We, Jt) | 0, M = M + Math.imul(le, Ve) | 0, m = m + Math.imul(le, Xt) | 0, m = m + Math.imul(Me, Ve) | 0, A = A + Math.imul(Me, Xt) | 0, M = M + Math.imul(X, L) | 0, m = m + Math.imul(X, F) | 0, m = m + Math.imul(re, L) | 0, A = A + Math.imul(re, F) | 0, M = M + Math.imul(z, U) | 0, m = m + Math.imul(z, Z) | 0, m = m + Math.imul(oe, U) | 0, A = A + Math.imul(oe, Z) | 0;
            var tt = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, M = Math.imul(S, Q), m = Math.imul(S, he), m = m + Math.imul(D, Q) | 0, A = Math.imul(D, he), M = M + Math.imul(v, ge) | 0, m = m + Math.imul(v, Te) | 0, m = m + Math.imul(u, ge) | 0, A = A + Math.imul(u, Te) | 0, M = M + Math.imul(Ze, ot) | 0, m = m + Math.imul(Ze, Gt) | 0, m = m + Math.imul(ft, ot) | 0, A = A + Math.imul(ft, Gt) | 0, M = M + Math.imul(Ye, ht) | 0, m = m + Math.imul(Ye, tr) | 0, m = m + Math.imul(Xe, ht) | 0, A = A + Math.imul(Xe, tr) | 0, M = M + Math.imul(it, et) | 0, m = m + Math.imul(it, Lt) | 0, m = m + Math.imul(At, et) | 0, A = A + Math.imul(At, Lt) | 0, M = M + Math.imul(Ue, ct) | 0, m = m + Math.imul(Ue, Jt) | 0, m = m + Math.imul(Ut, ct) | 0, A = A + Math.imul(Ut, Jt) | 0, M = M + Math.imul(ve, Ve) | 0, m = m + Math.imul(ve, Xt) | 0, m = m + Math.imul(We, Ve) | 0, A = A + Math.imul(We, Xt) | 0, M = M + Math.imul(le, L) | 0, m = m + Math.imul(le, F) | 0, m = m + Math.imul(Me, L) | 0, A = A + Math.imul(Me, F) | 0, M = M + Math.imul(X, U) | 0, m = m + Math.imul(X, Z) | 0, m = m + Math.imul(re, U) | 0, A = A + Math.imul(re, Z) | 0, M = M + Math.imul(z, te) | 0, m = m + Math.imul(z, fe) | 0, m = m + Math.imul(oe, te) | 0, A = A + Math.imul(oe, fe) | 0;
            var st = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, M = Math.imul(S, ge), m = Math.imul(S, Te), m = m + Math.imul(D, ge) | 0, A = Math.imul(D, Te), M = M + Math.imul(v, ot) | 0, m = m + Math.imul(v, Gt) | 0, m = m + Math.imul(u, ot) | 0, A = A + Math.imul(u, Gt) | 0, M = M + Math.imul(Ze, ht) | 0, m = m + Math.imul(Ze, tr) | 0, m = m + Math.imul(ft, ht) | 0, A = A + Math.imul(ft, tr) | 0, M = M + Math.imul(Ye, et) | 0, m = m + Math.imul(Ye, Lt) | 0, m = m + Math.imul(Xe, et) | 0, A = A + Math.imul(Xe, Lt) | 0, M = M + Math.imul(it, ct) | 0, m = m + Math.imul(it, Jt) | 0, m = m + Math.imul(At, ct) | 0, A = A + Math.imul(At, Jt) | 0, M = M + Math.imul(Ue, Ve) | 0, m = m + Math.imul(Ue, Xt) | 0, m = m + Math.imul(Ut, Ve) | 0, A = A + Math.imul(Ut, Xt) | 0, M = M + Math.imul(ve, L) | 0, m = m + Math.imul(ve, F) | 0, m = m + Math.imul(We, L) | 0, A = A + Math.imul(We, F) | 0, M = M + Math.imul(le, U) | 0, m = m + Math.imul(le, Z) | 0, m = m + Math.imul(Me, U) | 0, A = A + Math.imul(Me, Z) | 0, M = M + Math.imul(X, te) | 0, m = m + Math.imul(X, fe) | 0, m = m + Math.imul(re, te) | 0, A = A + Math.imul(re, fe) | 0;
            var rt = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, M = Math.imul(S, ot), m = Math.imul(S, Gt), m = m + Math.imul(D, ot) | 0, A = Math.imul(D, Gt), M = M + Math.imul(v, ht) | 0, m = m + Math.imul(v, tr) | 0, m = m + Math.imul(u, ht) | 0, A = A + Math.imul(u, tr) | 0, M = M + Math.imul(Ze, et) | 0, m = m + Math.imul(Ze, Lt) | 0, m = m + Math.imul(ft, et) | 0, A = A + Math.imul(ft, Lt) | 0, M = M + Math.imul(Ye, ct) | 0, m = m + Math.imul(Ye, Jt) | 0, m = m + Math.imul(Xe, ct) | 0, A = A + Math.imul(Xe, Jt) | 0, M = M + Math.imul(it, Ve) | 0, m = m + Math.imul(it, Xt) | 0, m = m + Math.imul(At, Ve) | 0, A = A + Math.imul(At, Xt) | 0, M = M + Math.imul(Ue, L) | 0, m = m + Math.imul(Ue, F) | 0, m = m + Math.imul(Ut, L) | 0, A = A + Math.imul(Ut, F) | 0, M = M + Math.imul(ve, U) | 0, m = m + Math.imul(ve, Z) | 0, m = m + Math.imul(We, U) | 0, A = A + Math.imul(We, Z) | 0, M = M + Math.imul(le, te) | 0, m = m + Math.imul(le, fe) | 0, m = m + Math.imul(Me, te) | 0, A = A + Math.imul(Me, fe) | 0;
            var Pe = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, M = Math.imul(S, ht), m = Math.imul(S, tr), m = m + Math.imul(D, ht) | 0, A = Math.imul(D, tr), M = M + Math.imul(v, et) | 0, m = m + Math.imul(v, Lt) | 0, m = m + Math.imul(u, et) | 0, A = A + Math.imul(u, Lt) | 0, M = M + Math.imul(Ze, ct) | 0, m = m + Math.imul(Ze, Jt) | 0, m = m + Math.imul(ft, ct) | 0, A = A + Math.imul(ft, Jt) | 0, M = M + Math.imul(Ye, Ve) | 0, m = m + Math.imul(Ye, Xt) | 0, m = m + Math.imul(Xe, Ve) | 0, A = A + Math.imul(Xe, Xt) | 0, M = M + Math.imul(it, L) | 0, m = m + Math.imul(it, F) | 0, m = m + Math.imul(At, L) | 0, A = A + Math.imul(At, F) | 0, M = M + Math.imul(Ue, U) | 0, m = m + Math.imul(Ue, Z) | 0, m = m + Math.imul(Ut, U) | 0, A = A + Math.imul(Ut, Z) | 0, M = M + Math.imul(ve, te) | 0, m = m + Math.imul(ve, fe) | 0, m = m + Math.imul(We, te) | 0, A = A + Math.imul(We, fe) | 0;
            var He = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, M = Math.imul(S, et), m = Math.imul(S, Lt), m = m + Math.imul(D, et) | 0, A = Math.imul(D, Lt), M = M + Math.imul(v, ct) | 0, m = m + Math.imul(v, Jt) | 0, m = m + Math.imul(u, ct) | 0, A = A + Math.imul(u, Jt) | 0, M = M + Math.imul(Ze, Ve) | 0, m = m + Math.imul(Ze, Xt) | 0, m = m + Math.imul(ft, Ve) | 0, A = A + Math.imul(ft, Xt) | 0, M = M + Math.imul(Ye, L) | 0, m = m + Math.imul(Ye, F) | 0, m = m + Math.imul(Xe, L) | 0, A = A + Math.imul(Xe, F) | 0, M = M + Math.imul(it, U) | 0, m = m + Math.imul(it, Z) | 0, m = m + Math.imul(At, U) | 0, A = A + Math.imul(At, Z) | 0, M = M + Math.imul(Ue, te) | 0, m = m + Math.imul(Ue, fe) | 0, m = m + Math.imul(Ut, te) | 0, A = A + Math.imul(Ut, fe) | 0;
            var Oe = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, M = Math.imul(S, ct), m = Math.imul(S, Jt), m = m + Math.imul(D, ct) | 0, A = Math.imul(D, Jt), M = M + Math.imul(v, Ve) | 0, m = m + Math.imul(v, Xt) | 0, m = m + Math.imul(u, Ve) | 0, A = A + Math.imul(u, Xt) | 0, M = M + Math.imul(Ze, L) | 0, m = m + Math.imul(Ze, F) | 0, m = m + Math.imul(ft, L) | 0, A = A + Math.imul(ft, F) | 0, M = M + Math.imul(Ye, U) | 0, m = m + Math.imul(Ye, Z) | 0, m = m + Math.imul(Xe, U) | 0, A = A + Math.imul(Xe, Z) | 0, M = M + Math.imul(it, te) | 0, m = m + Math.imul(it, fe) | 0, m = m + Math.imul(At, te) | 0, A = A + Math.imul(At, fe) | 0;
            var Le = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, M = Math.imul(S, Ve), m = Math.imul(S, Xt), m = m + Math.imul(D, Ve) | 0, A = Math.imul(D, Xt), M = M + Math.imul(v, L) | 0, m = m + Math.imul(v, F) | 0, m = m + Math.imul(u, L) | 0, A = A + Math.imul(u, F) | 0, M = M + Math.imul(Ze, U) | 0, m = m + Math.imul(Ze, Z) | 0, m = m + Math.imul(ft, U) | 0, A = A + Math.imul(ft, Z) | 0, M = M + Math.imul(Ye, te) | 0, m = m + Math.imul(Ye, fe) | 0, m = m + Math.imul(Xe, te) | 0, A = A + Math.imul(Xe, fe) | 0;
            var ze = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, M = Math.imul(S, L), m = Math.imul(S, F), m = m + Math.imul(D, L) | 0, A = Math.imul(D, F), M = M + Math.imul(v, U) | 0, m = m + Math.imul(v, Z) | 0, m = m + Math.imul(u, U) | 0, A = A + Math.imul(u, Z) | 0, M = M + Math.imul(Ze, te) | 0, m = m + Math.imul(Ze, fe) | 0, m = m + Math.imul(ft, te) | 0, A = A + Math.imul(ft, fe) | 0;
            var ke = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, M = Math.imul(S, U), m = Math.imul(S, Z), m = m + Math.imul(D, U) | 0, A = Math.imul(D, Z), M = M + Math.imul(v, te) | 0, m = m + Math.imul(v, fe) | 0, m = m + Math.imul(u, te) | 0, A = A + Math.imul(u, fe) | 0;
            var ie = (_ + M | 0) + ((m & 8191) << 13) | 0;
            _ = (A + (m >>> 13) | 0) + (ie >>> 26) | 0, ie &= 67108863, M = Math.imul(S, te), m = Math.imul(S, fe), m = m + Math.imul(D, te) | 0, A = Math.imul(D, fe);
            var se = (_ + M | 0) + ((m & 8191) << 13) | 0;
            return _ = (A + (m >>> 13) | 0) + (se >>> 26) | 0, se &= 67108863, C[0] = Ae, C[1] = ye, C[2] = dt, C[3] = Ne, C[4] = Ge, C[5] = Ke, C[6] = Je, C[7] = ut, C[8] = tt, C[9] = st, C[10] = rt, C[11] = Pe, C[12] = He, C[13] = Oe, C[14] = Le, C[15] = ze, C[16] = ke, C[17] = ie, C[18] = se, _ !== 0 && (C[19] = _, f.length++), f
        };
        Math.imul || (j = T);

        function V(H, w, p) {
            p.negative = w.negative ^ H.negative, p.length = H.length + w.length;
            for (var f = 0, h = 0, b = 0; b < p.length - 1; b++) {
                var C = h;
                h = 0;
                for (var _ = f & 67108863, M = Math.min(b, w.length - 1), m = Math.max(0, b - H.length + 1); m <= M; m++) {
                    var A = b - m,
                        x = H.words[A] | 0,
                        z = w.words[m] | 0,
                        oe = x * z,
                        k = oe & 67108863;
                    C = C + (oe / 67108864 | 0) | 0, k = k + _ | 0, _ = k & 67108863, C = C + (k >>> 26) | 0, h += C >>> 26, C &= 67108863
                }
                p.words[b] = _, f = C, C = h
            }
            return f !== 0 ? p.words[b] = f : p.length--, p.strip()
        }

        function P(H, w, p) {
            var f = new O;
            return f.mulp(H, w, p)
        }
        s.prototype.mulTo = function(w, p) {
            var f, h = this.length + w.length;
            return this.length === 10 && w.length === 10 ? f = j(this, w, p) : h < 63 ? f = T(this, w, p) : h < 1024 ? f = V(this, w, p) : f = P(this, w, p), f
        };

        function O(H, w) {
            this.x = H, this.y = w
        }
        O.prototype.makeRBT = function(w) {
            for (var p = new Array(w), f = s.prototype._countBits(w) - 1, h = 0; h < w; h++) p[h] = this.revBin(h, f, w);
            return p
        }, O.prototype.revBin = function(w, p, f) {
            if (w === 0 || w === f - 1) return w;
            for (var h = 0, b = 0; b < p; b++) h |= (w & 1) << p - b - 1, w >>= 1;
            return h
        }, O.prototype.permute = function(w, p, f, h, b, C) {
            for (var _ = 0; _ < C; _++) h[_] = p[w[_]], b[_] = f[w[_]]
        }, O.prototype.transform = function(w, p, f, h, b, C) {
            this.permute(C, w, p, f, h, b);
            for (var _ = 1; _ < b; _ <<= 1)
                for (var M = _ << 1, m = Math.cos(2 * Math.PI / M), A = Math.sin(2 * Math.PI / M), x = 0; x < b; x += M)
                    for (var z = m, oe = A, k = 0; k < _; k++) {
                        var X = f[x + k],
                            re = h[x + k],
                            ae = f[x + k + _],
                            le = h[x + k + _],
                            Me = z * ae - oe * le;
                        le = z * le + oe * ae, ae = Me, f[x + k] = X + ae, h[x + k] = re + le, f[x + k + _] = X - ae, h[x + k + _] = re - le, k !== M && (Me = m * z - A * oe, oe = m * oe + A * z, z = Me)
                    }
        }, O.prototype.guessLen13b = function(w, p) {
            var f = Math.max(p, w) | 1,
                h = f & 1,
                b = 0;
            for (f = f / 2 | 0; f; f = f >>> 1) b++;
            return 1 << b + 1 + h
        }, O.prototype.conjugate = function(w, p, f) {
            if (!(f <= 1))
                for (var h = 0; h < f / 2; h++) {
                    var b = w[h];
                    w[h] = w[f - h - 1], w[f - h - 1] = b, b = p[h], p[h] = -p[f - h - 1], p[f - h - 1] = -b
                }
        }, O.prototype.normalize13b = function(w, p) {
            for (var f = 0, h = 0; h < p / 2; h++) {
                var b = Math.round(w[2 * h + 1] / p) * 8192 + Math.round(w[2 * h] / p) + f;
                w[h] = b & 67108863, b < 67108864 ? f = 0 : f = b / 67108864 | 0
            }
            return w
        }, O.prototype.convert13b = function(w, p, f, h) {
            for (var b = 0, C = 0; C < p; C++) b = b + (w[C] | 0), f[2 * C] = b & 8191, b = b >>> 13, f[2 * C + 1] = b & 8191, b = b >>> 13;
            for (C = 2 * p; C < h; ++C) f[C] = 0;
            n(b === 0), n((b & -8192) === 0)
        }, O.prototype.stub = function(w) {
            for (var p = new Array(w), f = 0; f < w; f++) p[f] = 0;
            return p
        }, O.prototype.mulp = function(w, p, f) {
            var h = 2 * this.guessLen13b(w.length, p.length),
                b = this.makeRBT(h),
                C = this.stub(h),
                _ = new Array(h),
                M = new Array(h),
                m = new Array(h),
                A = new Array(h),
                x = new Array(h),
                z = new Array(h),
                oe = f.words;
            oe.length = h, this.convert13b(w.words, w.length, _, h), this.convert13b(p.words, p.length, A, h), this.transform(_, C, M, m, h, b), this.transform(A, C, x, z, h, b);
            for (var k = 0; k < h; k++) {
                var X = M[k] * x[k] - m[k] * z[k];
                m[k] = M[k] * z[k] + m[k] * x[k], M[k] = X
            }
            return this.conjugate(M, m, h), this.transform(M, m, oe, C, h, b), this.conjugate(oe, C, h), this.normalize13b(oe, h), f.negative = w.negative ^ p.negative, f.length = w.length + p.length, f.strip()
        }, s.prototype.mul = function(w) {
            var p = new s(null);
            return p.words = new Array(this.length + w.length), this.mulTo(w, p)
        }, s.prototype.mulf = function(w) {
            var p = new s(null);
            return p.words = new Array(this.length + w.length), P(this, w, p)
        }, s.prototype.imul = function(w) {
            return this.clone().mulTo(w, this)
        }, s.prototype.imuln = function(w) {
            n(typeof w == "number"), n(w < 67108864);
            for (var p = 0, f = 0; f < this.length; f++) {
                var h = (this.words[f] | 0) * w,
                    b = (h & 67108863) + (p & 67108863);
                p >>= 26, p += h / 67108864 | 0, p += b >>> 26, this.words[f] = b & 67108863
            }
            return p !== 0 && (this.words[f] = p, this.length++), this
        }, s.prototype.muln = function(w) {
            return this.clone().imuln(w)
        }, s.prototype.sqr = function() {
            return this.mul(this)
        }, s.prototype.isqr = function() {
            return this.imul(this.clone())
        }, s.prototype.pow = function(w) {
            var p = E(w);
            if (p.length === 0) return new s(1);
            for (var f = this, h = 0; h < p.length && p[h] === 0; h++, f = f.sqr());
            if (++h < p.length)
                for (var b = f.sqr(); h < p.length; h++, b = b.sqr()) p[h] !== 0 && (f = f.mul(b));
            return f
        }, s.prototype.iushln = function(w) {
            n(typeof w == "number" && w >= 0);
            var p = w % 26,
                f = (w - p) / 26,
                h = 67108863 >>> 26 - p << 26 - p,
                b;
            if (p !== 0) {
                var C = 0;
                for (b = 0; b < this.length; b++) {
                    var _ = this.words[b] & h,
                        M = (this.words[b] | 0) - _ << p;
                    this.words[b] = M | C, C = _ >>> 26 - p
                }
                C && (this.words[b] = C, this.length++)
            }
            if (f !== 0) {
                for (b = this.length - 1; b >= 0; b--) this.words[b + f] = this.words[b];
                for (b = 0; b < f; b++) this.words[b] = 0;
                this.length += f
            }
            return this.strip()
        }, s.prototype.ishln = function(w) {
            return n(this.negative === 0), this.iushln(w)
        }, s.prototype.iushrn = function(w, p, f) {
            n(typeof w == "number" && w >= 0);
            var h;
            p ? h = (p - p % 26) / 26 : h = 0;
            var b = w % 26,
                C = Math.min((w - b) / 26, this.length),
                _ = 67108863 ^ 67108863 >>> b << b,
                M = f;
            if (h -= C, h = Math.max(0, h), M) {
                for (var m = 0; m < C; m++) M.words[m] = this.words[m];
                M.length = C
            }
            if (C !== 0)
                if (this.length > C)
                    for (this.length -= C, m = 0; m < this.length; m++) this.words[m] = this.words[m + C];
                else this.words[0] = 0, this.length = 1;
            var A = 0;
            for (m = this.length - 1; m >= 0 && (A !== 0 || m >= h); m--) {
                var x = this.words[m] | 0;
                this.words[m] = A << 26 - b | x >>> b, A = x & _
            }
            return M && A !== 0 && (M.words[M.length++] = A), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip()
        }, s.prototype.ishrn = function(w, p, f) {
            return n(this.negative === 0), this.iushrn(w, p, f)
        }, s.prototype.shln = function(w) {
            return this.clone().ishln(w)
        }, s.prototype.ushln = function(w) {
            return this.clone().iushln(w)
        }, s.prototype.shrn = function(w) {
            return this.clone().ishrn(w)
        }, s.prototype.ushrn = function(w) {
            return this.clone().iushrn(w)
        }, s.prototype.testn = function(w) {
            n(typeof w == "number" && w >= 0);
            var p = w % 26,
                f = (w - p) / 26,
                h = 1 << p;
            if (this.length <= f) return !1;
            var b = this.words[f];
            return !!(b & h)
        }, s.prototype.imaskn = function(w) {
            n(typeof w == "number" && w >= 0);
            var p = w % 26,
                f = (w - p) / 26;
            if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f) return this;
            if (p !== 0 && f++, this.length = Math.min(f, this.length), p !== 0) {
                var h = 67108863 ^ 67108863 >>> p << p;
                this.words[this.length - 1] &= h
            }
            return this.strip()
        }, s.prototype.maskn = function(w) {
            return this.clone().imaskn(w)
        }, s.prototype.iaddn = function(w) {
            return n(typeof w == "number"), n(w < 67108864), w < 0 ? this.isubn(-w) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < w ? (this.words[0] = w - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(w), this.negative = 1, this) : this._iaddn(w)
        }, s.prototype._iaddn = function(w) {
            this.words[0] += w;
            for (var p = 0; p < this.length && this.words[p] >= 67108864; p++) this.words[p] -= 67108864, p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
            return this.length = Math.max(this.length, p + 1), this
        }, s.prototype.isubn = function(w) {
            if (n(typeof w == "number"), n(w < 67108864), w < 0) return this.iaddn(-w);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(w), this.negative = 1, this;
            if (this.words[0] -= w, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else
                for (var p = 0; p < this.length && this.words[p] < 0; p++) this.words[p] += 67108864, this.words[p + 1] -= 1;
            return this.strip()
        }, s.prototype.addn = function(w) {
            return this.clone().iaddn(w)
        }, s.prototype.subn = function(w) {
            return this.clone().isubn(w)
        }, s.prototype.iabs = function() {
            return this.negative = 0, this
        }, s.prototype.abs = function() {
            return this.clone().iabs()
        }, s.prototype._ishlnsubmul = function(w, p, f) {
            var h = w.length + f,
                b;
            this._expand(h);
            var C, _ = 0;
            for (b = 0; b < w.length; b++) {
                C = (this.words[b + f] | 0) + _;
                var M = (w.words[b] | 0) * p;
                C -= M & 67108863, _ = (C >> 26) - (M / 67108864 | 0), this.words[b + f] = C & 67108863
            }
            for (; b < this.length - f; b++) C = (this.words[b + f] | 0) + _, _ = C >> 26, this.words[b + f] = C & 67108863;
            if (_ === 0) return this.strip();
            for (n(_ === -1), _ = 0, b = 0; b < this.length; b++) C = -(this.words[b] | 0) + _, _ = C >> 26, this.words[b] = C & 67108863;
            return this.negative = 1, this.strip()
        }, s.prototype._wordDiv = function(w, p) {
            var f = this.length - w.length,
                h = this.clone(),
                b = w,
                C = b.words[b.length - 1] | 0,
                _ = this._countBits(C);
            f = 26 - _, f !== 0 && (b = b.ushln(f), h.iushln(f), C = b.words[b.length - 1] | 0);
            var M = h.length - b.length,
                m;
            if (p !== "mod") {
                m = new s(null), m.length = M + 1, m.words = new Array(m.length);
                for (var A = 0; A < m.length; A++) m.words[A] = 0
            }
            var x = h.clone()._ishlnsubmul(b, 1, M);
            x.negative === 0 && (h = x, m && (m.words[M] = 1));
            for (var z = M - 1; z >= 0; z--) {
                var oe = (h.words[b.length + z] | 0) * 67108864 + (h.words[b.length + z - 1] | 0);
                for (oe = Math.min(oe / C | 0, 67108863), h._ishlnsubmul(b, oe, z); h.negative !== 0;) oe--, h.negative = 0, h._ishlnsubmul(b, 1, z), h.isZero() || (h.negative ^= 1);
                m && (m.words[z] = oe)
            }
            return m && m.strip(), h.strip(), p !== "div" && f !== 0 && h.iushrn(f), {
                div: m || null,
                mod: h
            }
        }, s.prototype.divmod = function(w, p, f) {
            if (n(!w.isZero()), this.isZero()) return {
                div: new s(0),
                mod: new s(0)
            };
            var h, b, C;
            return this.negative !== 0 && w.negative === 0 ? (C = this.neg().divmod(w, p), p !== "mod" && (h = C.div.neg()), p !== "div" && (b = C.mod.neg(), f && b.negative !== 0 && b.iadd(w)), {
                div: h,
                mod: b
            }) : this.negative === 0 && w.negative !== 0 ? (C = this.divmod(w.neg(), p), p !== "mod" && (h = C.div.neg()), {
                div: h,
                mod: C.mod
            }) : (this.negative & w.negative) !== 0 ? (C = this.neg().divmod(w.neg(), p), p !== "div" && (b = C.mod.neg(), f && b.negative !== 0 && b.isub(w)), {
                div: C.div,
                mod: b
            }) : w.length > this.length || this.cmp(w) < 0 ? {
                div: new s(0),
                mod: this
            } : w.length === 1 ? p === "div" ? {
                div: this.divn(w.words[0]),
                mod: null
            } : p === "mod" ? {
                div: null,
                mod: new s(this.modn(w.words[0]))
            } : {
                div: this.divn(w.words[0]),
                mod: new s(this.modn(w.words[0]))
            } : this._wordDiv(w, p)
        }, s.prototype.div = function(w) {
            return this.divmod(w, "div", !1).div
        }, s.prototype.mod = function(w) {
            return this.divmod(w, "mod", !1).mod
        }, s.prototype.umod = function(w) {
            return this.divmod(w, "mod", !0).mod
        }, s.prototype.divRound = function(w) {
            var p = this.divmod(w);
            if (p.mod.isZero()) return p.div;
            var f = p.div.negative !== 0 ? p.mod.isub(w) : p.mod,
                h = w.ushrn(1),
                b = w.andln(1),
                C = f.cmp(h);
            return C < 0 || b === 1 && C === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1)
        }, s.prototype.modn = function(w) {
            n(w <= 67108863);
            for (var p = (1 << 26) % w, f = 0, h = this.length - 1; h >= 0; h--) f = (p * f + (this.words[h] | 0)) % w;
            return f
        }, s.prototype.idivn = function(w) {
            n(w <= 67108863);
            for (var p = 0, f = this.length - 1; f >= 0; f--) {
                var h = (this.words[f] | 0) + p * 67108864;
                this.words[f] = h / w | 0, p = h % w
            }
            return this.strip()
        }, s.prototype.divn = function(w) {
            return this.clone().idivn(w)
        }, s.prototype.egcd = function(w) {
            n(w.negative === 0), n(!w.isZero());
            var p = this,
                f = w.clone();
            p.negative !== 0 ? p = p.umod(w) : p = p.clone();
            for (var h = new s(1), b = new s(0), C = new s(0), _ = new s(1), M = 0; p.isEven() && f.isEven();) p.iushrn(1), f.iushrn(1), ++M;
            for (var m = f.clone(), A = p.clone(); !p.isZero();) {
                for (var x = 0, z = 1;
                    (p.words[0] & z) === 0 && x < 26; ++x, z <<= 1);
                if (x > 0)
                    for (p.iushrn(x); x-- > 0;)(h.isOdd() || b.isOdd()) && (h.iadd(m), b.isub(A)), h.iushrn(1), b.iushrn(1);
                for (var oe = 0, k = 1;
                    (f.words[0] & k) === 0 && oe < 26; ++oe, k <<= 1);
                if (oe > 0)
                    for (f.iushrn(oe); oe-- > 0;)(C.isOdd() || _.isOdd()) && (C.iadd(m), _.isub(A)), C.iushrn(1), _.iushrn(1);
                p.cmp(f) >= 0 ? (p.isub(f), h.isub(C), b.isub(_)) : (f.isub(p), C.isub(h), _.isub(b))
            }
            return {
                a: C,
                b: _,
                gcd: f.iushln(M)
            }
        }, s.prototype._invmp = function(w) {
            n(w.negative === 0), n(!w.isZero());
            var p = this,
                f = w.clone();
            p.negative !== 0 ? p = p.umod(w) : p = p.clone();
            for (var h = new s(1), b = new s(0), C = f.clone(); p.cmpn(1) > 0 && f.cmpn(1) > 0;) {
                for (var _ = 0, M = 1;
                    (p.words[0] & M) === 0 && _ < 26; ++_, M <<= 1);
                if (_ > 0)
                    for (p.iushrn(_); _-- > 0;) h.isOdd() && h.iadd(C), h.iushrn(1);
                for (var m = 0, A = 1;
                    (f.words[0] & A) === 0 && m < 26; ++m, A <<= 1);
                if (m > 0)
                    for (f.iushrn(m); m-- > 0;) b.isOdd() && b.iadd(C), b.iushrn(1);
                p.cmp(f) >= 0 ? (p.isub(f), h.isub(b)) : (f.isub(p), b.isub(h))
            }
            var x;
            return p.cmpn(1) === 0 ? x = h : x = b, x.cmpn(0) < 0 && x.iadd(w), x
        }, s.prototype.gcd = function(w) {
            if (this.isZero()) return w.abs();
            if (w.isZero()) return this.abs();
            var p = this.clone(),
                f = w.clone();
            p.negative = 0, f.negative = 0;
            for (var h = 0; p.isEven() && f.isEven(); h++) p.iushrn(1), f.iushrn(1);
            do {
                for (; p.isEven();) p.iushrn(1);
                for (; f.isEven();) f.iushrn(1);
                var b = p.cmp(f);
                if (b < 0) {
                    var C = p;
                    p = f, f = C
                } else if (b === 0 || f.cmpn(1) === 0) break;
                p.isub(f)
            } while (!0);
            return f.iushln(h)
        }, s.prototype.invm = function(w) {
            return this.egcd(w).a.umod(w)
        }, s.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }, s.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }, s.prototype.andln = function(w) {
            return this.words[0] & w
        }, s.prototype.bincn = function(w) {
            n(typeof w == "number");
            var p = w % 26,
                f = (w - p) / 26,
                h = 1 << p;
            if (this.length <= f) return this._expand(f + 1), this.words[f] |= h, this;
            for (var b = h, C = f; b !== 0 && C < this.length; C++) {
                var _ = this.words[C] | 0;
                _ += b, b = _ >>> 26, _ &= 67108863, this.words[C] = _
            }
            return b !== 0 && (this.words[C] = b, this.length++), this
        }, s.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }, s.prototype.cmpn = function(w) {
            var p = w < 0;
            if (this.negative !== 0 && !p) return -1;
            if (this.negative === 0 && p) return 1;
            this.strip();
            var f;
            if (this.length > 1) f = 1;
            else {
                p && (w = -w), n(w <= 67108863, "Number is too big");
                var h = this.words[0] | 0;
                f = h === w ? 0 : h < w ? -1 : 1
            }
            return this.negative !== 0 ? -f | 0 : f
        }, s.prototype.cmp = function(w) {
            if (this.negative !== 0 && w.negative === 0) return -1;
            if (this.negative === 0 && w.negative !== 0) return 1;
            var p = this.ucmp(w);
            return this.negative !== 0 ? -p | 0 : p
        }, s.prototype.ucmp = function(w) {
            if (this.length > w.length) return 1;
            if (this.length < w.length) return -1;
            for (var p = 0, f = this.length - 1; f >= 0; f--) {
                var h = this.words[f] | 0,
                    b = w.words[f] | 0;
                if (h !== b) {
                    h < b ? p = -1 : h > b && (p = 1);
                    break
                }
            }
            return p
        }, s.prototype.gtn = function(w) {
            return this.cmpn(w) === 1
        }, s.prototype.gt = function(w) {
            return this.cmp(w) === 1
        }, s.prototype.gten = function(w) {
            return this.cmpn(w) >= 0
        }, s.prototype.gte = function(w) {
            return this.cmp(w) >= 0
        }, s.prototype.ltn = function(w) {
            return this.cmpn(w) === -1
        }, s.prototype.lt = function(w) {
            return this.cmp(w) === -1
        }, s.prototype.lten = function(w) {
            return this.cmpn(w) <= 0
        }, s.prototype.lte = function(w) {
            return this.cmp(w) <= 0
        }, s.prototype.eqn = function(w) {
            return this.cmpn(w) === 0
        }, s.prototype.eq = function(w) {
            return this.cmp(w) === 0
        }, s.red = function(w) {
            return new pe(w)
        }, s.prototype.toRed = function(w) {
            return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), w.convertTo(this)._forceRed(w)
        }, s.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, s.prototype._forceRed = function(w) {
            return this.red = w, this
        }, s.prototype.forceRed = function(w) {
            return n(!this.red, "Already a number in reduction context"), this._forceRed(w)
        }, s.prototype.redAdd = function(w) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, w)
        }, s.prototype.redIAdd = function(w) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, w)
        }, s.prototype.redSub = function(w) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, w)
        }, s.prototype.redISub = function(w) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, w)
        }, s.prototype.redShl = function(w) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, w)
        }, s.prototype.redMul = function(w) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, w), this.red.mul(this, w)
        }, s.prototype.redIMul = function(w) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, w), this.red.imul(this, w)
        }, s.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, s.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, s.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, s.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, s.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, s.prototype.redPow = function(w) {
            return n(this.red && !w.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, w)
        };
        var R = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };

        function q(H, w) {
            this.name = H, this.p = new s(w, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }
        q.prototype._tmp = function() {
            var w = new s(null);
            return w.words = new Array(Math.ceil(this.n / 13)), w
        }, q.prototype.ireduce = function(w) {
            var p = w,
                f;
            do this.split(p, this.tmp), p = this.imulK(p), p = p.iadd(this.tmp), f = p.bitLength(); while (f > this.n);
            var h = f < this.n ? -1 : p.ucmp(this.p);
            return h === 0 ? (p.words[0] = 0, p.length = 1) : h > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(), p
        }, q.prototype.split = function(w, p) {
            w.iushrn(this.n, 0, p)
        }, q.prototype.imulK = function(w) {
            return w.imul(this.k)
        };

        function W() {
            q.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(W, q), W.prototype.split = function(w, p) {
            for (var f = 4194303, h = Math.min(w.length, 9), b = 0; b < h; b++) p.words[b] = w.words[b];
            if (p.length = h, w.length <= 9) {
                w.words[0] = 0, w.length = 1;
                return
            }
            var C = w.words[9];
            for (p.words[p.length++] = C & f, b = 10; b < w.length; b++) {
                var _ = w.words[b] | 0;
                w.words[b - 10] = (_ & f) << 4 | C >>> 22, C = _
            }
            C >>>= 22, w.words[b - 10] = C, C === 0 && w.length > 10 ? w.length -= 10 : w.length -= 9
        }, W.prototype.imulK = function(w) {
            w.words[w.length] = 0, w.words[w.length + 1] = 0, w.length += 2;
            for (var p = 0, f = 0; f < w.length; f++) {
                var h = w.words[f] | 0;
                p += h * 977, w.words[f] = p & 67108863, p = h * 64 + (p / 67108864 | 0)
            }
            return w.words[w.length - 1] === 0 && (w.length--, w.words[w.length - 1] === 0 && w.length--), w
        };

        function Y() {
            q.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(Y, q);

        function G() {
            q.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(G, q);

        function J() {
            q.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(J, q), J.prototype.imulK = function(w) {
            for (var p = 0, f = 0; f < w.length; f++) {
                var h = (w.words[f] | 0) * 19 + p,
                    b = h & 67108863;
                h >>>= 26, w.words[f] = b, p = h
            }
            return p !== 0 && (w.words[w.length++] = p), w
        }, s._prime = function(w) {
            if (R[w]) return R[w];
            var p;
            if (w === "k256") p = new W;
            else if (w === "p224") p = new Y;
            else if (w === "p192") p = new G;
            else if (w === "p25519") p = new J;
            else throw new Error("Unknown prime " + w);
            return R[w] = p, p
        };

        function pe(H) {
            if (typeof H == "string") {
                var w = s._prime(H);
                this.m = w.p, this.prime = w
            } else n(H.gtn(1), "modulus must be greater than 1"), this.m = H, this.prime = null
        }
        pe.prototype._verify1 = function(w) {
            n(w.negative === 0, "red works only with positives"), n(w.red, "red works only with red numbers")
        }, pe.prototype._verify2 = function(w, p) {
            n((w.negative | p.negative) === 0, "red works only with positives"), n(w.red && w.red === p.red, "red works only with red numbers")
        }, pe.prototype.imod = function(w) {
            return this.prime ? this.prime.ireduce(w)._forceRed(this) : w.umod(this.m)._forceRed(this)
        }, pe.prototype.neg = function(w) {
            return w.isZero() ? w.clone() : this.m.sub(w)._forceRed(this)
        }, pe.prototype.add = function(w, p) {
            this._verify2(w, p);
            var f = w.add(p);
            return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this)
        }, pe.prototype.iadd = function(w, p) {
            this._verify2(w, p);
            var f = w.iadd(p);
            return f.cmp(this.m) >= 0 && f.isub(this.m), f
        }, pe.prototype.sub = function(w, p) {
            this._verify2(w, p);
            var f = w.sub(p);
            return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this)
        }, pe.prototype.isub = function(w, p) {
            this._verify2(w, p);
            var f = w.isub(p);
            return f.cmpn(0) < 0 && f.iadd(this.m), f
        }, pe.prototype.shl = function(w, p) {
            return this._verify1(w), this.imod(w.ushln(p))
        }, pe.prototype.imul = function(w, p) {
            return this._verify2(w, p), this.imod(w.imul(p))
        }, pe.prototype.mul = function(w, p) {
            return this._verify2(w, p), this.imod(w.mul(p))
        }, pe.prototype.isqr = function(w) {
            return this.imul(w, w.clone())
        }, pe.prototype.sqr = function(w) {
            return this.mul(w, w)
        }, pe.prototype.sqrt = function(w) {
            if (w.isZero()) return w.clone();
            var p = this.m.andln(3);
            if (n(p % 2 === 1), p === 3) {
                var f = this.m.add(new s(1)).iushrn(2);
                return this.pow(w, f)
            }
            for (var h = this.m.subn(1), b = 0; !h.isZero() && h.andln(1) === 0;) b++, h.iushrn(1);
            n(!h.isZero());
            var C = new s(1).toRed(this),
                _ = C.redNeg(),
                M = this.m.subn(1).iushrn(1),
                m = this.m.bitLength();
            for (m = new s(2 * m * m).toRed(this); this.pow(m, M).cmp(_) !== 0;) m.redIAdd(_);
            for (var A = this.pow(m, h), x = this.pow(w, h.addn(1).iushrn(1)), z = this.pow(w, h), oe = b; z.cmp(C) !== 0;) {
                for (var k = z, X = 0; k.cmp(C) !== 0; X++) k = k.redSqr();
                n(X < oe);
                var re = this.pow(A, new s(1).iushln(oe - X - 1));
                x = x.redMul(re), A = re.redSqr(), z = z.redMul(A), oe = X
            }
            return x
        }, pe.prototype.invm = function(w) {
            var p = w._invmp(this.m);
            return p.negative !== 0 ? (p.negative = 0, this.imod(p).redNeg()) : this.imod(p)
        }, pe.prototype.pow = function(w, p) {
            if (p.isZero()) return new s(1).toRed(this);
            if (p.cmpn(1) === 0) return w.clone();
            var f = 4,
                h = new Array(1 << f);
            h[0] = new s(1).toRed(this), h[1] = w;
            for (var b = 2; b < h.length; b++) h[b] = this.mul(h[b - 1], w);
            var C = h[0],
                _ = 0,
                M = 0,
                m = p.bitLength() % 26;
            for (m === 0 && (m = 26), b = p.length - 1; b >= 0; b--) {
                for (var A = p.words[b], x = m - 1; x >= 0; x--) {
                    var z = A >> x & 1;
                    if (C !== h[0] && (C = this.sqr(C)), z === 0 && _ === 0) {
                        M = 0;
                        continue
                    }
                    _ <<= 1, _ |= z, M++, !(M !== f && (b !== 0 || x !== 0)) && (C = this.mul(C, h[_]), M = 0, _ = 0)
                }
                m = 26
            }
            return C
        }, pe.prototype.convertTo = function(w) {
            var p = w.umod(this.m);
            return p === w ? p.clone() : p
        }, pe.prototype.convertFrom = function(w) {
            var p = w.clone();
            return p.red = null, p
        }, s.mont = function(w) {
            return new we(w)
        };

        function we(H) {
            pe.call(this, H), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }
        i(we, pe), we.prototype.convertTo = function(w) {
            return this.imod(w.ushln(this.shift))
        }, we.prototype.convertFrom = function(w) {
            var p = this.imod(w.mul(this.rinv));
            return p.red = null, p
        }, we.prototype.imul = function(w, p) {
            if (w.isZero() || p.isZero()) return w.words[0] = 0, w.length = 1, w;
            var f = w.imul(p),
                h = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                b = f.isub(h).iushrn(this.shift),
                C = b;
            return b.cmp(this.m) >= 0 ? C = b.isub(this.m) : b.cmpn(0) < 0 && (C = b.iadd(this.m)), C._forceRed(this)
        }, we.prototype.mul = function(w, p) {
            if (w.isZero() || p.isZero()) return new s(0)._forceRed(this);
            var f = w.mul(p),
                h = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                b = f.isub(h).iushrn(this.shift),
                C = b;
            return b.cmp(this.m) >= 0 ? C = b.isub(this.m) : b.cmpn(0) < 0 && (C = b.iadd(this.m)), C._forceRed(this)
        }, we.prototype.invm = function(w) {
            var p = this.imod(w._invmp(this.m).mul(this.r2));
            return p._forceRed(this)
        }
    })(t, zn)
})(es);
var Uo = H2;

function H2(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
H2.equal = function(e, r, n) {
    if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r)
};
var S1 = {};
(function(t) {
    var e = t;

    function r(s, o) {
        if (Array.isArray(s)) return s.slice();
        if (!s) return [];
        var a = [];
        if (typeof s != "string") {
            for (var c = 0; c < s.length; c++) a[c] = s[c] | 0;
            return a
        }
        if (o === "hex") {
            s = s.replace(/[^a-z0-9]+/ig, ""), s.length % 2 !== 0 && (s = "0" + s);
            for (var c = 0; c < s.length; c += 2) a.push(parseInt(s[c] + s[c + 1], 16))
        } else
            for (var c = 0; c < s.length; c++) {
                var d = s.charCodeAt(c),
                    y = d >> 8,
                    I = d & 255;
                y ? a.push(y, I) : a.push(I)
            }
        return a
    }
    e.toArray = r;

    function n(s) {
        return s.length === 1 ? "0" + s : s
    }
    e.zero2 = n;

    function i(s) {
        for (var o = "", a = 0; a < s.length; a++) o += n(s[a].toString(16));
        return o
    }
    e.toHex = i, e.encode = function(o, a) {
        return a === "hex" ? i(o) : o
    }
})(S1);
(function(t) {
    var e = t,
        r = es.exports,
        n = Uo,
        i = S1;
    e.assert = n, e.toArray = i.toArray, e.zero2 = i.zero2, e.toHex = i.toHex, e.encode = i.encode;

    function s(y, I, N) {
        var E = new Array(Math.max(y.bitLength(), N) + 1);
        E.fill(0);
        for (var T = 1 << I + 1, j = y.clone(), V = 0; V < E.length; V++) {
            var P, O = j.andln(T - 1);
            j.isOdd() ? (O > (T >> 1) - 1 ? P = (T >> 1) - O : P = O, j.isubn(P)) : P = 0, E[V] = P, j.iushrn(1)
        }
        return E
    }
    e.getNAF = s;

    function o(y, I) {
        var N = [
            [],
            []
        ];
        y = y.clone(), I = I.clone();
        for (var E = 0, T = 0, j; y.cmpn(-E) > 0 || I.cmpn(-T) > 0;) {
            var V = y.andln(3) + E & 3,
                P = I.andln(3) + T & 3;
            V === 3 && (V = -1), P === 3 && (P = -1);
            var O;
            (V & 1) === 0 ? O = 0 : (j = y.andln(7) + E & 7, (j === 3 || j === 5) && P === 2 ? O = -V : O = V), N[0].push(O);
            var R;
            (P & 1) === 0 ? R = 0 : (j = I.andln(7) + T & 7, (j === 3 || j === 5) && V === 2 ? R = -P : R = P), N[1].push(R), 2 * E === O + 1 && (E = 1 - E), 2 * T === R + 1 && (T = 1 - T), y.iushrn(1), I.iushrn(1)
        }
        return N
    }
    e.getJSF = o;

    function a(y, I, N) {
        var E = "_" + I;
        y.prototype[I] = function() {
            return this[E] !== void 0 ? this[E] : this[E] = N.call(this)
        }
    }
    e.cachedProperty = a;

    function c(y) {
        return typeof y == "string" ? e.toArray(y, "hex") : y
    }
    e.parseBytes = c;

    function d(y) {
        return new r(y, "hex", "le")
    }
    e.intFromLE = d
})(qn);
var lh = {
        exports: {}
    },
    g0;
lh.exports = function(e) {
    return g0 || (g0 = new Qs(null)), g0.generate(e)
};

function Qs(t) {
    this.rand = t
}
lh.exports.Rand = Qs;
Qs.prototype.generate = function(e) {
    return this._rand(e)
};
Qs.prototype._rand = function(e) {
    if (this.rand.getBytes) return this.rand.getBytes(e);
    for (var r = new Uint8Array(e), n = 0; n < r.length; n++) r[n] = this.rand.getByte();
    return r
};
if (typeof self == "object") self.crypto && self.crypto.getRandomValues ? Qs.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.crypto.getRandomValues(r), r
} : self.msCrypto && self.msCrypto.getRandomValues ? Qs.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.msCrypto.getRandomValues(r), r
} : typeof window == "object" && (Qs.prototype._rand = function() {
    throw new Error("Not implemented yet")
});
else try {
    var wv = require("crypto");
    if (typeof wv.randomBytes != "function") throw new Error("Not supported");
    Qs.prototype._rand = function(e) {
        return wv.randomBytes(e)
    }
} catch {}
var M1 = {},
    uo = es.exports,
    Il = qn,
    yc = Il.getNAF,
    WS = Il.getJSF,
    wc = Il.assert;

function ao(t, e) {
    this.type = t, this.p = new uo(e.p, 16), this.red = e.prime ? uo.red(e.prime) : uo.mont(this.p), this.zero = new uo(0).toRed(this.red), this.one = new uo(1).toRed(this.red), this.two = new uo(2).toRed(this.red), this.n = e.n && new uo(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
}
var fh = ao;
ao.prototype.point = function() {
    throw new Error("Not implemented")
};
ao.prototype.validate = function() {
    throw new Error("Not implemented")
};
ao.prototype._fixedNafMul = function(e, r) {
    wc(e.precomputed);
    var n = e._getDoubles(),
        i = yc(r, 1, this._bitLength),
        s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
    s /= 3;
    var o = [],
        a, c;
    for (a = 0; a < i.length; a += n.step) {
        c = 0;
        for (var d = a + n.step - 1; d >= a; d--) c = (c << 1) + i[d];
        o.push(c)
    }
    for (var y = this.jpoint(null, null, null), I = this.jpoint(null, null, null), N = s; N > 0; N--) {
        for (a = 0; a < o.length; a++) c = o[a], c === N ? I = I.mixedAdd(n.points[a]) : c === -N && (I = I.mixedAdd(n.points[a].neg()));
        y = y.add(I)
    }
    return y.toP()
};
ao.prototype._wnafMul = function(e, r) {
    var n = 4,
        i = e._getNAFPoints(n);
    n = i.wnd;
    for (var s = i.points, o = yc(r, n, this._bitLength), a = this.jpoint(null, null, null), c = o.length - 1; c >= 0; c--) {
        for (var d = 0; c >= 0 && o[c] === 0; c--) d++;
        if (c >= 0 && d++, a = a.dblp(d), c < 0) break;
        var y = o[c];
        wc(y !== 0), e.type === "affine" ? y > 0 ? a = a.mixedAdd(s[y - 1 >> 1]) : a = a.mixedAdd(s[-y - 1 >> 1].neg()) : y > 0 ? a = a.add(s[y - 1 >> 1]) : a = a.add(s[-y - 1 >> 1].neg())
    }
    return e.type === "affine" ? a.toP() : a
};
ao.prototype._wnafMulAdd = function(e, r, n, i, s) {
    var o = this._wnafT1,
        a = this._wnafT2,
        c = this._wnafT3,
        d = 0,
        y, I, N;
    for (y = 0; y < i; y++) {
        N = r[y];
        var E = N._getNAFPoints(e);
        o[y] = E.wnd, a[y] = E.points
    }
    for (y = i - 1; y >= 1; y -= 2) {
        var T = y - 1,
            j = y;
        if (o[T] !== 1 || o[j] !== 1) {
            c[T] = yc(n[T], o[T], this._bitLength), c[j] = yc(n[j], o[j], this._bitLength), d = Math.max(c[T].length, d), d = Math.max(c[j].length, d);
            continue
        }
        var V = [r[T], null, null, r[j]];
        r[T].y.cmp(r[j].y) === 0 ? (V[1] = r[T].add(r[j]), V[2] = r[T].toJ().mixedAdd(r[j].neg())) : r[T].y.cmp(r[j].y.redNeg()) === 0 ? (V[1] = r[T].toJ().mixedAdd(r[j]), V[2] = r[T].add(r[j].neg())) : (V[1] = r[T].toJ().mixedAdd(r[j]), V[2] = r[T].toJ().mixedAdd(r[j].neg()));
        var P = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            O = WS(n[T], n[j]);
        for (d = Math.max(O[0].length, d), c[T] = new Array(d), c[j] = new Array(d), I = 0; I < d; I++) {
            var R = O[0][I] | 0,
                q = O[1][I] | 0;
            c[T][I] = P[(R + 1) * 3 + (q + 1)], c[j][I] = 0, a[T] = V
        }
    }
    var W = this.jpoint(null, null, null),
        Y = this._wnafT4;
    for (y = d; y >= 0; y--) {
        for (var G = 0; y >= 0;) {
            var J = !0;
            for (I = 0; I < i; I++) Y[I] = c[I][y] | 0, Y[I] !== 0 && (J = !1);
            if (!J) break;
            G++, y--
        }
        if (y >= 0 && G++, W = W.dblp(G), y < 0) break;
        for (I = 0; I < i; I++) {
            var pe = Y[I];
            pe !== 0 && (pe > 0 ? N = a[I][pe - 1 >> 1] : pe < 0 && (N = a[I][-pe - 1 >> 1].neg()), N.type === "affine" ? W = W.mixedAdd(N) : W = W.add(N))
        }
    }
    for (y = 0; y < i; y++) a[y] = null;
    return s ? W : W.toP()
};

function fi(t, e) {
    this.curve = t, this.type = e, this.precomputed = null
}
ao.BasePoint = fi;
fi.prototype.eq = function() {
    throw new Error("Not implemented")
};
fi.prototype.validate = function() {
    return this.curve.validate(this)
};
ao.prototype.decodePoint = function(e, r) {
    e = Il.toArray(e, r);
    var n = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
        e[0] === 6 ? wc(e[e.length - 1] % 2 === 0) : e[0] === 7 && wc(e[e.length - 1] % 2 === 1);
        var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
        return i
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n) return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
    throw new Error("Unknown point format")
};
fi.prototype.encodeCompressed = function(e) {
    return this.encode(e, !0)
};
fi.prototype._encode = function(e) {
    var r = this.curve.p.byteLength(),
        n = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r))
};
fi.prototype.encode = function(e, r) {
    return Il.encode(this._encode(r), e)
};
fi.prototype.precompute = function(e) {
    if (this.precomputed) return this;
    var r = {
        doubles: null,
        naf: null,
        beta: null
    };
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this
};
fi.prototype._hasDoubles = function(e) {
    if (!this.precomputed) return !1;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1
};
fi.prototype._getDoubles = function(e, r) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    for (var n = [this], i = this, s = 0; s < r; s += e) {
        for (var o = 0; o < e; o++) i = i.dbl();
        n.push(i)
    }
    return {
        step: e,
        points: n
    }
};
fi.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++) r[s] = r[s - 1].add(i);
    return {
        wnd: e,
        points: r
    }
};
fi.prototype._getBeta = function() {
    return null
};
fi.prototype.dblp = function(e) {
    for (var r = this, n = 0; n < e; n++) r = r.dbl();
    return r
};
var _a = {
    exports: {}
};
typeof Object.create == "function" ? _a.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }))
} : _a.exports = function(e, r) {
    if (r) {
        e.super_ = r;
        var n = function() {};
        n.prototype = r.prototype, e.prototype = new n, e.prototype.constructor = e
    }
};
var VS = qn,
    _r = es.exports,
    E1 = _a.exports,
    qa = fh,
    GS = VS.assert;

function ci(t) {
    qa.call(this, "short", t), this.a = new _r(t.a, 16).toRed(this.red), this.b = new _r(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
}
E1(ci, qa);
var YS = ci;
ci.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, n;
        if (e.beta) r = new _r(e.beta, 16).toRed(this.red);
        else {
            var i = this._getEndoRoots(this.p);
            r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red)
        }
        if (e.lambda) n = new _r(e.lambda, 16);
        else {
            var s = this._getEndoRoots(this.n);
            this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], GS(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0))
        }
        var o;
        return e.basis ? o = e.basis.map(function(a) {
            return {
                a: new _r(a.a, 16),
                b: new _r(a.b, 16)
            }
        }) : o = this._getEndoBasis(n), {
            beta: r,
            lambda: n,
            basis: o
        }
    }
};
ci.prototype._getEndoRoots = function(e) {
    var r = e === this.p ? this.red : _r.mont(e),
        n = new _r(2).toRed(r).redInvm(),
        i = n.redNeg(),
        s = new _r(3).toRed(r).redNeg().redSqrt().redMul(n),
        o = i.redAdd(s).fromRed(),
        a = i.redSub(s).fromRed();
    return [o, a]
};
ci.prototype._getEndoBasis = function(e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new _r(1), o = new _r(0), a = new _r(0), c = new _r(1), d, y, I, N, E, T, j, V = 0, P, O; n.cmpn(0) !== 0;) {
        var R = i.div(n);
        P = i.sub(R.mul(n)), O = a.sub(R.mul(s));
        var q = c.sub(R.mul(o));
        if (!I && P.cmp(r) < 0) d = j.neg(), y = s, I = P.neg(), N = O;
        else if (I && ++V === 2) break;
        j = P, i = n, n = P, a = s, s = O, c = o, o = q
    }
    E = P.neg(), T = O;
    var W = I.sqr().add(N.sqr()),
        Y = E.sqr().add(T.sqr());
    return Y.cmp(W) >= 0 && (E = d, T = y), I.negative && (I = I.neg(), N = N.neg()), E.negative && (E = E.neg(), T = T.neg()), [{
        a: I,
        b: N
    }, {
        a: E,
        b: T
    }]
};
ci.prototype._endoSplit = function(e) {
    var r = this.endo.basis,
        n = r[0],
        i = r[1],
        s = i.b.mul(e).divRound(this.n),
        o = n.b.neg().mul(e).divRound(this.n),
        a = s.mul(n.a),
        c = o.mul(i.a),
        d = s.mul(n.b),
        y = o.mul(i.b),
        I = e.sub(a).sub(c),
        N = d.add(y).neg();
    return {
        k1: I,
        k2: N
    }
};
ci.prototype.pointFromX = function(e, r) {
    e = new _r(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
        i = n.redSqrt();
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0) throw new Error("invalid point");
    var s = i.fromRed().isOdd();
    return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i)
};
ci.prototype.validate = function(e) {
    if (e.inf) return !0;
    var r = e.x,
        n = e.y,
        i = this.a.redMul(r),
        s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
    return n.redSqr().redISub(s).cmpn(0) === 0
};
ci.prototype._endoWnafMulAdd = function(e, r, n) {
    for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
        var a = this._endoSplit(r[o]),
            c = e[o],
            d = c._getBeta();
        a.k1.negative && (a.k1.ineg(), c = c.neg(!0)), a.k2.negative && (a.k2.ineg(), d = d.neg(!0)), i[o * 2] = c, i[o * 2 + 1] = d, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2
    }
    for (var y = this._wnafMulAdd(1, i, s, o * 2, n), I = 0; I < o * 2; I++) i[I] = null, s[I] = null;
    return y
};

function qr(t, e, r, n) {
    qa.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new _r(e, 16), this.y = new _r(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
}
E1(qr, qa.BasePoint);
ci.prototype.point = function(e, r, n) {
    return new qr(this, e, r, n)
};
ci.prototype.pointFromJSON = function(e, r) {
    return qr.fromJSON(this, e, r)
};
qr.prototype._getBeta = function() {
    if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta) return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
            var n = this.curve,
                i = function(s) {
                    return n.point(s.x.redMul(n.endo.beta), s.y)
                };
            e.beta = r, r.precomputed = {
                beta: null,
                naf: e.naf && {
                    wnd: e.naf.wnd,
                    points: e.naf.points.map(i)
                },
                doubles: e.doubles && {
                    step: e.doubles.step,
                    points: e.doubles.points.map(i)
                }
            }
        }
        return r
    }
};
qr.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
        }
    }] : [this.x, this.y]
};
qr.fromJSON = function(e, r, n) {
    typeof r == "string" && (r = JSON.parse(r));
    var i = e.point(r[0], r[1], n);
    if (!r[2]) return i;

    function s(a) {
        return e.point(a[0], a[1], n)
    }
    var o = r[2];
    return i.precomputed = {
        beta: null,
        doubles: o.doubles && {
            step: o.doubles.step,
            points: [i].concat(o.doubles.points.map(s))
        },
        naf: o.naf && {
            wnd: o.naf.wnd,
            points: [i].concat(o.naf.points.map(s))
        }
    }, i
};
qr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
};
qr.prototype.isInfinity = function() {
    return this.inf
};
qr.prototype.add = function(e) {
    if (this.inf) return e;
    if (e.inf) return this;
    if (this.eq(e)) return this.dbl();
    if (this.neg().eq(e)) return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var n = r.redSqr().redISub(this.x).redISub(e.x),
        i = r.redMul(this.x.redSub(n)).redISub(this.y);
    return this.curve.point(n, i)
};
qr.prototype.dbl = function() {
    if (this.inf) return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0) return this.curve.point(null, null);
    var r = this.curve.a,
        n = this.x.redSqr(),
        i = e.redInvm(),
        s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i),
        o = s.redSqr().redISub(this.x.redAdd(this.x)),
        a = s.redMul(this.x.redSub(o)).redISub(this.y);
    return this.curve.point(o, a)
};
qr.prototype.getX = function() {
    return this.x.fromRed()
};
qr.prototype.getY = function() {
    return this.y.fromRed()
};
qr.prototype.mul = function(e) {
    return e = new _r(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
};
qr.prototype.mulAdd = function(e, r, n) {
    var i = [this, r],
        s = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2)
};
qr.prototype.jmulAdd = function(e, r, n) {
    var i = [this, r],
        s = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0)
};
qr.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)
};
qr.prototype.neg = function(e) {
    if (this.inf) return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
        var n = this.precomputed,
            i = function(s) {
                return s.neg()
            };
        r.precomputed = {
            naf: n.naf && {
                wnd: n.naf.wnd,
                points: n.naf.points.map(i)
            },
            doubles: n.doubles && {
                step: n.doubles.step,
                points: n.doubles.points.map(i)
            }
        }
    }
    return r
};
qr.prototype.toJ = function() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e
};

function en(t, e, r, n) {
    qa.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new _r(0)) : (this.x = new _r(e, 16), this.y = new _r(r, 16), this.z = new _r(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
}
E1(en, qa.BasePoint);
ci.prototype.jpoint = function(e, r, n) {
    return new en(this, e, r, n)
};
en.prototype.toP = function() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var e = this.z.redInvm(),
        r = e.redSqr(),
        n = this.x.redMul(r),
        i = this.y.redMul(r).redMul(e);
    return this.curve.point(n, i)
};
en.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
};
en.prototype.add = function(e) {
    if (this.isInfinity()) return e;
    if (e.isInfinity()) return this;
    var r = e.z.redSqr(),
        n = this.z.redSqr(),
        i = this.x.redMul(r),
        s = e.x.redMul(n),
        o = this.y.redMul(r.redMul(e.z)),
        a = e.y.redMul(n.redMul(this.z)),
        c = i.redSub(s),
        d = o.redSub(a);
    if (c.cmpn(0) === 0) return d.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var y = c.redSqr(),
        I = y.redMul(c),
        N = i.redMul(y),
        E = d.redSqr().redIAdd(I).redISub(N).redISub(N),
        T = d.redMul(N.redISub(E)).redISub(o.redMul(I)),
        j = this.z.redMul(e.z).redMul(c);
    return this.curve.jpoint(E, T, j)
};
en.prototype.mixedAdd = function(e) {
    if (this.isInfinity()) return e.toJ();
    if (e.isInfinity()) return this;
    var r = this.z.redSqr(),
        n = this.x,
        i = e.x.redMul(r),
        s = this.y,
        o = e.y.redMul(r).redMul(this.z),
        a = n.redSub(i),
        c = s.redSub(o);
    if (a.cmpn(0) === 0) return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var d = a.redSqr(),
        y = d.redMul(a),
        I = n.redMul(d),
        N = c.redSqr().redIAdd(y).redISub(I).redISub(I),
        E = c.redMul(I.redISub(N)).redISub(s.redMul(y)),
        T = this.z.redMul(a);
    return this.curve.jpoint(N, E, T)
};
en.prototype.dblp = function(e) {
    if (e === 0) return this;
    if (this.isInfinity()) return this;
    if (!e) return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
        var n = this;
        for (r = 0; r < e; r++) n = n.dbl();
        return n
    }
    var i = this.curve.a,
        s = this.curve.tinv,
        o = this.x,
        a = this.y,
        c = this.z,
        d = c.redSqr().redSqr(),
        y = a.redAdd(a);
    for (r = 0; r < e; r++) {
        var I = o.redSqr(),
            N = y.redSqr(),
            E = N.redSqr(),
            T = I.redAdd(I).redIAdd(I).redIAdd(i.redMul(d)),
            j = o.redMul(N),
            V = T.redSqr().redISub(j.redAdd(j)),
            P = j.redISub(V),
            O = T.redMul(P);
        O = O.redIAdd(O).redISub(E);
        var R = y.redMul(c);
        r + 1 < e && (d = d.redMul(E)), o = V, c = R, y = O
    }
    return this.curve.jpoint(o, y.redMul(s), c)
};
en.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
};
en.prototype._zeroDbl = function() {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
        a = a.redIAdd(a);
        var c = i.redAdd(i).redIAdd(i),
            d = c.redSqr().redISub(a).redISub(a),
            y = o.redIAdd(o);
        y = y.redIAdd(y), y = y.redIAdd(y), e = d, r = c.redMul(a.redISub(d)).redISub(y), n = this.y.redAdd(this.y)
    } else {
        var I = this.x.redSqr(),
            N = this.y.redSqr(),
            E = N.redSqr(),
            T = this.x.redAdd(N).redSqr().redISub(I).redISub(E);
        T = T.redIAdd(T);
        var j = I.redAdd(I).redIAdd(I),
            V = j.redSqr(),
            P = E.redIAdd(E);
        P = P.redIAdd(P), P = P.redIAdd(P), e = V.redISub(T).redISub(T), r = j.redMul(T.redISub(e)).redISub(P), n = this.y.redMul(this.z), n = n.redIAdd(n)
    }
    return this.curve.jpoint(e, r, n)
};
en.prototype._threeDbl = function() {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
        a = a.redIAdd(a);
        var c = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
            d = c.redSqr().redISub(a).redISub(a);
        e = d;
        var y = o.redIAdd(o);
        y = y.redIAdd(y), y = y.redIAdd(y), r = c.redMul(a.redISub(d)).redISub(y), n = this.y.redAdd(this.y)
    } else {
        var I = this.z.redSqr(),
            N = this.y.redSqr(),
            E = this.x.redMul(N),
            T = this.x.redSub(I).redMul(this.x.redAdd(I));
        T = T.redAdd(T).redIAdd(T);
        var j = E.redIAdd(E);
        j = j.redIAdd(j);
        var V = j.redAdd(j);
        e = T.redSqr().redISub(V), n = this.y.redAdd(this.z).redSqr().redISub(N).redISub(I);
        var P = N.redSqr();
        P = P.redIAdd(P), P = P.redIAdd(P), P = P.redIAdd(P), r = T.redMul(j.redISub(e)).redISub(P)
    }
    return this.curve.jpoint(e, r, n)
};
en.prototype._dbl = function() {
    var e = this.curve.a,
        r = this.x,
        n = this.y,
        i = this.z,
        s = i.redSqr().redSqr(),
        o = r.redSqr(),
        a = n.redSqr(),
        c = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)),
        d = r.redAdd(r);
    d = d.redIAdd(d);
    var y = d.redMul(a),
        I = c.redSqr().redISub(y.redAdd(y)),
        N = y.redISub(I),
        E = a.redSqr();
    E = E.redIAdd(E), E = E.redIAdd(E), E = E.redIAdd(E);
    var T = c.redMul(N).redISub(E),
        j = n.redAdd(n).redMul(i);
    return this.curve.jpoint(I, T, j)
};
en.prototype.trpl = function() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    var e = this.x.redSqr(),
        r = this.y.redSqr(),
        n = this.z.redSqr(),
        i = r.redSqr(),
        s = e.redAdd(e).redIAdd(e),
        o = s.redSqr(),
        a = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
    a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
    var c = a.redSqr(),
        d = i.redIAdd(i);
    d = d.redIAdd(d), d = d.redIAdd(d), d = d.redIAdd(d);
    var y = s.redIAdd(a).redSqr().redISub(o).redISub(c).redISub(d),
        I = r.redMul(y);
    I = I.redIAdd(I), I = I.redIAdd(I);
    var N = this.x.redMul(c).redISub(I);
    N = N.redIAdd(N), N = N.redIAdd(N);
    var E = this.y.redMul(y.redMul(d.redISub(y)).redISub(a.redMul(c)));
    E = E.redIAdd(E), E = E.redIAdd(E), E = E.redIAdd(E);
    var T = this.z.redAdd(a).redSqr().redISub(n).redISub(c);
    return this.curve.jpoint(N, E, T)
};
en.prototype.mul = function(e, r) {
    return e = new _r(e, r), this.curve._wnafMul(this, e)
};
en.prototype.eq = function(e) {
    if (e.type === "affine") return this.eq(e.toJ());
    if (this === e) return !0;
    var r = this.z.redSqr(),
        n = e.z.redSqr();
    if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0) return !1;
    var i = r.redMul(this.z),
        s = n.redMul(e.z);
    return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0
};
en.prototype.eqXToP = function(e) {
    var r = this.z.redSqr(),
        n = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(n) === 0) return !0;
    for (var i = e.clone(), s = this.curve.redN.redMul(r);;) {
        if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1;
        if (n.redIAdd(s), this.x.cmp(n) === 0) return !0
    }
};
en.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
};
en.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0
};
var ua = es.exports,
    Q2 = _a.exports,
    ch = fh,
    KS = qn;

function Wa(t) {
    ch.call(this, "mont", t), this.a = new ua(t.a, 16).toRed(this.red), this.b = new ua(t.b, 16).toRed(this.red), this.i4 = new ua(4).toRed(this.red).redInvm(), this.two = new ua(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two))
}
Q2(Wa, ch);
var ZS = Wa;
Wa.prototype.validate = function(e) {
    var r = e.normalize().x,
        n = r.redSqr(),
        i = n.redMul(r).redAdd(n.redMul(this.a)).redAdd(r),
        s = i.redSqrt();
    return s.redSqr().cmp(i) === 0
};

function Qr(t, e, r) {
    ch.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new ua(e, 16), this.z = new ua(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)))
}
Q2(Qr, ch.BasePoint);
Wa.prototype.decodePoint = function(e, r) {
    return this.point(KS.toArray(e, r), 1)
};
Wa.prototype.point = function(e, r) {
    return new Qr(this, e, r)
};
Wa.prototype.pointFromJSON = function(e) {
    return Qr.fromJSON(this, e)
};
Qr.prototype.precompute = function() {};
Qr.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength())
};
Qr.fromJSON = function(e, r) {
    return new Qr(e, r[0], r[1] || e.one)
};
Qr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
};
Qr.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0
};
Qr.prototype.dbl = function() {
    var e = this.x.redAdd(this.z),
        r = e.redSqr(),
        n = this.x.redSub(this.z),
        i = n.redSqr(),
        s = r.redSub(i),
        o = r.redMul(i),
        a = s.redMul(i.redAdd(this.curve.a24.redMul(s)));
    return this.curve.point(o, a)
};
Qr.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve")
};
Qr.prototype.diffAdd = function(e, r) {
    var n = this.x.redAdd(this.z),
        i = this.x.redSub(this.z),
        s = e.x.redAdd(e.z),
        o = e.x.redSub(e.z),
        a = o.redMul(n),
        c = s.redMul(i),
        d = r.z.redMul(a.redAdd(c).redSqr()),
        y = r.x.redMul(a.redISub(c).redSqr());
    return this.curve.point(d, y)
};
Qr.prototype.mul = function(e) {
    for (var r = e.clone(), n = this, i = this.curve.point(null, null), s = this, o = []; r.cmpn(0) !== 0; r.iushrn(1)) o.push(r.andln(1));
    for (var a = o.length - 1; a >= 0; a--) o[a] === 0 ? (n = n.diffAdd(i, s), i = i.dbl()) : (i = n.diffAdd(i, s), n = n.dbl());
    return i
};
Qr.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve")
};
Qr.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve")
};
Qr.prototype.eq = function(e) {
    return this.getX().cmp(e.getX()) === 0
};
Qr.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this
};
Qr.prototype.getX = function() {
    return this.normalize(), this.x.fromRed()
};
var JS = qn,
    cs = es.exports,
    q2 = _a.exports,
    hh = fh,
    XS = JS.assert;

function ts(t) {
    this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, hh.call(this, "edwards", t), this.a = new cs(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new cs(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new cs(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), XS(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1
}
q2(ts, hh);
var eM = ts;
ts.prototype._mulA = function(e) {
    return this.mOneA ? e.redNeg() : this.a.redMul(e)
};
ts.prototype._mulC = function(e) {
    return this.oneC ? e : this.c.redMul(e)
};
ts.prototype.jpoint = function(e, r, n, i) {
    return this.point(e, r, n, i)
};
ts.prototype.pointFromX = function(e, r) {
    e = new cs(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(),
        i = this.c2.redSub(this.a.redMul(n)),
        s = this.one.redSub(this.c2.redMul(this.d).redMul(n)),
        o = i.redMul(s.redInvm()),
        a = o.redSqrt();
    if (a.redSqr().redSub(o).cmp(this.zero) !== 0) throw new Error("invalid point");
    var c = a.fromRed().isOdd();
    return (r && !c || !r && c) && (a = a.redNeg()), this.point(e, a)
};
ts.prototype.pointFromY = function(e, r) {
    e = new cs(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(),
        i = n.redSub(this.c2),
        s = n.redMul(this.d).redMul(this.c2).redSub(this.a),
        o = i.redMul(s.redInvm());
    if (o.cmp(this.zero) === 0) {
        if (r) throw new Error("invalid point");
        return this.point(this.zero, e)
    }
    var a = o.redSqrt();
    if (a.redSqr().redSub(o).cmp(this.zero) !== 0) throw new Error("invalid point");
    return a.fromRed().isOdd() !== r && (a = a.redNeg()), this.point(a, e)
};
ts.prototype.validate = function(e) {
    if (e.isInfinity()) return !0;
    e.normalize();
    var r = e.x.redSqr(),
        n = e.y.redSqr(),
        i = r.redMul(this.a).redAdd(n),
        s = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(n)));
    return i.cmp(s) === 0
};

function fr(t, e, r, n, i) {
    hh.BasePoint.call(this, t, "projective"), e === null && r === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new cs(e, 16), this.y = new cs(r, 16), this.z = n ? new cs(n, 16) : this.curve.one, this.t = i && new cs(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
}
q2(fr, hh.BasePoint);
ts.prototype.pointFromJSON = function(e) {
    return fr.fromJSON(this, e)
};
ts.prototype.point = function(e, r, n, i) {
    return new fr(this, e, r, n, i)
};
fr.fromJSON = function(e, r) {
    return new fr(e, r[0], r[1], r[2])
};
fr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
};
fr.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0)
};
fr.prototype._extDbl = function() {
    var e = this.x.redSqr(),
        r = this.y.redSqr(),
        n = this.z.redSqr();
    n = n.redIAdd(n);
    var i = this.curve._mulA(e),
        s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r),
        o = i.redAdd(r),
        a = o.redSub(n),
        c = i.redSub(r),
        d = s.redMul(a),
        y = o.redMul(c),
        I = s.redMul(c),
        N = a.redMul(o);
    return this.curve.point(d, y, N, I)
};
fr.prototype._projDbl = function() {
    var e = this.x.redAdd(this.y).redSqr(),
        r = this.x.redSqr(),
        n = this.y.redSqr(),
        i, s, o, a, c, d;
    if (this.curve.twisted) {
        a = this.curve._mulA(r);
        var y = a.redAdd(n);
        this.zOne ? (i = e.redSub(r).redSub(n).redMul(y.redSub(this.curve.two)), s = y.redMul(a.redSub(n)), o = y.redSqr().redSub(y).redSub(y)) : (c = this.z.redSqr(), d = y.redSub(c).redISub(c), i = e.redSub(r).redISub(n).redMul(d), s = y.redMul(a.redSub(n)), o = y.redMul(d))
    } else a = r.redAdd(n), c = this.curve._mulC(this.z).redSqr(), d = a.redSub(c).redSub(c), i = this.curve._mulC(e.redISub(a)).redMul(d), s = this.curve._mulC(a).redMul(r.redISub(n)), o = a.redMul(d);
    return this.curve.point(i, s, o)
};
fr.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
};
fr.prototype._extAdd = function(e) {
    var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)),
        n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),
        i = this.t.redMul(this.curve.dd).redMul(e.t),
        s = this.z.redMul(e.z.redAdd(e.z)),
        o = n.redSub(r),
        a = s.redSub(i),
        c = s.redAdd(i),
        d = n.redAdd(r),
        y = o.redMul(a),
        I = c.redMul(d),
        N = o.redMul(d),
        E = a.redMul(c);
    return this.curve.point(y, I, E, N)
};
fr.prototype._projAdd = function(e) {
    var r = this.z.redMul(e.z),
        n = r.redSqr(),
        i = this.x.redMul(e.x),
        s = this.y.redMul(e.y),
        o = this.curve.d.redMul(i).redMul(s),
        a = n.redSub(o),
        c = n.redAdd(o),
        d = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(s),
        y = r.redMul(a).redMul(d),
        I, N;
    return this.curve.twisted ? (I = r.redMul(c).redMul(s.redSub(this.curve._mulA(i))), N = a.redMul(c)) : (I = r.redMul(c).redMul(s.redSub(i)), N = this.curve._mulC(a).redMul(c)), this.curve.point(y, I, N)
};
fr.prototype.add = function(e) {
    return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e)
};
fr.prototype.mul = function(e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e)
};
fr.prototype.mulAdd = function(e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !1)
};
fr.prototype.jmulAdd = function(e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !0)
};
fr.prototype.normalize = function() {
    if (this.zOne) return this;
    var e = this.z.redInvm();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this
};
fr.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
};
fr.prototype.getX = function() {
    return this.normalize(), this.x.fromRed()
};
fr.prototype.getY = function() {
    return this.normalize(), this.y.fromRed()
};
fr.prototype.eq = function(e) {
    return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0
};
fr.prototype.eqXToP = function(e) {
    var r = e.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(r) === 0) return !0;
    for (var n = e.clone(), i = this.curve.redN.redMul(this.z);;) {
        if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0) return !1;
        if (r.redIAdd(i), this.x.cmp(r) === 0) return !0
    }
};
fr.prototype.toP = fr.prototype.normalize;
fr.prototype.mixedAdd = fr.prototype.add;
(function(t) {
    var e = t;
    e.base = fh, e.short = YS, e.mont = ZS, e.edwards = eM
})(M1);
var dh = {},
    ph = {},
    Dt = {},
    tM = Uo,
    rM = _a.exports;
Dt.inherits = rM;

function nM(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320
}

function iM(t, e) {
    if (Array.isArray(t)) return t.slice();
    if (!t) return [];
    var r = [];
    if (typeof t == "string")
        if (e) {
            if (e === "hex")
                for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2) r.push(parseInt(t[i] + t[i + 1], 16))
        } else
            for (var n = 0, i = 0; i < t.length; i++) {
                var s = t.charCodeAt(i);
                s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = s & 63 | 128) : nM(t, i) ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128)
            } else
                for (i = 0; i < t.length; i++) r[i] = t[i] | 0;
    return r
}
Dt.toArray = iM;

function sM(t) {
    for (var e = "", r = 0; r < t.length; r++) e += V2(t[r].toString(16));
    return e
}
Dt.toHex = sM;

function W2(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0
}
Dt.htonl = W2;

function oM(t, e) {
    for (var r = "", n = 0; n < t.length; n++) {
        var i = t[n];
        e === "little" && (i = W2(i)), r += G2(i.toString(16))
    }
    return r
}
Dt.toHex32 = oM;

function V2(t) {
    return t.length === 1 ? "0" + t : t
}
Dt.zero2 = V2;

function G2(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t
}
Dt.zero8 = G2;

function aM(t, e, r, n) {
    var i = r - e;
    tM(i % 4 === 0);
    for (var s = new Array(i / 4), o = 0, a = e; o < s.length; o++, a += 4) {
        var c;
        n === "big" ? c = t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3] : c = t[a + 3] << 24 | t[a + 2] << 16 | t[a + 1] << 8 | t[a], s[o] = c >>> 0
    }
    return s
}
Dt.join32 = aM;

function uM(t, e) {
    for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
        var s = t[n];
        e === "big" ? (r[i] = s >>> 24, r[i + 1] = s >>> 16 & 255, r[i + 2] = s >>> 8 & 255, r[i + 3] = s & 255) : (r[i + 3] = s >>> 24, r[i + 2] = s >>> 16 & 255, r[i + 1] = s >>> 8 & 255, r[i] = s & 255)
    }
    return r
}
Dt.split32 = uM;

function lM(t, e) {
    return t >>> e | t << 32 - e
}
Dt.rotr32 = lM;

function fM(t, e) {
    return t << e | t >>> 32 - e
}
Dt.rotl32 = fM;

function cM(t, e) {
    return t + e >>> 0
}
Dt.sum32 = cM;

function hM(t, e, r) {
    return t + e + r >>> 0
}
Dt.sum32_3 = hM;

function dM(t, e, r, n) {
    return t + e + r + n >>> 0
}
Dt.sum32_4 = dM;

function pM(t, e, r, n, i) {
    return t + e + r + n + i >>> 0
}
Dt.sum32_5 = pM;

function mM(t, e, r, n) {
    var i = t[e],
        s = t[e + 1],
        o = n + s >>> 0,
        a = (o < n ? 1 : 0) + r + i;
    t[e] = a >>> 0, t[e + 1] = o
}
Dt.sum64 = mM;

function vM(t, e, r, n) {
    var i = e + n >>> 0,
        s = (i < e ? 1 : 0) + t + r;
    return s >>> 0
}
Dt.sum64_hi = vM;

function gM(t, e, r, n) {
    var i = e + n;
    return i >>> 0
}
Dt.sum64_lo = gM;

function yM(t, e, r, n, i, s, o, a) {
    var c = 0,
        d = e;
    d = d + n >>> 0, c += d < e ? 1 : 0, d = d + s >>> 0, c += d < s ? 1 : 0, d = d + a >>> 0, c += d < a ? 1 : 0;
    var y = t + r + i + o + c;
    return y >>> 0
}
Dt.sum64_4_hi = yM;

function wM(t, e, r, n, i, s, o, a) {
    var c = e + n + s + a;
    return c >>> 0
}
Dt.sum64_4_lo = wM;

function xM(t, e, r, n, i, s, o, a, c, d) {
    var y = 0,
        I = e;
    I = I + n >>> 0, y += I < e ? 1 : 0, I = I + s >>> 0, y += I < s ? 1 : 0, I = I + a >>> 0, y += I < a ? 1 : 0, I = I + d >>> 0, y += I < d ? 1 : 0;
    var N = t + r + i + o + c + y;
    return N >>> 0
}
Dt.sum64_5_hi = xM;

function bM(t, e, r, n, i, s, o, a, c, d) {
    var y = e + n + s + a + d;
    return y >>> 0
}
Dt.sum64_5_lo = bM;

function AM(t, e, r) {
    var n = e << 32 - r | t >>> r;
    return n >>> 0
}
Dt.rotr64_hi = AM;

function SM(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0
}
Dt.rotr64_lo = SM;

function MM(t, e, r) {
    return t >>> r
}
Dt.shr64_hi = MM;

function EM(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0
}
Dt.shr64_lo = EM;
var Va = {},
    xv = Dt,
    _M = Uo;

function mh() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
}
Va.BlockHash = mh;
mh.prototype.update = function(e, r) {
    if (e = xv.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var n = e.length % this._delta8;
        this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = xv.join32(e, 0, e.length - n, this.endian);
        for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
    }
    return this
};
mh.prototype.digest = function(e) {
    return this.update(this._pad()), _M(this.pending === null), this._digest(e)
};
mh.prototype._pad = function() {
    var e = this.pendingTotal,
        r = this._delta8,
        n = r - (e + this.padLength) % r,
        i = new Array(n + this.padLength);
    i[0] = 128;
    for (var s = 1; s < n; s++) i[s] = 0;
    if (e <<= 3, this.endian === "big") {
        for (var o = 8; o < this.padLength; o++) i[s++] = 0;
        i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255
    } else
        for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, o = 8; o < this.padLength; o++) i[s++] = 0;
    return i
};
var Ga = {},
    rs = {},
    IM = Dt,
    Ui = IM.rotr32;

function CM(t, e, r, n) {
    if (t === 0) return Y2(e, r, n);
    if (t === 1 || t === 3) return Z2(e, r, n);
    if (t === 2) return K2(e, r, n)
}
rs.ft_1 = CM;

function Y2(t, e, r) {
    return t & e ^ ~t & r
}
rs.ch32 = Y2;

function K2(t, e, r) {
    return t & e ^ t & r ^ e & r
}
rs.maj32 = K2;

function Z2(t, e, r) {
    return t ^ e ^ r
}
rs.p32 = Z2;

function BM(t) {
    return Ui(t, 2) ^ Ui(t, 13) ^ Ui(t, 22)
}
rs.s0_256 = BM;

function kM(t) {
    return Ui(t, 6) ^ Ui(t, 11) ^ Ui(t, 25)
}
rs.s1_256 = kM;

function NM(t) {
    return Ui(t, 7) ^ Ui(t, 18) ^ t >>> 3
}
rs.g0_256 = NM;

function TM(t) {
    return Ui(t, 17) ^ Ui(t, 19) ^ t >>> 10
}
rs.g1_256 = TM;
var Ia = Dt,
    OM = Va,
    RM = rs,
    y0 = Ia.rotl32,
    gu = Ia.sum32,
    DM = Ia.sum32_5,
    PM = RM.ft_1,
    J2 = OM.BlockHash,
    LM = [1518500249, 1859775393, 2400959708, 3395469782];

function qi() {
    if (!(this instanceof qi)) return new qi;
    J2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
}
Ia.inherits(qi, J2);
var FM = qi;
qi.blockSize = 512;
qi.outSize = 160;
qi.hmacStrength = 80;
qi.padLength = 64;
qi.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
    for (; i < n.length; i++) n[i] = y0(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
    var s = this.h[0],
        o = this.h[1],
        a = this.h[2],
        c = this.h[3],
        d = this.h[4];
    for (i = 0; i < n.length; i++) {
        var y = ~~(i / 20),
            I = DM(y0(s, 5), PM(y, o, a, c), d, n[i], LM[y]);
        d = c, c = a, a = y0(o, 30), o = s, s = I
    }
    this.h[0] = gu(this.h[0], s), this.h[1] = gu(this.h[1], o), this.h[2] = gu(this.h[2], a), this.h[3] = gu(this.h[3], c), this.h[4] = gu(this.h[4], d)
};
qi.prototype._digest = function(e) {
    return e === "hex" ? Ia.toHex32(this.h, "big") : Ia.split32(this.h, "big")
};
var Ca = Dt,
    UM = Va,
    Ya = rs,
    zM = Uo,
    di = Ca.sum32,
    jM = Ca.sum32_4,
    $M = Ca.sum32_5,
    HM = Ya.ch32,
    QM = Ya.maj32,
    qM = Ya.s0_256,
    WM = Ya.s1_256,
    VM = Ya.g0_256,
    GM = Ya.g1_256,
    X2 = UM.BlockHash,
    YM = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

function Wi() {
    if (!(this instanceof Wi)) return new Wi;
    X2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = YM, this.W = new Array(64)
}
Ca.inherits(Wi, X2);
var ex = Wi;
Wi.blockSize = 512;
Wi.outSize = 256;
Wi.hmacStrength = 192;
Wi.padLength = 64;
Wi.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
    for (; i < n.length; i++) n[i] = jM(GM(n[i - 2]), n[i - 7], VM(n[i - 15]), n[i - 16]);
    var s = this.h[0],
        o = this.h[1],
        a = this.h[2],
        c = this.h[3],
        d = this.h[4],
        y = this.h[5],
        I = this.h[6],
        N = this.h[7];
    for (zM(this.k.length === n.length), i = 0; i < n.length; i++) {
        var E = $M(N, WM(d), HM(d, y, I), this.k[i], n[i]),
            T = di(qM(s), QM(s, o, a));
        N = I, I = y, y = d, d = di(c, E), c = a, a = o, o = s, s = di(E, T)
    }
    this.h[0] = di(this.h[0], s), this.h[1] = di(this.h[1], o), this.h[2] = di(this.h[2], a), this.h[3] = di(this.h[3], c), this.h[4] = di(this.h[4], d), this.h[5] = di(this.h[5], y), this.h[6] = di(this.h[6], I), this.h[7] = di(this.h[7], N)
};
Wi.prototype._digest = function(e) {
    return e === "hex" ? Ca.toHex32(this.h, "big") : Ca.split32(this.h, "big")
};
var jd = Dt,
    tx = ex;

function ys() {
    if (!(this instanceof ys)) return new ys;
    tx.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
}
jd.inherits(ys, tx);
var KM = ys;
ys.blockSize = 512;
ys.outSize = 224;
ys.hmacStrength = 192;
ys.padLength = 64;
ys.prototype._digest = function(e) {
    return e === "hex" ? jd.toHex32(this.h.slice(0, 7), "big") : jd.split32(this.h.slice(0, 7), "big")
};
var kn = Dt,
    ZM = Va,
    JM = Uo,
    zi = kn.rotr64_hi,
    ji = kn.rotr64_lo,
    rx = kn.shr64_hi,
    nx = kn.shr64_lo,
    Es = kn.sum64,
    w0 = kn.sum64_hi,
    x0 = kn.sum64_lo,
    XM = kn.sum64_4_hi,
    eE = kn.sum64_4_lo,
    tE = kn.sum64_5_hi,
    rE = kn.sum64_5_lo,
    ix = ZM.BlockHash,
    nE = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

function Ci() {
    if (!(this instanceof Ci)) return new Ci;
    ix.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = nE, this.W = new Array(160)
}
kn.inherits(Ci, ix);
var sx = Ci;
Ci.blockSize = 1024;
Ci.outSize = 512;
Ci.hmacStrength = 192;
Ci.padLength = 128;
Ci.prototype._prepareBlock = function(e, r) {
    for (var n = this.W, i = 0; i < 32; i++) n[i] = e[r + i];
    for (; i < n.length; i += 2) {
        var s = pE(n[i - 4], n[i - 3]),
            o = mE(n[i - 4], n[i - 3]),
            a = n[i - 14],
            c = n[i - 13],
            d = hE(n[i - 30], n[i - 29]),
            y = dE(n[i - 30], n[i - 29]),
            I = n[i - 32],
            N = n[i - 31];
        n[i] = XM(s, o, a, c, d, y, I, N), n[i + 1] = eE(s, o, a, c, d, y, I, N)
    }
};
Ci.prototype._update = function(e, r) {
    this._prepareBlock(e, r);
    var n = this.W,
        i = this.h[0],
        s = this.h[1],
        o = this.h[2],
        a = this.h[3],
        c = this.h[4],
        d = this.h[5],
        y = this.h[6],
        I = this.h[7],
        N = this.h[8],
        E = this.h[9],
        T = this.h[10],
        j = this.h[11],
        V = this.h[12],
        P = this.h[13],
        O = this.h[14],
        R = this.h[15];
    JM(this.k.length === n.length);
    for (var q = 0; q < n.length; q += 2) {
        var W = O,
            Y = R,
            G = fE(N, E),
            J = cE(N, E),
            pe = iE(N, E, T, j, V),
            we = sE(N, E, T, j, V, P),
            H = this.k[q],
            w = this.k[q + 1],
            p = n[q],
            f = n[q + 1],
            h = tE(W, Y, G, J, pe, we, H, w, p, f),
            b = rE(W, Y, G, J, pe, we, H, w, p, f);
        W = uE(i, s), Y = lE(i, s), G = oE(i, s, o, a, c), J = aE(i, s, o, a, c, d);
        var C = w0(W, Y, G, J),
            _ = x0(W, Y, G, J);
        O = V, R = P, V = T, P = j, T = N, j = E, N = w0(y, I, h, b), E = x0(I, I, h, b), y = c, I = d, c = o, d = a, o = i, a = s, i = w0(h, b, C, _), s = x0(h, b, C, _)
    }
    Es(this.h, 0, i, s), Es(this.h, 2, o, a), Es(this.h, 4, c, d), Es(this.h, 6, y, I), Es(this.h, 8, N, E), Es(this.h, 10, T, j), Es(this.h, 12, V, P), Es(this.h, 14, O, R)
};
Ci.prototype._digest = function(e) {
    return e === "hex" ? kn.toHex32(this.h, "big") : kn.split32(this.h, "big")
};

function iE(t, e, r, n, i) {
    var s = t & r ^ ~t & i;
    return s < 0 && (s += 4294967296), s
}

function sE(t, e, r, n, i, s) {
    var o = e & n ^ ~e & s;
    return o < 0 && (o += 4294967296), o
}

function oE(t, e, r, n, i) {
    var s = t & r ^ t & i ^ r & i;
    return s < 0 && (s += 4294967296), s
}

function aE(t, e, r, n, i, s) {
    var o = e & n ^ e & s ^ n & s;
    return o < 0 && (o += 4294967296), o
}

function uE(t, e) {
    var r = zi(t, e, 28),
        n = zi(e, t, 2),
        i = zi(e, t, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function lE(t, e) {
    var r = ji(t, e, 28),
        n = ji(e, t, 2),
        i = ji(e, t, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function fE(t, e) {
    var r = zi(t, e, 14),
        n = zi(t, e, 18),
        i = zi(e, t, 9),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function cE(t, e) {
    var r = ji(t, e, 14),
        n = ji(t, e, 18),
        i = ji(e, t, 9),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function hE(t, e) {
    var r = zi(t, e, 1),
        n = zi(t, e, 8),
        i = rx(t, e, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function dE(t, e) {
    var r = ji(t, e, 1),
        n = ji(t, e, 8),
        i = nx(t, e, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function pE(t, e) {
    var r = zi(t, e, 19),
        n = zi(e, t, 29),
        i = rx(t, e, 6),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function mE(t, e) {
    var r = ji(t, e, 19),
        n = ji(e, t, 29),
        i = nx(t, e, 6),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}
var $d = Dt,
    ox = sx;

function ws() {
    if (!(this instanceof ws)) return new ws;
    ox.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
}
$d.inherits(ws, ox);
var vE = ws;
ws.blockSize = 1024;
ws.outSize = 384;
ws.hmacStrength = 192;
ws.padLength = 128;
ws.prototype._digest = function(e) {
    return e === "hex" ? $d.toHex32(this.h.slice(0, 12), "big") : $d.split32(this.h.slice(0, 12), "big")
};
Ga.sha1 = FM;
Ga.sha224 = KM;
Ga.sha256 = ex;
Ga.sha384 = vE;
Ga.sha512 = sx;
var ax = {},
    To = Dt,
    gE = Va,
    uf = To.rotl32,
    bv = To.sum32,
    yu = To.sum32_3,
    Av = To.sum32_4,
    ux = gE.BlockHash;

function Vi() {
    if (!(this instanceof Vi)) return new Vi;
    ux.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
}
To.inherits(Vi, ux);
ax.ripemd160 = Vi;
Vi.blockSize = 512;
Vi.outSize = 160;
Vi.hmacStrength = 192;
Vi.padLength = 64;
Vi.prototype._update = function(e, r) {
    for (var n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], c = n, d = i, y = s, I = o, N = a, E = 0; E < 80; E++) {
        var T = bv(uf(Av(n, Sv(E, i, s, o), e[xE[E] + r], yE(E)), AE[E]), a);
        n = a, a = o, o = uf(s, 10), s = i, i = T, T = bv(uf(Av(c, Sv(79 - E, d, y, I), e[bE[E] + r], wE(E)), SE[E]), N), c = N, N = I, I = uf(y, 10), y = d, d = T
    }
    T = yu(this.h[1], s, I), this.h[1] = yu(this.h[2], o, N), this.h[2] = yu(this.h[3], a, c), this.h[3] = yu(this.h[4], n, d), this.h[4] = yu(this.h[0], i, y), this.h[0] = T
};
Vi.prototype._digest = function(e) {
    return e === "hex" ? To.toHex32(this.h, "little") : To.split32(this.h, "little")
};

function Sv(t, e, r, n) {
    return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n)
}

function yE(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838
}

function wE(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0
}
var xE = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
    bE = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
    AE = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
    SE = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
    ME = Dt,
    EE = Uo;

function Ba(t, e, r) {
    if (!(this instanceof Ba)) return new Ba(t, e, r);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(ME.toArray(e, r))
}
var _E = Ba;
Ba.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), EE(e.length <= this.blockSize);
    for (var r = e.length; r < this.blockSize; r++) e.push(0);
    for (r = 0; r < e.length; r++) e[r] ^= 54;
    for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++) e[r] ^= 106;
    this.outer = new this.Hash().update(e)
};
Ba.prototype.update = function(e, r) {
    return this.inner.update(e, r), this
};
Ba.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e)
};
(function(t) {
    var e = t;
    e.utils = Dt, e.common = Va, e.sha = Ga, e.ripemd = ax, e.hmac = _E, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160
})(ph);
(function(t) {
    var e = t,
        r = ph,
        n = M1,
        i = qn,
        s = i.assert;

    function o(d) {
        d.type === "short" ? this.curve = new n.short(d) : d.type === "edwards" ? this.curve = new n.edwards(d) : this.curve = new n.mont(d), this.g = this.curve.g, this.n = this.curve.n, this.hash = d.hash, s(this.g.validate(), "Invalid curve"), s(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
    }
    e.PresetCurve = o;

    function a(d, y) {
        Object.defineProperty(e, d, {
            configurable: !0,
            enumerable: !0,
            get: function() {
                var I = new o(y);
                return Object.defineProperty(e, d, {
                    configurable: !0,
                    enumerable: !0,
                    value: I
                }), I
            }
        })
    }
    a("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: r.sha256,
        gRed: !1,
        g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
    }), a("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: r.sha256,
        gRed: !1,
        g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
    }), a("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: r.sha256,
        gRed: !1,
        g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
    }), a("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: r.sha384,
        gRed: !1,
        g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
    }), a("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: r.sha512,
        gRed: !1,
        g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
    }), a("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: r.sha256,
        gRed: !1,
        g: ["9"]
    }), a("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: r.sha256,
        gRed: !1,
        g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
    });
    var c;
    try {
        c = require("./precomputed/secp256k1")
    } catch {
        c = void 0
    }
    a("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: r.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [{
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        }, {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
        }],
        gRed: !1,
        g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", c]
    })
})(dh);
var IE = ph,
    Mo = S1,
    lx = Uo;

function ro(t) {
    if (!(this instanceof ro)) return new ro(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = Mo.toArray(t.entropy, t.entropyEnc || "hex"),
        r = Mo.toArray(t.nonce, t.nonceEnc || "hex"),
        n = Mo.toArray(t.pers, t.persEnc || "hex");
    lx(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n)
}
var CE = ro;
ro.prototype._init = function(e, r, n) {
    var i = e.concat(r).concat(n);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var s = 0; s < this.V.length; s++) this.K[s] = 0, this.V[s] = 1;
    this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656
};
ro.prototype._hmac = function() {
    return new IE.hmac(this.hash, this.K)
};
ro.prototype._update = function(e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
};
ro.prototype.reseed = function(e, r, n, i) {
    typeof r != "string" && (i = n, n = r, r = null), e = Mo.toArray(e, r), n = Mo.toArray(n, i), lx(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1
};
ro.prototype.generate = function(e, r, n, i) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    typeof r != "string" && (i = n, n = r, r = null), n && (n = Mo.toArray(n, i || "hex"), this._update(n));
    for (var s = []; s.length < e;) this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
    var o = s.slice(0, e);
    return this._update(n), this._reseed++, Mo.encode(o, r)
};
var BE = es.exports,
    kE = qn,
    Hd = kE.assert;

function pn(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc)
}
var NE = pn;
pn.fromPublic = function(e, r, n) {
    return r instanceof pn ? r : new pn(e, {
        pub: r,
        pubEnc: n
    })
};
pn.fromPrivate = function(e, r, n) {
    return r instanceof pn ? r : new pn(e, {
        priv: r,
        privEnc: n
    })
};
pn.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? {
        result: !1,
        reason: "Invalid public key"
    } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
        result: !0,
        reason: null
    } : {
        result: !1,
        reason: "Public key * N != O"
    } : {
        result: !1,
        reason: "Public key is not a point"
    }
};
pn.prototype.getPublic = function(e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub
};
pn.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv
};
pn.prototype._importPrivate = function(e, r) {
    this.priv = new BE(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n)
};
pn.prototype._importPublic = function(e, r) {
    if (e.x || e.y) {
        this.ec.curve.type === "mont" ? Hd(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Hd(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return
    }
    this.pub = this.ec.curve.decodePoint(e, r)
};
pn.prototype.derive = function(e) {
    return e.validate() || Hd(e.validate(), "public point not validated"), e.mul(this.priv).getX()
};
pn.prototype.sign = function(e, r, n) {
    return this.ec.sign(e, this, r, n)
};
pn.prototype.verify = function(e, r) {
    return this.ec.verify(e, r, this)
};
pn.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
};
var xc = es.exports,
    _1 = qn,
    TE = _1.assert;

function vh(t, e) {
    if (t instanceof vh) return t;
    this._importDER(t, e) || (TE(t.r && t.s, "Signature without r or s"), this.r = new xc(t.r, 16), this.s = new xc(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam)
}
var OE = vh;

function RE() {
    this.place = 0
}

function b0(t, e) {
    var r = t[e.place++];
    if (!(r & 128)) return r;
    var n = r & 15;
    if (n === 0 || n > 4) return !1;
    for (var i = 0, s = 0, o = e.place; s < n; s++, o++) i <<= 8, i |= t[o], i >>>= 0;
    return i <= 127 ? !1 : (e.place = o, i)
}

function Mv(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r;) e++;
    return e === 0 ? t : t.slice(e)
}
vh.prototype._importDER = function(e, r) {
    e = _1.toArray(e, r);
    var n = new RE;
    if (e[n.place++] !== 48) return !1;
    var i = b0(e, n);
    if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2) return !1;
    var s = b0(e, n);
    if (s === !1) return !1;
    var o = e.slice(n.place, s + n.place);
    if (n.place += s, e[n.place++] !== 2) return !1;
    var a = b0(e, n);
    if (a === !1 || e.length !== a + n.place) return !1;
    var c = e.slice(n.place, a + n.place);
    if (o[0] === 0)
        if (o[1] & 128) o = o.slice(1);
        else return !1;
    if (c[0] === 0)
        if (c[1] & 128) c = c.slice(1);
        else return !1;
    return this.r = new xc(o), this.s = new xc(c), this.recoveryParam = null, !0
};

function A0(t, e) {
    if (e < 128) {
        t.push(e);
        return
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128); --r;) t.push(e >>> (r << 3) & 255);
    t.push(e)
}
vh.prototype.toDER = function(e) {
    var r = this.r.toArray(),
        n = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = Mv(r), n = Mv(n); !n[0] && !(n[1] & 128);) n = n.slice(1);
    var i = [2];
    A0(i, r.length), i = i.concat(r), i.push(2), A0(i, n.length);
    var s = i.concat(n),
        o = [48];
    return A0(o, s.length), o = o.concat(s), _1.encode(o, e)
};
var Eo = es.exports,
    fx = CE,
    DE = qn,
    S0 = dh,
    PE = lh.exports,
    cx = DE.assert,
    I1 = NE,
    gh = OE;

function li(t) {
    if (!(this instanceof li)) return new li(t);
    typeof t == "string" && (cx(Object.prototype.hasOwnProperty.call(S0, t), "Unknown curve " + t), t = S0[t]), t instanceof S0.PresetCurve && (t = {
        curve: t
    }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash
}
var LE = li;
li.prototype.keyPair = function(e) {
    return new I1(this, e)
};
li.prototype.keyFromPrivate = function(e, r) {
    return I1.fromPrivate(this, e, r)
};
li.prototype.keyFromPublic = function(e, r) {
    return I1.fromPublic(this, e, r)
};
li.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r = new fx({
            hash: this.hash,
            pers: e.pers,
            persEnc: e.persEnc || "utf8",
            entropy: e.entropy || PE(this.hash.hmacStrength),
            entropyEnc: e.entropy && e.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), n = this.n.byteLength(), i = this.n.sub(new Eo(2));;) {
        var s = new Eo(r.generate(n));
        if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
    }
};
li.prototype._truncateToN = function(e, r) {
    var n = e.byteLength() * 8 - this.n.bitLength();
    return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
};
li.prototype.sign = function(e, r, n, i) {
    typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new Eo(e, 16));
    for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), a = e.toArray("be", s), c = new fx({
            hash: this.hash,
            entropy: o,
            nonce: a,
            pers: i.pers,
            persEnc: i.persEnc || "utf8"
        }), d = this.n.sub(new Eo(1)), y = 0;; y++) {
        var I = i.k ? i.k(y) : new Eo(c.generate(this.n.byteLength()));
        if (I = this._truncateToN(I, !0), !(I.cmpn(1) <= 0 || I.cmp(d) >= 0)) {
            var N = this.g.mul(I);
            if (!N.isInfinity()) {
                var E = N.getX(),
                    T = E.umod(this.n);
                if (T.cmpn(0) !== 0) {
                    var j = I.invm(this.n).mul(T.mul(r.getPrivate()).iadd(e));
                    if (j = j.umod(this.n), j.cmpn(0) !== 0) {
                        var V = (N.getY().isOdd() ? 1 : 0) | (E.cmp(T) !== 0 ? 2 : 0);
                        return i.canonical && j.cmp(this.nh) > 0 && (j = this.n.sub(j), V ^= 1), new gh({
                            r: T,
                            s: j,
                            recoveryParam: V
                        })
                    }
                }
            }
        }
    }
};
li.prototype.verify = function(e, r, n, i) {
    e = this._truncateToN(new Eo(e, 16)), n = this.keyFromPublic(n, i), r = new gh(r, "hex");
    var s = r.r,
        o = r.s;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
    var a = o.invm(this.n),
        c = a.mul(e).umod(this.n),
        d = a.mul(s).umod(this.n),
        y;
    return this.curve._maxwellTrick ? (y = this.g.jmulAdd(c, n.getPublic(), d), y.isInfinity() ? !1 : y.eqXToP(s)) : (y = this.g.mulAdd(c, n.getPublic(), d), y.isInfinity() ? !1 : y.getX().umod(this.n).cmp(s) === 0)
};
li.prototype.recoverPubKey = function(t, e, r, n) {
    cx((3 & r) === r, "The recovery param is more than two bits"), e = new gh(e, n);
    var i = this.n,
        s = new Eo(t),
        o = e.r,
        a = e.s,
        c = r & 1,
        d = r >> 1;
    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && d) throw new Error("Unable to find sencond key candinate");
    d ? o = this.curve.pointFromX(o.add(this.curve.n), c) : o = this.curve.pointFromX(o, c);
    var y = e.r.invm(i),
        I = i.sub(s).mul(y).umod(i),
        N = a.mul(y).umod(i);
    return this.g.mulAdd(I, o, N)
};
li.prototype.getKeyRecoveryParam = function(t, e, r, n) {
    if (e = new gh(e, n), e.recoveryParam !== null) return e.recoveryParam;
    for (var i = 0; i < 4; i++) {
        var s;
        try {
            s = this.recoverPubKey(t, e, i)
        } catch {
            continue
        }
        if (s.eq(r)) return i
    }
    throw new Error("Unable to find valid recovery factor")
};
var Cl = qn,
    hx = Cl.assert,
    Ev = Cl.parseBytes,
    Ka = Cl.cachedProperty;

function Hr(t, e) {
    this.eddsa = t, this._secret = Ev(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Ev(e.pub)
}
Hr.fromPublic = function(e, r) {
    return r instanceof Hr ? r : new Hr(e, {
        pub: r
    })
};
Hr.fromSecret = function(e, r) {
    return r instanceof Hr ? r : new Hr(e, {
        secret: r
    })
};
Hr.prototype.secret = function() {
    return this._secret
};
Ka(Hr, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub())
});
Ka(Hr, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
});
Ka(Hr, "privBytes", function() {
    var e = this.eddsa,
        r = this.hash(),
        n = e.encodingLength - 1,
        i = r.slice(0, e.encodingLength);
    return i[0] &= 248, i[n] &= 127, i[n] |= 64, i
});
Ka(Hr, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes())
});
Ka(Hr, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest()
});
Ka(Hr, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength)
});
Hr.prototype.sign = function(e) {
    return hx(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this)
};
Hr.prototype.verify = function(e, r) {
    return this.eddsa.verify(e, r, this)
};
Hr.prototype.getSecret = function(e) {
    return hx(this._secret, "KeyPair is public only"), Cl.encode(this.secret(), e)
};
Hr.prototype.getPublic = function(e) {
    return Cl.encode(this.pubBytes(), e)
};
var FE = Hr,
    UE = es.exports,
    yh = qn,
    zE = yh.assert,
    wh = yh.cachedProperty,
    jE = yh.parseBytes;

function zo(t, e) {
    this.eddsa = t, typeof e != "object" && (e = jE(e)), Array.isArray(e) && (e = {
        R: e.slice(0, t.encodingLength),
        S: e.slice(t.encodingLength)
    }), zE(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof UE && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded
}
wh(zo, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded())
});
wh(zo, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded())
});
wh(zo, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R())
});
wh(zo, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S())
});
zo.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded())
};
zo.prototype.toHex = function() {
    return yh.encode(this.toBytes(), "hex").toUpperCase()
};
var $E = zo,
    HE = ph,
    QE = dh,
    ka = qn,
    qE = ka.assert,
    dx = ka.parseBytes,
    px = FE,
    _v = $E;

function Nn(t) {
    if (qE(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof Nn)) return new Nn(t);
    t = QE[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = HE.sha512
}
var WE = Nn;
Nn.prototype.sign = function(e, r) {
    e = dx(e);
    var n = this.keyFromSecret(r),
        i = this.hashInt(n.messagePrefix(), e),
        s = this.g.mul(i),
        o = this.encodePoint(s),
        a = this.hashInt(o, n.pubBytes(), e).mul(n.priv()),
        c = i.add(a).umod(this.curve.n);
    return this.makeSignature({
        R: s,
        S: c,
        Rencoded: o
    })
};
Nn.prototype.verify = function(e, r, n) {
    e = dx(e), r = this.makeSignature(r);
    var i = this.keyFromPublic(n),
        s = this.hashInt(r.Rencoded(), i.pubBytes(), e),
        o = this.g.mul(r.S()),
        a = r.R().add(i.pub().mul(s));
    return a.eq(o)
};
Nn.prototype.hashInt = function() {
    for (var e = this.hash(), r = 0; r < arguments.length; r++) e.update(arguments[r]);
    return ka.intFromLE(e.digest()).umod(this.curve.n)
};
Nn.prototype.keyFromPublic = function(e) {
    return px.fromPublic(this, e)
};
Nn.prototype.keyFromSecret = function(e) {
    return px.fromSecret(this, e)
};
Nn.prototype.makeSignature = function(e) {
    return e instanceof _v ? e : new _v(this, e)
};
Nn.prototype.encodePoint = function(e) {
    var r = e.getY().toArray("le", this.encodingLength);
    return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r
};
Nn.prototype.decodePoint = function(e) {
    e = ka.parseBytes(e);
    var r = e.length - 1,
        n = e.slice(0, r).concat(e[r] & -129),
        i = (e[r] & 128) !== 0,
        s = ka.intFromLE(n);
    return this.curve.pointFromY(s, i)
};
Nn.prototype.encodeInt = function(e) {
    return e.toArray("le", this.encodingLength)
};
Nn.prototype.decodeInt = function(e) {
    return ka.intFromLE(e)
};
Nn.prototype.isPoint = function(e) {
    return e instanceof this.pointClass
};
(function(t) {
    var e = t;
    e.version = qS.version, e.utils = qn, e.rand = lh.exports, e.curve = M1, e.curves = dh, e.ec = LE, e.eddsa = WE
})($2);
const VE = $2.ec,
    Oi = new VE("secp256k1"),
    Ft = Oi.curve,
    ur = Ft.n.constructor;

function GE(t, e) {
    let r = new ur(e);
    if (r.cmp(Ft.p) >= 0) return null;
    r = r.toRed(Ft.red);
    let n = r.redSqr().redIMul(r).redIAdd(Ft.b).redSqrt();
    return t === 3 !== n.isOdd() && (n = n.redNeg()), Oi.keyPair({
        pub: {
            x: r,
            y: n
        }
    })
}

function YE(t, e, r) {
    let n = new ur(e),
        i = new ur(r);
    if (n.cmp(Ft.p) >= 0 || i.cmp(Ft.p) >= 0 || (n = n.toRed(Ft.red), i = i.toRed(Ft.red), (t === 6 || t === 7) && i.isOdd() !== (t === 7))) return null;
    const s = n.redSqr().redIMul(n);
    return i.redSqr().redISub(s.redIAdd(Ft.b)).isZero() ? Oi.keyPair({
        pub: {
            x: n,
            y: i
        }
    }) : null
}

function _s(t) {
    const e = t[0];
    switch (e) {
        case 2:
        case 3:
            return t.length !== 33 ? null : GE(e, t.subarray(1, 33));
        case 4:
        case 6:
        case 7:
            return t.length !== 65 ? null : YE(e, t.subarray(1, 33), t.subarray(33, 65));
        default:
            return null
    }
}

function lo(t, e) {
    const r = e.encode(null, t.length === 33);
    for (let n = 0; n < t.length; ++n) t[n] = r[n]
}
var IT = {
        contextRandomize() {
            return 0
        },
        privateKeyVerify(t) {
            const e = new ur(t);
            return e.cmp(Ft.n) < 0 && !e.isZero() ? 0 : 1
        },
        privateKeyNegate(t) {
            const e = new ur(t),
                r = Ft.n.sub(e).umod(Ft.n).toArrayLike(Uint8Array, "be", 32);
            return t.set(r), 0
        },
        privateKeyTweakAdd(t, e) {
            const r = new ur(e);
            if (r.cmp(Ft.n) >= 0 || (r.iadd(new ur(t)), r.cmp(Ft.n) >= 0 && r.isub(Ft.n), r.isZero())) return 1;
            const n = r.toArrayLike(Uint8Array, "be", 32);
            return t.set(n), 0
        },
        privateKeyTweakMul(t, e) {
            let r = new ur(e);
            if (r.cmp(Ft.n) >= 0 || r.isZero()) return 1;
            r.imul(new ur(t)), r.cmp(Ft.n) >= 0 && (r = r.umod(Ft.n));
            const n = r.toArrayLike(Uint8Array, "be", 32);
            return t.set(n), 0
        },
        publicKeyVerify(t) {
            return _s(t) === null ? 1 : 0
        },
        publicKeyCreate(t, e) {
            const r = new ur(e);
            if (r.cmp(Ft.n) >= 0 || r.isZero()) return 1;
            const n = Oi.keyFromPrivate(e).getPublic();
            return lo(t, n), 0
        },
        publicKeyConvert(t, e) {
            const r = _s(e);
            if (r === null) return 1;
            const n = r.getPublic();
            return lo(t, n), 0
        },
        publicKeyNegate(t, e) {
            const r = _s(e);
            if (r === null) return 1;
            const n = r.getPublic();
            return n.y = n.y.redNeg(), lo(t, n), 0
        },
        publicKeyCombine(t, e) {
            const r = new Array(e.length);
            for (let i = 0; i < e.length; ++i)
                if (r[i] = _s(e[i]), r[i] === null) return 1;
            let n = r[0].getPublic();
            for (let i = 1; i < r.length; ++i) n = n.add(r[i].pub);
            return n.isInfinity() ? 2 : (lo(t, n), 0)
        },
        publicKeyTweakAdd(t, e, r) {
            const n = _s(e);
            if (n === null) return 1;
            if (r = new ur(r), r.cmp(Ft.n) >= 0) return 2;
            const i = n.getPublic().add(Ft.g.mul(r));
            return i.isInfinity() ? 2 : (lo(t, i), 0)
        },
        publicKeyTweakMul(t, e, r) {
            const n = _s(e);
            if (n === null) return 1;
            if (r = new ur(r), r.cmp(Ft.n) >= 0 || r.isZero()) return 2;
            const i = n.getPublic().mul(r);
            return lo(t, i), 0
        },
        signatureNormalize(t) {
            const e = new ur(t.subarray(0, 32)),
                r = new ur(t.subarray(32, 64));
            return e.cmp(Ft.n) >= 0 || r.cmp(Ft.n) >= 0 ? 1 : (r.cmp(Oi.nh) === 1 && t.set(Ft.n.sub(r).toArrayLike(Uint8Array, "be", 32), 32), 0)
        },
        signatureExport(t, e) {
            const r = e.subarray(0, 32),
                n = e.subarray(32, 64);
            if (new ur(r).cmp(Ft.n) >= 0 || new ur(n).cmp(Ft.n) >= 0) return 1;
            const {
                output: i
            } = t;
            let s = i.subarray(4, 4 + 33);
            s[0] = 0, s.set(r, 1);
            let o = 33,
                a = 0;
            for (; o > 1 && s[a] === 0 && !(s[a + 1] & 128); --o, ++a);
            if (s = s.subarray(a), s[0] & 128 || o > 1 && s[0] === 0 && !(s[1] & 128)) return 1;
            let c = i.subarray(6 + 33, 6 + 33 + 33);
            c[0] = 0, c.set(n, 1);
            let d = 33,
                y = 0;
            for (; d > 1 && c[y] === 0 && !(c[y + 1] & 128); --d, ++y);
            return c = c.subarray(y), c[0] & 128 || d > 1 && c[0] === 0 && !(c[1] & 128) ? 1 : (t.outputlen = 6 + o + d, i[0] = 48, i[1] = t.outputlen - 2, i[2] = 2, i[3] = s.length, i.set(s, 4), i[4 + o] = 2, i[5 + o] = c.length, i.set(c, 6 + o), 0)
        },
        signatureImport(t, e) {
            if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return 1;
            const r = e[3];
            if (r === 0 || 5 + r >= e.length || e[4 + r] !== 2) return 1;
            const n = e[5 + r];
            if (n === 0 || 6 + r + n !== e.length || e[4] & 128 || r > 1 && e[4] === 0 && !(e[5] & 128) || e[r + 6] & 128 || n > 1 && e[r + 6] === 0 && !(e[r + 7] & 128)) return 1;
            let i = e.subarray(4, 4 + r);
            if (i.length === 33 && i[0] === 0 && (i = i.subarray(1)), i.length > 32) return 1;
            let s = e.subarray(6 + r);
            if (s.length === 33 && s[0] === 0 && (s = s.slice(1)), s.length > 32) throw new Error("S length is too long");
            let o = new ur(i);
            o.cmp(Ft.n) >= 0 && (o = new ur(0));
            let a = new ur(e.subarray(6 + r));
            return a.cmp(Ft.n) >= 0 && (a = new ur(0)), t.set(o.toArrayLike(Uint8Array, "be", 32), 0), t.set(a.toArrayLike(Uint8Array, "be", 32), 32), 0
        },
        ecdsaSign(t, e, r, n, i) {
            if (i) {
                const a = i;
                i = c => {
                    const d = a(e, r, null, n, c);
                    if (!(d instanceof Uint8Array && d.length === 32)) throw new Error("This is the way");
                    return new ur(d)
                }
            }
            const s = new ur(r);
            if (s.cmp(Ft.n) >= 0 || s.isZero()) return 1;
            let o;
            try {
                o = Oi.sign(e, r, {
                    canonical: !0,
                    k: i,
                    pers: n
                })
            } catch {
                return 1
            }
            return t.signature.set(o.r.toArrayLike(Uint8Array, "be", 32), 0), t.signature.set(o.s.toArrayLike(Uint8Array, "be", 32), 32), t.recid = o.recoveryParam, 0
        },
        ecdsaVerify(t, e, r) {
            const n = {
                    r: t.subarray(0, 32),
                    s: t.subarray(32, 64)
                },
                i = new ur(n.r),
                s = new ur(n.s);
            if (i.cmp(Ft.n) >= 0 || s.cmp(Ft.n) >= 0) return 1;
            if (s.cmp(Oi.nh) === 1 || i.isZero() || s.isZero()) return 3;
            const o = _s(r);
            if (o === null) return 2;
            const a = o.getPublic();
            return Oi.verify(e, n, a) ? 0 : 3
        },
        ecdsaRecover(t, e, r, n) {
            const i = {
                    r: e.slice(0, 32),
                    s: e.slice(32, 64)
                },
                s = new ur(i.r),
                o = new ur(i.s);
            if (s.cmp(Ft.n) >= 0 || o.cmp(Ft.n) >= 0) return 1;
            if (s.isZero() || o.isZero()) return 2;
            let a;
            try {
                a = Oi.recoverPubKey(n, i, r)
            } catch {
                return 2
            }
            return lo(t, a), 0
        },
        ecdh(t, e, r, n, i, s, o) {
            const a = _s(e);
            if (a === null) return 1;
            const c = new ur(r);
            if (c.cmp(Ft.n) >= 0 || c.isZero()) return 2;
            const d = a.getPublic().mul(c);
            if (i === void 0) {
                const y = d.encode(null, !0),
                    I = Oi.hash().update(y).digest();
                for (let N = 0; N < 32; ++N) t[N] = I[N]
            } else {
                s || (s = new Uint8Array(32));
                const y = d.getX().toArray("be", 32);
                for (let T = 0; T < 32; ++T) s[T] = y[T];
                o || (o = new Uint8Array(32));
                const I = d.getY().toArray("be", 32);
                for (let T = 0; T < 32; ++T) o[T] = I[T];
                const N = i(s, o, n);
                if (!(N instanceof Uint8Array && N.length === t.length)) return 2;
                t.set(N)
            }
            return 0
        }
    },
    KE = {
        exports: {}
    };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(t) {
    (function() {
        var e = "input is invalid type",
            r = "finalize already called",
            n = typeof window == "object",
            i = n ? window : {};
        i.JS_SHA3_NO_WINDOW && (n = !1);
        var s = !n && typeof self == "object",
            o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
        o ? i = zn : s && (i = self);
        var a = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports,
            c = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined",
            d = "0123456789abcdef".split(""),
            y = [31, 7936, 2031616, 520093696],
            I = [4, 1024, 262144, 67108864],
            N = [1, 256, 65536, 16777216],
            E = [6, 1536, 393216, 100663296],
            T = [0, 8, 16, 24],
            j = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
            V = [224, 256, 384, 512],
            P = [128, 256],
            O = ["hex", "buffer", "arrayBuffer", "array", "digest"],
            R = {
                128: 168,
                256: 136
            };
        (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(k) {
            return Object.prototype.toString.call(k) === "[object Array]"
        }), c && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(k) {
            return typeof k == "object" && k.buffer && k.buffer.constructor === ArrayBuffer
        });
        for (var q = function(k, X, re) {
                return function(ae) {
                    return new x(k, X, k).update(ae)[re]()
                }
            }, W = function(k, X, re) {
                return function(ae, le) {
                    return new x(k, X, le).update(ae)[re]()
                }
            }, Y = function(k, X, re) {
                return function(ae, le, Me, Re) {
                    return f["cshake" + k].update(ae, le, Me, Re)[re]()
                }
            }, G = function(k, X, re) {
                return function(ae, le, Me, Re) {
                    return f["kmac" + k].update(ae, le, Me, Re)[re]()
                }
            }, J = function(k, X, re, ae) {
                for (var le = 0; le < O.length; ++le) {
                    var Me = O[le];
                    k[Me] = X(re, ae, Me)
                }
                return k
            }, pe = function(k, X) {
                var re = q(k, X, "hex");
                return re.create = function() {
                    return new x(k, X, k)
                }, re.update = function(ae) {
                    return re.create().update(ae)
                }, J(re, q, k, X)
            }, we = function(k, X) {
                var re = W(k, X, "hex");
                return re.create = function(ae) {
                    return new x(k, X, ae)
                }, re.update = function(ae, le) {
                    return re.create(le).update(ae)
                }, J(re, W, k, X)
            }, H = function(k, X) {
                var re = R[k],
                    ae = Y(k, X, "hex");
                return ae.create = function(le, Me, Re) {
                    return !Me && !Re ? f["shake" + k].create(le) : new x(k, X, le).bytepad([Me, Re], re)
                }, ae.update = function(le, Me, Re, ve) {
                    return ae.create(Me, Re, ve).update(le)
                }, J(ae, Y, k, X)
            }, w = function(k, X) {
                var re = R[k],
                    ae = G(k, X, "hex");
                return ae.create = function(le, Me, Re) {
                    return new z(k, X, Me).bytepad(["KMAC", Re], re).bytepad([le], re)
                }, ae.update = function(le, Me, Re, ve) {
                    return ae.create(le, Re, ve).update(Me)
                }, J(ae, G, k, X)
            }, p = [{
                name: "keccak",
                padding: N,
                bits: V,
                createMethod: pe
            }, {
                name: "sha3",
                padding: E,
                bits: V,
                createMethod: pe
            }, {
                name: "shake",
                padding: y,
                bits: P,
                createMethod: we
            }, {
                name: "cshake",
                padding: I,
                bits: P,
                createMethod: H
            }, {
                name: "kmac",
                padding: I,
                bits: P,
                createMethod: w
            }], f = {}, h = [], b = 0; b < p.length; ++b)
            for (var C = p[b], _ = C.bits, M = 0; M < _.length; ++M) {
                var m = C.name + "_" + _[M];
                if (h.push(m), f[m] = C.createMethod(_[M], C.padding), C.name !== "sha3") {
                    var A = C.name + _[M];
                    h.push(A), f[A] = f[m]
                }
            }

        function x(k, X, re) {
            this.blocks = [], this.s = [], this.padding = X, this.outputBits = re, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (k << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = re >> 5, this.extraBytes = (re & 31) >> 3;
            for (var ae = 0; ae < 50; ++ae) this.s[ae] = 0
        }
        x.prototype.update = function(k) {
            if (this.finalized) throw new Error(r);
            var X, re = typeof k;
            if (re !== "string") {
                if (re === "object") {
                    if (k === null) throw new Error(e);
                    if (c && k.constructor === ArrayBuffer) k = new Uint8Array(k);
                    else if (!Array.isArray(k) && (!c || !ArrayBuffer.isView(k))) throw new Error(e)
                } else throw new Error(e);
                X = !0
            }
            for (var ae = this.blocks, le = this.byteCount, Me = k.length, Re = this.blockCount, ve = 0, We = this.s, Ie, Ue; ve < Me;) {
                if (this.reset)
                    for (this.reset = !1, ae[0] = this.block, Ie = 1; Ie < Re + 1; ++Ie) ae[Ie] = 0;
                if (X)
                    for (Ie = this.start; ve < Me && Ie < le; ++ve) ae[Ie >> 2] |= k[ve] << T[Ie++ & 3];
                else
                    for (Ie = this.start; ve < Me && Ie < le; ++ve) Ue = k.charCodeAt(ve), Ue < 128 ? ae[Ie >> 2] |= Ue << T[Ie++ & 3] : Ue < 2048 ? (ae[Ie >> 2] |= (192 | Ue >> 6) << T[Ie++ & 3], ae[Ie >> 2] |= (128 | Ue & 63) << T[Ie++ & 3]) : Ue < 55296 || Ue >= 57344 ? (ae[Ie >> 2] |= (224 | Ue >> 12) << T[Ie++ & 3], ae[Ie >> 2] |= (128 | Ue >> 6 & 63) << T[Ie++ & 3], ae[Ie >> 2] |= (128 | Ue & 63) << T[Ie++ & 3]) : (Ue = 65536 + ((Ue & 1023) << 10 | k.charCodeAt(++ve) & 1023), ae[Ie >> 2] |= (240 | Ue >> 18) << T[Ie++ & 3], ae[Ie >> 2] |= (128 | Ue >> 12 & 63) << T[Ie++ & 3], ae[Ie >> 2] |= (128 | Ue >> 6 & 63) << T[Ie++ & 3], ae[Ie >> 2] |= (128 | Ue & 63) << T[Ie++ & 3]);
                if (this.lastByteIndex = Ie, Ie >= le) {
                    for (this.start = Ie - le, this.block = ae[Re], Ie = 0; Ie < Re; ++Ie) We[Ie] ^= ae[Ie];
                    oe(We), this.reset = !0
                } else this.start = Ie
            }
            return this
        }, x.prototype.encode = function(k, X) {
            var re = k & 255,
                ae = 1,
                le = [re];
            for (k = k >> 8, re = k & 255; re > 0;) le.unshift(re), k = k >> 8, re = k & 255, ++ae;
            return X ? le.push(ae) : le.unshift(ae), this.update(le), le.length
        }, x.prototype.encodeString = function(k) {
            var X, re = typeof k;
            if (re !== "string") {
                if (re === "object") {
                    if (k === null) throw new Error(e);
                    if (c && k.constructor === ArrayBuffer) k = new Uint8Array(k);
                    else if (!Array.isArray(k) && (!c || !ArrayBuffer.isView(k))) throw new Error(e)
                } else throw new Error(e);
                X = !0
            }
            var ae = 0,
                le = k.length;
            if (X) ae = le;
            else
                for (var Me = 0; Me < k.length; ++Me) {
                    var Re = k.charCodeAt(Me);
                    Re < 128 ? ae += 1 : Re < 2048 ? ae += 2 : Re < 55296 || Re >= 57344 ? ae += 3 : (Re = 65536 + ((Re & 1023) << 10 | k.charCodeAt(++Me) & 1023), ae += 4)
                }
            return ae += this.encode(ae * 8), this.update(k), ae
        }, x.prototype.bytepad = function(k, X) {
            for (var re = this.encode(X), ae = 0; ae < k.length; ++ae) re += this.encodeString(k[ae]);
            var le = X - re % X,
                Me = [];
            return Me.length = le, this.update(Me), this
        }, x.prototype.finalize = function() {
            if (!this.finalized) {
                this.finalized = !0;
                var k = this.blocks,
                    X = this.lastByteIndex,
                    re = this.blockCount,
                    ae = this.s;
                if (k[X >> 2] |= this.padding[X & 3], this.lastByteIndex === this.byteCount)
                    for (k[0] = k[re], X = 1; X < re + 1; ++X) k[X] = 0;
                for (k[re - 1] |= 2147483648, X = 0; X < re; ++X) ae[X] ^= k[X];
                oe(ae)
            }
        }, x.prototype.toString = x.prototype.hex = function() {
            this.finalize();
            for (var k = this.blockCount, X = this.s, re = this.outputBlocks, ae = this.extraBytes, le = 0, Me = 0, Re = "", ve; Me < re;) {
                for (le = 0; le < k && Me < re; ++le, ++Me) ve = X[le], Re += d[ve >> 4 & 15] + d[ve & 15] + d[ve >> 12 & 15] + d[ve >> 8 & 15] + d[ve >> 20 & 15] + d[ve >> 16 & 15] + d[ve >> 28 & 15] + d[ve >> 24 & 15];
                Me % k === 0 && (oe(X), le = 0)
            }
            return ae && (ve = X[le], Re += d[ve >> 4 & 15] + d[ve & 15], ae > 1 && (Re += d[ve >> 12 & 15] + d[ve >> 8 & 15]), ae > 2 && (Re += d[ve >> 20 & 15] + d[ve >> 16 & 15])), Re
        }, x.prototype.arrayBuffer = function() {
            this.finalize();
            var k = this.blockCount,
                X = this.s,
                re = this.outputBlocks,
                ae = this.extraBytes,
                le = 0,
                Me = 0,
                Re = this.outputBits >> 3,
                ve;
            ae ? ve = new ArrayBuffer(re + 1 << 2) : ve = new ArrayBuffer(Re);
            for (var We = new Uint32Array(ve); Me < re;) {
                for (le = 0; le < k && Me < re; ++le, ++Me) We[Me] = X[le];
                Me % k === 0 && oe(X)
            }
            return ae && (We[le] = X[le], ve = ve.slice(0, Re)), ve
        }, x.prototype.buffer = x.prototype.arrayBuffer, x.prototype.digest = x.prototype.array = function() {
            this.finalize();
            for (var k = this.blockCount, X = this.s, re = this.outputBlocks, ae = this.extraBytes, le = 0, Me = 0, Re = [], ve, We; Me < re;) {
                for (le = 0; le < k && Me < re; ++le, ++Me) ve = Me << 2, We = X[le], Re[ve] = We & 255, Re[ve + 1] = We >> 8 & 255, Re[ve + 2] = We >> 16 & 255, Re[ve + 3] = We >> 24 & 255;
                Me % k === 0 && oe(X)
            }
            return ae && (ve = Me << 2, We = X[le], Re[ve] = We & 255, ae > 1 && (Re[ve + 1] = We >> 8 & 255), ae > 2 && (Re[ve + 2] = We >> 16 & 255)), Re
        };

        function z(k, X, re) {
            x.call(this, k, X, re)
        }
        z.prototype = new x, z.prototype.finalize = function() {
            return this.encode(this.outputBits, !0), x.prototype.finalize.call(this)
        };
        var oe = function(k) {
            var X, re, ae, le, Me, Re, ve, We, Ie, Ue, Ut, It, it, At, Ct, Ye, Xe, St, Ze, ft, Ot, v, u, l, S, D, $, Q, he, Be, ge, Te, Se, ot, Gt, Zt, ht, tr, Nt, et, Lt, Yt, ct, Jt, rr, Ve, Xt, B, L, F, g, U, Z, ee, te, fe, Ae, ye, dt, Ne, Ge, Ke, Je;
            for (ae = 0; ae < 48; ae += 2) le = k[0] ^ k[10] ^ k[20] ^ k[30] ^ k[40], Me = k[1] ^ k[11] ^ k[21] ^ k[31] ^ k[41], Re = k[2] ^ k[12] ^ k[22] ^ k[32] ^ k[42], ve = k[3] ^ k[13] ^ k[23] ^ k[33] ^ k[43], We = k[4] ^ k[14] ^ k[24] ^ k[34] ^ k[44], Ie = k[5] ^ k[15] ^ k[25] ^ k[35] ^ k[45], Ue = k[6] ^ k[16] ^ k[26] ^ k[36] ^ k[46], Ut = k[7] ^ k[17] ^ k[27] ^ k[37] ^ k[47], It = k[8] ^ k[18] ^ k[28] ^ k[38] ^ k[48], it = k[9] ^ k[19] ^ k[29] ^ k[39] ^ k[49], X = It ^ (Re << 1 | ve >>> 31), re = it ^ (ve << 1 | Re >>> 31), k[0] ^= X, k[1] ^= re, k[10] ^= X, k[11] ^= re, k[20] ^= X, k[21] ^= re, k[30] ^= X, k[31] ^= re, k[40] ^= X, k[41] ^= re, X = le ^ (We << 1 | Ie >>> 31), re = Me ^ (Ie << 1 | We >>> 31), k[2] ^= X, k[3] ^= re, k[12] ^= X, k[13] ^= re, k[22] ^= X, k[23] ^= re, k[32] ^= X, k[33] ^= re, k[42] ^= X, k[43] ^= re, X = Re ^ (Ue << 1 | Ut >>> 31), re = ve ^ (Ut << 1 | Ue >>> 31), k[4] ^= X, k[5] ^= re, k[14] ^= X, k[15] ^= re, k[24] ^= X, k[25] ^= re, k[34] ^= X, k[35] ^= re, k[44] ^= X, k[45] ^= re, X = We ^ (It << 1 | it >>> 31), re = Ie ^ (it << 1 | It >>> 31), k[6] ^= X, k[7] ^= re, k[16] ^= X, k[17] ^= re, k[26] ^= X, k[27] ^= re, k[36] ^= X, k[37] ^= re, k[46] ^= X, k[47] ^= re, X = Ue ^ (le << 1 | Me >>> 31), re = Ut ^ (Me << 1 | le >>> 31), k[8] ^= X, k[9] ^= re, k[18] ^= X, k[19] ^= re, k[28] ^= X, k[29] ^= re, k[38] ^= X, k[39] ^= re, k[48] ^= X, k[49] ^= re, At = k[0], Ct = k[1], Ve = k[11] << 4 | k[10] >>> 28, Xt = k[10] << 4 | k[11] >>> 28, Q = k[20] << 3 | k[21] >>> 29, he = k[21] << 3 | k[20] >>> 29, Ne = k[31] << 9 | k[30] >>> 23, Ge = k[30] << 9 | k[31] >>> 23, Yt = k[40] << 18 | k[41] >>> 14, ct = k[41] << 18 | k[40] >>> 14, ot = k[2] << 1 | k[3] >>> 31, Gt = k[3] << 1 | k[2] >>> 31, Ye = k[13] << 12 | k[12] >>> 20, Xe = k[12] << 12 | k[13] >>> 20, B = k[22] << 10 | k[23] >>> 22, L = k[23] << 10 | k[22] >>> 22, Be = k[33] << 13 | k[32] >>> 19, ge = k[32] << 13 | k[33] >>> 19, Ke = k[42] << 2 | k[43] >>> 30, Je = k[43] << 2 | k[42] >>> 30, ee = k[5] << 30 | k[4] >>> 2, te = k[4] << 30 | k[5] >>> 2, Zt = k[14] << 6 | k[15] >>> 26, ht = k[15] << 6 | k[14] >>> 26, St = k[25] << 11 | k[24] >>> 21, Ze = k[24] << 11 | k[25] >>> 21, F = k[34] << 15 | k[35] >>> 17, g = k[35] << 15 | k[34] >>> 17, Te = k[45] << 29 | k[44] >>> 3, Se = k[44] << 29 | k[45] >>> 3, l = k[6] << 28 | k[7] >>> 4, S = k[7] << 28 | k[6] >>> 4, fe = k[17] << 23 | k[16] >>> 9, Ae = k[16] << 23 | k[17] >>> 9, tr = k[26] << 25 | k[27] >>> 7, Nt = k[27] << 25 | k[26] >>> 7, ft = k[36] << 21 | k[37] >>> 11, Ot = k[37] << 21 | k[36] >>> 11, U = k[47] << 24 | k[46] >>> 8, Z = k[46] << 24 | k[47] >>> 8, Jt = k[8] << 27 | k[9] >>> 5, rr = k[9] << 27 | k[8] >>> 5, D = k[18] << 20 | k[19] >>> 12, $ = k[19] << 20 | k[18] >>> 12, ye = k[29] << 7 | k[28] >>> 25, dt = k[28] << 7 | k[29] >>> 25, et = k[38] << 8 | k[39] >>> 24, Lt = k[39] << 8 | k[38] >>> 24, v = k[48] << 14 | k[49] >>> 18, u = k[49] << 14 | k[48] >>> 18, k[0] = At ^ ~Ye & St, k[1] = Ct ^ ~Xe & Ze, k[10] = l ^ ~D & Q, k[11] = S ^ ~$ & he, k[20] = ot ^ ~Zt & tr, k[21] = Gt ^ ~ht & Nt, k[30] = Jt ^ ~Ve & B, k[31] = rr ^ ~Xt & L, k[40] = ee ^ ~fe & ye, k[41] = te ^ ~Ae & dt, k[2] = Ye ^ ~St & ft, k[3] = Xe ^ ~Ze & Ot, k[12] = D ^ ~Q & Be, k[13] = $ ^ ~he & ge, k[22] = Zt ^ ~tr & et, k[23] = ht ^ ~Nt & Lt, k[32] = Ve ^ ~B & F, k[33] = Xt ^ ~L & g, k[42] = fe ^ ~ye & Ne, k[43] = Ae ^ ~dt & Ge, k[4] = St ^ ~ft & v, k[5] = Ze ^ ~Ot & u, k[14] = Q ^ ~Be & Te, k[15] = he ^ ~ge & Se, k[24] = tr ^ ~et & Yt, k[25] = Nt ^ ~Lt & ct, k[34] = B ^ ~F & U, k[35] = L ^ ~g & Z, k[44] = ye ^ ~Ne & Ke, k[45] = dt ^ ~Ge & Je, k[6] = ft ^ ~v & At, k[7] = Ot ^ ~u & Ct, k[16] = Be ^ ~Te & l, k[17] = ge ^ ~Se & S, k[26] = et ^ ~Yt & ot, k[27] = Lt ^ ~ct & Gt, k[36] = F ^ ~U & Jt, k[37] = g ^ ~Z & rr, k[46] = Ne ^ ~Ke & ee, k[47] = Ge ^ ~Je & te, k[8] = v ^ ~At & Ye, k[9] = u ^ ~Ct & Xe, k[18] = Te ^ ~l & D, k[19] = Se ^ ~S & $, k[28] = Yt ^ ~ot & Zt, k[29] = ct ^ ~Gt & ht, k[38] = U ^ ~Jt & Ve, k[39] = Z ^ ~rr & Xt, k[48] = Ke ^ ~ee & fe, k[49] = Je ^ ~te & Ae, k[0] ^= j[ae], k[1] ^= j[ae + 1]
        };
        if (a) t.exports = f;
        else
            for (b = 0; b < h.length; ++b) i[h[b]] = f[h[b]]
    })()
})(KE);
const Bl = t => Et.Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? Et.Buffer.from(t.buffer, t.byteOffset, t.byteLength) : Et.Buffer.from(t);
var mx = {},
    Pt = {},
    kl = vx;

function vx(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
vx.equal = function(e, r, n) {
    if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r)
};
var Qd = {
    exports: {}
};
typeof Object.create == "function" ? Qd.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }))
} : Qd.exports = function(e, r) {
    if (r) {
        e.super_ = r;
        var n = function() {};
        n.prototype = r.prototype, e.prototype = new n, e.prototype.constructor = e
    }
};
var ZE = kl,
    JE = Qd.exports;
Pt.inherits = JE;

function XE(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320
}

function e8(t, e) {
    if (Array.isArray(t)) return t.slice();
    if (!t) return [];
    var r = [];
    if (typeof t == "string")
        if (e) {
            if (e === "hex")
                for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2) r.push(parseInt(t[i] + t[i + 1], 16))
        } else
            for (var n = 0, i = 0; i < t.length; i++) {
                var s = t.charCodeAt(i);
                s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = s & 63 | 128) : XE(t, i) ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128)
            } else
                for (i = 0; i < t.length; i++) r[i] = t[i] | 0;
    return r
}
Pt.toArray = e8;

function t8(t) {
    for (var e = "", r = 0; r < t.length; r++) e += yx(t[r].toString(16));
    return e
}
Pt.toHex = t8;

function gx(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0
}
Pt.htonl = gx;

function r8(t, e) {
    for (var r = "", n = 0; n < t.length; n++) {
        var i = t[n];
        e === "little" && (i = gx(i)), r += wx(i.toString(16))
    }
    return r
}
Pt.toHex32 = r8;

function yx(t) {
    return t.length === 1 ? "0" + t : t
}
Pt.zero2 = yx;

function wx(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t
}
Pt.zero8 = wx;

function n8(t, e, r, n) {
    var i = r - e;
    ZE(i % 4 === 0);
    for (var s = new Array(i / 4), o = 0, a = e; o < s.length; o++, a += 4) {
        var c;
        n === "big" ? c = t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3] : c = t[a + 3] << 24 | t[a + 2] << 16 | t[a + 1] << 8 | t[a], s[o] = c >>> 0
    }
    return s
}
Pt.join32 = n8;

function i8(t, e) {
    for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
        var s = t[n];
        e === "big" ? (r[i] = s >>> 24, r[i + 1] = s >>> 16 & 255, r[i + 2] = s >>> 8 & 255, r[i + 3] = s & 255) : (r[i + 3] = s >>> 24, r[i + 2] = s >>> 16 & 255, r[i + 1] = s >>> 8 & 255, r[i] = s & 255)
    }
    return r
}
Pt.split32 = i8;

function s8(t, e) {
    return t >>> e | t << 32 - e
}
Pt.rotr32 = s8;

function o8(t, e) {
    return t << e | t >>> 32 - e
}
Pt.rotl32 = o8;

function a8(t, e) {
    return t + e >>> 0
}
Pt.sum32 = a8;

function u8(t, e, r) {
    return t + e + r >>> 0
}
Pt.sum32_3 = u8;

function l8(t, e, r, n) {
    return t + e + r + n >>> 0
}
Pt.sum32_4 = l8;

function f8(t, e, r, n, i) {
    return t + e + r + n + i >>> 0
}
Pt.sum32_5 = f8;

function c8(t, e, r, n) {
    var i = t[e],
        s = t[e + 1],
        o = n + s >>> 0,
        a = (o < n ? 1 : 0) + r + i;
    t[e] = a >>> 0, t[e + 1] = o
}
Pt.sum64 = c8;

function h8(t, e, r, n) {
    var i = e + n >>> 0,
        s = (i < e ? 1 : 0) + t + r;
    return s >>> 0
}
Pt.sum64_hi = h8;

function d8(t, e, r, n) {
    var i = e + n;
    return i >>> 0
}
Pt.sum64_lo = d8;

function p8(t, e, r, n, i, s, o, a) {
    var c = 0,
        d = e;
    d = d + n >>> 0, c += d < e ? 1 : 0, d = d + s >>> 0, c += d < s ? 1 : 0, d = d + a >>> 0, c += d < a ? 1 : 0;
    var y = t + r + i + o + c;
    return y >>> 0
}
Pt.sum64_4_hi = p8;

function m8(t, e, r, n, i, s, o, a) {
    var c = e + n + s + a;
    return c >>> 0
}
Pt.sum64_4_lo = m8;

function v8(t, e, r, n, i, s, o, a, c, d) {
    var y = 0,
        I = e;
    I = I + n >>> 0, y += I < e ? 1 : 0, I = I + s >>> 0, y += I < s ? 1 : 0, I = I + a >>> 0, y += I < a ? 1 : 0, I = I + d >>> 0, y += I < d ? 1 : 0;
    var N = t + r + i + o + c + y;
    return N >>> 0
}
Pt.sum64_5_hi = v8;

function g8(t, e, r, n, i, s, o, a, c, d) {
    var y = e + n + s + a + d;
    return y >>> 0
}
Pt.sum64_5_lo = g8;

function y8(t, e, r) {
    var n = e << 32 - r | t >>> r;
    return n >>> 0
}
Pt.rotr64_hi = y8;

function w8(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0
}
Pt.rotr64_lo = w8;

function x8(t, e, r) {
    return t >>> r
}
Pt.shr64_hi = x8;

function b8(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0
}
Pt.shr64_lo = b8;
var Za = {},
    Iv = Pt,
    A8 = kl;

function xh() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
}
Za.BlockHash = xh;
xh.prototype.update = function(e, r) {
    if (e = Iv.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var n = e.length % this._delta8;
        this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = Iv.join32(e, 0, e.length - n, this.endian);
        for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
    }
    return this
};
xh.prototype.digest = function(e) {
    return this.update(this._pad()), A8(this.pending === null), this._digest(e)
};
xh.prototype._pad = function() {
    var e = this.pendingTotal,
        r = this._delta8,
        n = r - (e + this.padLength) % r,
        i = new Array(n + this.padLength);
    i[0] = 128;
    for (var s = 1; s < n; s++) i[s] = 0;
    if (e <<= 3, this.endian === "big") {
        for (var o = 8; o < this.padLength; o++) i[s++] = 0;
        i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255
    } else
        for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, o = 8; o < this.padLength; o++) i[s++] = 0;
    return i
};
var Ja = {},
    ns = {},
    S8 = Pt,
    $i = S8.rotr32;

function M8(t, e, r, n) {
    if (t === 0) return xx(e, r, n);
    if (t === 1 || t === 3) return Ax(e, r, n);
    if (t === 2) return bx(e, r, n)
}
ns.ft_1 = M8;

function xx(t, e, r) {
    return t & e ^ ~t & r
}
ns.ch32 = xx;

function bx(t, e, r) {
    return t & e ^ t & r ^ e & r
}
ns.maj32 = bx;

function Ax(t, e, r) {
    return t ^ e ^ r
}
ns.p32 = Ax;

function E8(t) {
    return $i(t, 2) ^ $i(t, 13) ^ $i(t, 22)
}
ns.s0_256 = E8;

function _8(t) {
    return $i(t, 6) ^ $i(t, 11) ^ $i(t, 25)
}
ns.s1_256 = _8;

function I8(t) {
    return $i(t, 7) ^ $i(t, 18) ^ t >>> 3
}
ns.g0_256 = I8;

function C8(t) {
    return $i(t, 17) ^ $i(t, 19) ^ t >>> 10
}
ns.g1_256 = C8;
var Na = Pt,
    B8 = Za,
    k8 = ns,
    M0 = Na.rotl32,
    wu = Na.sum32,
    N8 = Na.sum32_5,
    T8 = k8.ft_1,
    Sx = B8.BlockHash,
    O8 = [1518500249, 1859775393, 2400959708, 3395469782];

function Gi() {
    if (!(this instanceof Gi)) return new Gi;
    Sx.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
}
Na.inherits(Gi, Sx);
var R8 = Gi;
Gi.blockSize = 512;
Gi.outSize = 160;
Gi.hmacStrength = 80;
Gi.padLength = 64;
Gi.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
    for (; i < n.length; i++) n[i] = M0(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
    var s = this.h[0],
        o = this.h[1],
        a = this.h[2],
        c = this.h[3],
        d = this.h[4];
    for (i = 0; i < n.length; i++) {
        var y = ~~(i / 20),
            I = N8(M0(s, 5), T8(y, o, a, c), d, n[i], O8[y]);
        d = c, c = a, a = M0(o, 30), o = s, s = I
    }
    this.h[0] = wu(this.h[0], s), this.h[1] = wu(this.h[1], o), this.h[2] = wu(this.h[2], a), this.h[3] = wu(this.h[3], c), this.h[4] = wu(this.h[4], d)
};
Gi.prototype._digest = function(e) {
    return e === "hex" ? Na.toHex32(this.h, "big") : Na.split32(this.h, "big")
};
var Ta = Pt,
    D8 = Za,
    Xa = ns,
    P8 = kl,
    pi = Ta.sum32,
    L8 = Ta.sum32_4,
    F8 = Ta.sum32_5,
    U8 = Xa.ch32,
    z8 = Xa.maj32,
    j8 = Xa.s0_256,
    $8 = Xa.s1_256,
    H8 = Xa.g0_256,
    Q8 = Xa.g1_256,
    Mx = D8.BlockHash,
    q8 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

function Yi() {
    if (!(this instanceof Yi)) return new Yi;
    Mx.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = q8, this.W = new Array(64)
}
Ta.inherits(Yi, Mx);
var Ex = Yi;
Yi.blockSize = 512;
Yi.outSize = 256;
Yi.hmacStrength = 192;
Yi.padLength = 64;
Yi.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
    for (; i < n.length; i++) n[i] = L8(Q8(n[i - 2]), n[i - 7], H8(n[i - 15]), n[i - 16]);
    var s = this.h[0],
        o = this.h[1],
        a = this.h[2],
        c = this.h[3],
        d = this.h[4],
        y = this.h[5],
        I = this.h[6],
        N = this.h[7];
    for (P8(this.k.length === n.length), i = 0; i < n.length; i++) {
        var E = F8(N, $8(d), U8(d, y, I), this.k[i], n[i]),
            T = pi(j8(s), z8(s, o, a));
        N = I, I = y, y = d, d = pi(c, E), c = a, a = o, o = s, s = pi(E, T)
    }
    this.h[0] = pi(this.h[0], s), this.h[1] = pi(this.h[1], o), this.h[2] = pi(this.h[2], a), this.h[3] = pi(this.h[3], c), this.h[4] = pi(this.h[4], d), this.h[5] = pi(this.h[5], y), this.h[6] = pi(this.h[6], I), this.h[7] = pi(this.h[7], N)
};
Yi.prototype._digest = function(e) {
    return e === "hex" ? Ta.toHex32(this.h, "big") : Ta.split32(this.h, "big")
};
var qd = Pt,
    _x = Ex;

function xs() {
    if (!(this instanceof xs)) return new xs;
    _x.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
}
qd.inherits(xs, _x);
var W8 = xs;
xs.blockSize = 512;
xs.outSize = 224;
xs.hmacStrength = 192;
xs.padLength = 64;
xs.prototype._digest = function(e) {
    return e === "hex" ? qd.toHex32(this.h.slice(0, 7), "big") : qd.split32(this.h.slice(0, 7), "big")
};
var Tn = Pt,
    V8 = Za,
    G8 = kl,
    Hi = Tn.rotr64_hi,
    Qi = Tn.rotr64_lo,
    Ix = Tn.shr64_hi,
    Cx = Tn.shr64_lo,
    Is = Tn.sum64,
    E0 = Tn.sum64_hi,
    _0 = Tn.sum64_lo,
    Y8 = Tn.sum64_4_hi,
    K8 = Tn.sum64_4_lo,
    Z8 = Tn.sum64_5_hi,
    J8 = Tn.sum64_5_lo,
    Bx = V8.BlockHash,
    X8 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

function Bi() {
    if (!(this instanceof Bi)) return new Bi;
    Bx.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = X8, this.W = new Array(160)
}
Tn.inherits(Bi, Bx);
var kx = Bi;
Bi.blockSize = 1024;
Bi.outSize = 512;
Bi.hmacStrength = 192;
Bi.padLength = 128;
Bi.prototype._prepareBlock = function(e, r) {
    for (var n = this.W, i = 0; i < 32; i++) n[i] = e[r + i];
    for (; i < n.length; i += 2) {
        var s = f5(n[i - 4], n[i - 3]),
            o = c5(n[i - 4], n[i - 3]),
            a = n[i - 14],
            c = n[i - 13],
            d = u5(n[i - 30], n[i - 29]),
            y = l5(n[i - 30], n[i - 29]),
            I = n[i - 32],
            N = n[i - 31];
        n[i] = Y8(s, o, a, c, d, y, I, N), n[i + 1] = K8(s, o, a, c, d, y, I, N)
    }
};
Bi.prototype._update = function(e, r) {
    this._prepareBlock(e, r);
    var n = this.W,
        i = this.h[0],
        s = this.h[1],
        o = this.h[2],
        a = this.h[3],
        c = this.h[4],
        d = this.h[5],
        y = this.h[6],
        I = this.h[7],
        N = this.h[8],
        E = this.h[9],
        T = this.h[10],
        j = this.h[11],
        V = this.h[12],
        P = this.h[13],
        O = this.h[14],
        R = this.h[15];
    G8(this.k.length === n.length);
    for (var q = 0; q < n.length; q += 2) {
        var W = O,
            Y = R,
            G = o5(N, E),
            J = a5(N, E),
            pe = e5(N, E, T, j, V),
            we = t5(N, E, T, j, V, P),
            H = this.k[q],
            w = this.k[q + 1],
            p = n[q],
            f = n[q + 1],
            h = Z8(W, Y, G, J, pe, we, H, w, p, f),
            b = J8(W, Y, G, J, pe, we, H, w, p, f);
        W = i5(i, s), Y = s5(i, s), G = r5(i, s, o, a, c), J = n5(i, s, o, a, c, d);
        var C = E0(W, Y, G, J),
            _ = _0(W, Y, G, J);
        O = V, R = P, V = T, P = j, T = N, j = E, N = E0(y, I, h, b), E = _0(I, I, h, b), y = c, I = d, c = o, d = a, o = i, a = s, i = E0(h, b, C, _), s = _0(h, b, C, _)
    }
    Is(this.h, 0, i, s), Is(this.h, 2, o, a), Is(this.h, 4, c, d), Is(this.h, 6, y, I), Is(this.h, 8, N, E), Is(this.h, 10, T, j), Is(this.h, 12, V, P), Is(this.h, 14, O, R)
};
Bi.prototype._digest = function(e) {
    return e === "hex" ? Tn.toHex32(this.h, "big") : Tn.split32(this.h, "big")
};

function e5(t, e, r, n, i) {
    var s = t & r ^ ~t & i;
    return s < 0 && (s += 4294967296), s
}

function t5(t, e, r, n, i, s) {
    var o = e & n ^ ~e & s;
    return o < 0 && (o += 4294967296), o
}

function r5(t, e, r, n, i) {
    var s = t & r ^ t & i ^ r & i;
    return s < 0 && (s += 4294967296), s
}

function n5(t, e, r, n, i, s) {
    var o = e & n ^ e & s ^ n & s;
    return o < 0 && (o += 4294967296), o
}

function i5(t, e) {
    var r = Hi(t, e, 28),
        n = Hi(e, t, 2),
        i = Hi(e, t, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function s5(t, e) {
    var r = Qi(t, e, 28),
        n = Qi(e, t, 2),
        i = Qi(e, t, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function o5(t, e) {
    var r = Hi(t, e, 14),
        n = Hi(t, e, 18),
        i = Hi(e, t, 9),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function a5(t, e) {
    var r = Qi(t, e, 14),
        n = Qi(t, e, 18),
        i = Qi(e, t, 9),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function u5(t, e) {
    var r = Hi(t, e, 1),
        n = Hi(t, e, 8),
        i = Ix(t, e, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function l5(t, e) {
    var r = Qi(t, e, 1),
        n = Qi(t, e, 8),
        i = Cx(t, e, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function f5(t, e) {
    var r = Hi(t, e, 19),
        n = Hi(e, t, 29),
        i = Ix(t, e, 6),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function c5(t, e) {
    var r = Qi(t, e, 19),
        n = Qi(e, t, 29),
        i = Cx(t, e, 6),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}
var Wd = Pt,
    Nx = kx;

function bs() {
    if (!(this instanceof bs)) return new bs;
    Nx.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
}
Wd.inherits(bs, Nx);
var h5 = bs;
bs.blockSize = 1024;
bs.outSize = 384;
bs.hmacStrength = 192;
bs.padLength = 128;
bs.prototype._digest = function(e) {
    return e === "hex" ? Wd.toHex32(this.h.slice(0, 12), "big") : Wd.split32(this.h.slice(0, 12), "big")
};
Ja.sha1 = R8;
Ja.sha224 = W8;
Ja.sha256 = Ex;
Ja.sha384 = h5;
Ja.sha512 = kx;
var Tx = {},
    Oo = Pt,
    d5 = Za,
    lf = Oo.rotl32,
    Cv = Oo.sum32,
    xu = Oo.sum32_3,
    Bv = Oo.sum32_4,
    Ox = d5.BlockHash;

function Ki() {
    if (!(this instanceof Ki)) return new Ki;
    Ox.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
}
Oo.inherits(Ki, Ox);
Tx.ripemd160 = Ki;
Ki.blockSize = 512;
Ki.outSize = 160;
Ki.hmacStrength = 192;
Ki.padLength = 64;
Ki.prototype._update = function(e, r) {
    for (var n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], c = n, d = i, y = s, I = o, N = a, E = 0; E < 80; E++) {
        var T = Cv(lf(Bv(n, kv(E, i, s, o), e[v5[E] + r], p5(E)), y5[E]), a);
        n = a, a = o, o = lf(s, 10), s = i, i = T, T = Cv(lf(Bv(c, kv(79 - E, d, y, I), e[g5[E] + r], m5(E)), w5[E]), N), c = N, N = I, I = lf(y, 10), y = d, d = T
    }
    T = xu(this.h[1], s, I), this.h[1] = xu(this.h[2], o, N), this.h[2] = xu(this.h[3], a, c), this.h[3] = xu(this.h[4], n, d), this.h[4] = xu(this.h[0], i, y), this.h[0] = T
};
Ki.prototype._digest = function(e) {
    return e === "hex" ? Oo.toHex32(this.h, "little") : Oo.split32(this.h, "little")
};

function kv(t, e, r, n) {
    return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n)
}

function p5(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838
}

function m5(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0
}
var v5 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
    g5 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
    y5 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
    w5 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
    x5 = Pt,
    b5 = kl;

function Oa(t, e, r) {
    if (!(this instanceof Oa)) return new Oa(t, e, r);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(x5.toArray(e, r))
}
var A5 = Oa;
Oa.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), b5(e.length <= this.blockSize);
    for (var r = e.length; r < this.blockSize; r++) e.push(0);
    for (r = 0; r < e.length; r++) e[r] ^= 54;
    for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++) e[r] ^= 106;
    this.outer = new this.Hash().update(e)
};
Oa.prototype.update = function(e, r) {
    return this.inner.update(e, r), this
};
Oa.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e)
};
(function(t) {
    var e = t;
    e.utils = Pt, e.common = Za, e.sha = Ja, e.ripemd = Tx, e.hmac = A5, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160
})(mx);
var S5 = mx;
const M5 = "logger/5.6.0";
let Nv = !1,
    Tv = !1;
const Nf = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let Ov = Nf.default,
    I0 = null;

function E5() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const Rv = E5();
var Vd;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(Vd || (Vd = {}));
var wi;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"
})(wi || (wi = {}));
const Dv = "0123456789abcdef";
class mr {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        Nf[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(Ov > Nf[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(mr.levels.DEBUG, e)
    }
    info(...e) {
        this._log(mr.levels.INFO, e)
    }
    warn(...e) {
        this._log(mr.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (Tv) return this.makeError("censored error", r, {});
        r || (r = mr.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(c => {
            const d = n[c];
            try {
                if (d instanceof Uint8Array) {
                    let y = "";
                    for (let I = 0; I < d.length; I++) y += Dv[d[I] >> 4], y += Dv[d[I] & 15];
                    i.push(c + "=Uint8Array(0x" + y + ")")
                } else i.push(c + "=" + JSON.stringify(d))
            } catch {
                i.push(c + "=" + JSON.stringify(n[c].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (r) {
            case wi.NUMERIC_FAULT:
                {
                    o = "NUMERIC_FAULT";
                    const c = e;
                    switch (c) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            o += "-" + c;
                            break;
                        case "negative-power":
                        case "negative-width":
                            o += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            o += "-unbound-result";
                            break
                    }
                    break
                }
            case wi.CALL_EXCEPTION:
            case wi.INSUFFICIENT_FUNDS:
            case wi.MISSING_NEW:
            case wi.NONCE_EXPIRED:
            case wi.REPLACEMENT_UNDERPRICED:
            case wi.TRANSACTION_REPLACED:
            case wi.UNPREDICTABLE_GAS_LIMIT:
                o = r;
                break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const a = new Error(e);
        return a.reason = s, a.code = r, Object.keys(n).forEach(function(c) {
            a[c] = n[c]
        }), a
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, mr.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        Rv && this.throwError("platform missing String.prototype.normalize", mr.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: Rv
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, mr.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, mr.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, mr.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, mr.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", mr.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", mr.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", mr.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return I0 || (I0 = new mr(M5)), I0
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", mr.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), Nv) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", mr.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        Tv = !!e, Nv = !!r
    }
    static setLogLevel(e) {
        const r = Nf[e.toLowerCase()];
        if (r == null) {
            mr.globalLogger().warn("invalid log level - " + e);
            return
        }
        Ov = r
    }
    static from(e) {
        return new mr(e)
    }
}
mr.errors = wi;
mr.levels = Vd;
const _5 = "bytes/5.6.0",
    C0 = new mr(_5);

function I5(t) {
    return !!t.toHexString
}

function Tf(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Tf(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function Pv(t) {
    return typeof t == "number" && t == t && t % 1 === 0
}

function C5(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !Pv(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!Pv(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function B5(t, e) {
    if (e || (e = {}), typeof t == "number") {
        C0.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), Tf(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), I5(t) && (t = t.toHexString()), k5(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : C0.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return Tf(new Uint8Array(n))
    }
    return C5(t) ? Tf(new Uint8Array(t)) : C0.throwArgumentError("invalid arrayify value", "value", t)
}

function k5(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const N5 = "sha2/5.6.0";
new mr(N5);

function Lv(t) {
    return "0x" + S5.sha256().update(B5(t)).digest("hex")
}
class T5 {
    constructor(e) {
        Object.assign(this, e)
    }
    encode() {
        return Et.Buffer.from(u2(Of, this))
    }
    static decode(e) {
        return l2(Of, this, e)
    }
    static decodeUnchecked(e) {
        return n2(Of, this, e)
    }
}
const Of = new Map,
    O5 = 32;

function R5(t) {
    return t._bn !== void 0
}
class bt extends T5 {
    constructor(e) {
        if (super({}), this._bn = void 0, R5(e)) this._bn = e._bn;
        else {
            if (typeof e == "string") {
                const r = Ln.decode(e);
                if (r.length != 32) throw new Error("Invalid public key input");
                this._bn = new l0(r)
            } else this._bn = new l0(e);
            if (this._bn.byteLength() > 32) throw new Error("Invalid public key input")
        }
    }
    equals(e) {
        return this._bn.eq(e._bn)
    }
    toBase58() {
        return Ln.encode(this.toBytes())
    }
    toJSON() {
        return this.toBase58()
    }
    toBytes() {
        return this.toBuffer()
    }
    toBuffer() {
        const e = this._bn.toArrayLike(Et.Buffer);
        if (e.length === 32) return e;
        const r = Et.Buffer.alloc(32);
        return e.copy(r, 32 - e.length), r
    }
    toString() {
        return this.toBase58()
    }
    static async createWithSeed(e, r, n) {
        const i = Et.Buffer.concat([e.toBuffer(), Et.Buffer.from(r), n.toBuffer()]),
            s = Lv(new Uint8Array(i)).slice(2);
        return new bt(Et.Buffer.from(s, "hex"))
    }
    static createProgramAddressSync(e, r) {
        let n = Et.Buffer.alloc(0);
        e.forEach(function(o) {
            if (o.length > O5) throw new TypeError("Max seed length exceeded");
            n = Et.Buffer.concat([n, Bl(o)])
        }), n = Et.Buffer.concat([n, r.toBuffer(), Et.Buffer.from("ProgramDerivedAddress")]);
        let i = Lv(new Uint8Array(n)).slice(2),
            s = new l0(i, 16).toArray(void 0, 32);
        if (Fv(s)) throw new Error("Invalid seeds, address must fall off the curve");
        return new bt(s)
    }
    static async createProgramAddress(e, r) {
        return this.createProgramAddressSync(e, r)
    }
    static findProgramAddressSync(e, r) {
        let n = 255,
            i;
        for (; n != 0;) {
            try {
                const s = e.concat(Et.Buffer.from([n]));
                i = this.createProgramAddressSync(s, r)
            } catch (s) {
                if (s instanceof TypeError) throw s;
                n--;
                continue
            }
            return [i, n]
        }
        throw new Error("Unable to find a viable program address nonce")
    }
    static async findProgramAddress(e, r) {
        return this.findProgramAddressSync(e, r)
    }
    static isOnCurve(e) {
        const r = new bt(e);
        return Fv(r.toBytes()) == 1
    }
}
bt.default = new bt("11111111111111111111111111111111");
Of.set(bt, {
    kind: "struct",
    fields: [
        ["_bn", "u256"]
    ]
});
let Tt = Ud.lowlevel;

function Fv(t) {
    var e = [Tt.gf(), Tt.gf(), Tt.gf(), Tt.gf()],
        r = Tt.gf(),
        n = Tt.gf(),
        i = Tt.gf(),
        s = Tt.gf(),
        o = Tt.gf(),
        a = Tt.gf(),
        c = Tt.gf();
    return Tt.set25519(e[2], D5), Tt.unpack25519(e[1], t), Tt.S(i, e[1]), Tt.M(s, i, Tt.D), Tt.Z(i, i, e[2]), Tt.A(s, e[2], s), Tt.S(o, s), Tt.S(a, o), Tt.M(c, a, o), Tt.M(r, c, i), Tt.M(r, r, s), Tt.pow2523(r, r), Tt.M(r, r, i), Tt.M(r, r, s), Tt.M(r, r, s), Tt.M(e[0], r, s), Tt.S(n, e[0]), Tt.M(n, n, s), Uv(n, i) && Tt.M(e[0], e[0], P5), Tt.S(n, e[0]), Tt.M(n, n, s), Uv(n, i) ? 0 : 1
}
let D5 = Tt.gf([1]),
    P5 = Tt.gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

function Uv(t, e) {
    var r = new Uint8Array(32),
        n = new Uint8Array(32);
    return Tt.pack25519(r, t), Tt.pack25519(n, e), Tt.crypto_verify_32(r, 0, n, 0)
}
new bt("BPFLoader1111111111111111111111111111111111");
const Gd = 1280 - 40 - 8,
    Yd = 64,
    ir = t => Xn(32, t),
    Tu = t => {
        const e = pt([yt("length"), yt("lengthPadding"), Xn(Vu(yt(), -8), "chars")], t),
            r = e.decode.bind(e),
            n = e.encode.bind(e),
            i = e;
        return i.decode = (s, o) => r(s, o).chars.toString(), i.encode = (s, o, a) => {
            const c = {
                chars: Et.Buffer.from(s, "utf8")
            };
            return n(c, o, a)
        }, i.alloc = s => yt().span + yt().span + Et.Buffer.from(s, "utf8").length, i
    },
    L5 = (t = "authorized") => pt([ir("staker"), ir("withdrawer")], t),
    F5 = (t = "lockup") => pt([Pn("unixTimestamp"), Pn("epoch"), ir("custodian")], t),
    U5 = (t = "voteInit") => pt([ir("nodePubkey"), ir("authorizedVoter"), ir("authorizedWithdrawer"), Rr("commission")], t);

function Ou(t) {
    let e = 0,
        r = 0;
    for (;;) {
        let n = t.shift();
        if (e |= (n & 127) << r * 7, r += 1, (n & 128) === 0) break
    }
    return e
}

function Ru(t, e) {
    let r = e;
    for (;;) {
        let n = r & 127;
        if (r >>= 7, r == 0) {
            t.push(n);
            break
        } else n |= 128, t.push(n)
    }
}
const ff = 32;
class qs {
    constructor(e) {
        this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = e.header, this.accountKeys = e.accountKeys.map(r => new bt(r)), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach(r => this.indexToProgramIds.set(r.programIdIndex, this.accountKeys[r.programIdIndex]))
    }
    isAccountSigner(e) {
        return e < this.header.numRequiredSignatures
    }
    isAccountWritable(e) {
        return e < this.header.numRequiredSignatures - this.header.numReadonlySignedAccounts || e >= this.header.numRequiredSignatures && e < this.accountKeys.length - this.header.numReadonlyUnsignedAccounts
    }
    isProgramId(e) {
        return this.indexToProgramIds.has(e)
    }
    programIds() {
        return [...this.indexToProgramIds.values()]
    }
    nonProgramIds() {
        return this.accountKeys.filter((e, r) => !this.isProgramId(r))
    }
    serialize() {
        const e = this.accountKeys.length;
        let r = [];
        Ru(r, e);
        const n = this.instructions.map(I => {
            const {
                accounts: N,
                programIdIndex: E
            } = I, T = Array.from(Ln.decode(I.data));
            let j = [];
            Ru(j, N.length);
            let V = [];
            return Ru(V, T.length), {
                programIdIndex: E,
                keyIndicesCount: Et.Buffer.from(j),
                keyIndices: N,
                dataLength: Et.Buffer.from(V),
                data: T
            }
        });
        let i = [];
        Ru(i, n.length);
        let s = Et.Buffer.alloc(Gd);
        Et.Buffer.from(i).copy(s);
        let o = i.length;
        n.forEach(I => {
            o += pt([Rr("programIdIndex"), Xn(I.keyIndicesCount.length, "keyIndicesCount"), $s(Rr("keyIndex"), I.keyIndices.length, "keyIndices"), Xn(I.dataLength.length, "dataLength"), $s(Rr("userdatum"), I.data.length, "data")]).encode(I, s, o)
        }), s = s.slice(0, o);
        const a = pt([Xn(1, "numRequiredSignatures"), Xn(1, "numReadonlySignedAccounts"), Xn(1, "numReadonlyUnsignedAccounts"), Xn(r.length, "keyCount"), $s(ir("key"), e, "keys"), ir("recentBlockhash")]),
            c = {
                numRequiredSignatures: Et.Buffer.from([this.header.numRequiredSignatures]),
                numReadonlySignedAccounts: Et.Buffer.from([this.header.numReadonlySignedAccounts]),
                numReadonlyUnsignedAccounts: Et.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
                keyCount: Et.Buffer.from(r),
                keys: this.accountKeys.map(I => Bl(I.toBytes())),
                recentBlockhash: Ln.decode(this.recentBlockhash)
            };
        let d = Et.Buffer.alloc(2048);
        const y = a.encode(c, d);
        return s.copy(d, y), d.slice(0, y + s.length)
    }
    static from(e) {
        let r = [...e];
        const n = r.shift(),
            i = r.shift(),
            s = r.shift(),
            o = Ou(r);
        let a = [];
        for (let N = 0; N < o; N++) {
            const E = r.slice(0, ff);
            r = r.slice(ff), a.push(Ln.encode(Et.Buffer.from(E)))
        }
        const c = r.slice(0, ff);
        r = r.slice(ff);
        const d = Ou(r);
        let y = [];
        for (let N = 0; N < d; N++) {
            const E = r.shift(),
                T = Ou(r),
                j = r.slice(0, T);
            r = r.slice(T);
            const V = Ou(r),
                P = r.slice(0, V),
                O = Ln.encode(Et.Buffer.from(P));
            r = r.slice(V), y.push({
                programIdIndex: E,
                accounts: j,
                data: O
            })
        }
        const I = {
            header: {
                numRequiredSignatures: n,
                numReadonlySignedAccounts: i,
                numReadonlyUnsignedAccounts: s
            },
            recentBlockhash: Ln.encode(Et.Buffer.from(c)),
            accountKeys: a,
            instructions: y
        };
        return new qs(I)
    }
}

function Yn(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
let Ns;
(function(t) {
    t[t.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", t[t.PROCESSED = 1] = "PROCESSED", t[t.TIMED_OUT = 2] = "TIMED_OUT"
})(Ns || (Ns = {}));
const z5 = Et.Buffer.alloc(Yd).fill(0);
class zv {
    constructor(e) {
        this.keys = void 0, this.programId = void 0, this.data = Et.Buffer.alloc(0), this.programId = e.programId, this.keys = e.keys, e.data && (this.data = e.data)
    }
    toJSON() {
        return {
            keys: this.keys.map(({
                pubkey: e,
                isSigner: r,
                isWritable: n
            }) => ({
                pubkey: e.toJSON(),
                isSigner: r,
                isWritable: n
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
        }
    }
}
class Ls {
    get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null
    }
    constructor(e) {
        if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this._message = void 0, this._json = void 0, e)
            if (Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
                const r = e;
                Object.assign(this, r), this.recentBlockhash = r.blockhash, this.lastValidBlockHeight = r.lastValidBlockHeight
            } else {
                const r = e;
                Object.assign(this, r), this.recentBlockhash = r.recentBlockhash
            }
        else return
    }
    toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map(e => e.toJSON()),
            signers: this.signatures.map(({
                publicKey: e
            }) => e.toJSON())
        }
    }
    add(...e) {
        if (e.length === 0) throw new Error("No instructions");
        return e.forEach(r => {
            "instructions" in r ? this.instructions = this.instructions.concat(r.instructions) : "data" in r && "programId" in r && "keys" in r ? this.instructions.push(r) : this.instructions.push(new zv(r))
        }), this
    }
    compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
        const {
            nonceInfo: e
        } = this;
        e && this.instructions[0] != e.nonceInstruction && (this.recentBlockhash = e.nonce, this.instructions.unshift(e.nonceInstruction));
        const {
            recentBlockhash: r
        } = this;
        if (!r) throw new Error("Transaction recentBlockhash required");
        this.instructions.length < 1 && console.warn("No instructions provided");
        let n;
        if (this.feePayer) n = this.feePayer;
        else if (this.signatures.length > 0 && this.signatures[0].publicKey) n = this.signatures[0].publicKey;
        else throw new Error("Transaction fee payer required");
        for (let j = 0; j < this.instructions.length; j++)
            if (this.instructions[j].programId === void 0) throw new Error(`Transaction instruction index ${j} has undefined program id`);
        const i = [],
            s = [];
        this.instructions.forEach(j => {
            j.keys.forEach(P => {
                s.push(Ce({}, P))
            });
            const V = j.programId.toString();
            i.includes(V) || i.push(V)
        }), i.forEach(j => {
            s.push({
                pubkey: new bt(j),
                isSigner: !1,
                isWritable: !1
            })
        }), s.sort(function(j, V) {
            const P = j.pubkey.toBase58().localeCompare(V.pubkey.toBase58()),
                O = j.isSigner === V.isSigner ? 0 : j.isSigner ? -1 : 1,
                R = j.isWritable === V.isWritable ? P : j.isWritable ? -1 : 1;
            return O || R
        });
        const o = [];
        s.forEach(j => {
            const V = j.pubkey.toString(),
                P = o.findIndex(O => O.pubkey.toString() === V);
            P > -1 ? o[P].isWritable = o[P].isWritable || j.isWritable : o.push(j)
        });
        const a = o.findIndex(j => j.pubkey.equals(n));
        if (a > -1) {
            const [j] = o.splice(a, 1);
            j.isSigner = !0, j.isWritable = !0, o.unshift(j)
        } else o.unshift({
            pubkey: n,
            isSigner: !0,
            isWritable: !0
        });
        for (const j of this.signatures) {
            const V = o.findIndex(P => P.pubkey.equals(j.publicKey));
            if (V > -1) o[V].isSigner || (o[V].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
            else throw new Error(`unknown signer: ${j.publicKey.toString()}`)
        }
        let c = 0,
            d = 0,
            y = 0;
        const I = [],
            N = [];
        o.forEach(({
            pubkey: j,
            isSigner: V,
            isWritable: P
        }) => {
            V ? (I.push(j.toString()), c += 1, P || (d += 1)) : (N.push(j.toString()), P || (y += 1))
        });
        const E = I.concat(N),
            T = this.instructions.map(j => {
                const {
                    data: V,
                    programId: P
                } = j;
                return {
                    programIdIndex: E.indexOf(P.toString()),
                    accounts: j.keys.map(O => E.indexOf(O.pubkey.toString())),
                    data: Ln.encode(V)
                }
            });
        return T.forEach(j => {
            Yn(j.programIdIndex >= 0), j.accounts.forEach(V => Yn(V >= 0))
        }), new qs({
            header: {
                numRequiredSignatures: c,
                numReadonlySignedAccounts: d,
                numReadonlyUnsignedAccounts: y
            },
            accountKeys: E,
            recentBlockhash: r,
            instructions: T
        })
    }
    _compile() {
        const e = this.compileMessage(),
            r = e.accountKeys.slice(0, e.header.numRequiredSignatures);
        return this.signatures.length === r.length && this.signatures.every((i, s) => r[s].equals(i.publicKey)) || (this.signatures = r.map(n => ({
            signature: null,
            publicKey: n
        }))), e
    }
    serializeMessage() {
        return this._compile().serialize()
    }
    async getEstimatedFee(e) {
        return (await e.getFeeForMessage(this.compileMessage())).value
    }
    setSigners(...e) {
        if (e.length === 0) throw new Error("No signers");
        const r = new Set;
        this.signatures = e.filter(n => {
            const i = n.toString();
            return r.has(i) ? !1 : (r.add(i), !0)
        }).map(n => ({
            signature: null,
            publicKey: n
        }))
    }
    sign(...e) {
        if (e.length === 0) throw new Error("No signers");
        const r = new Set,
            n = [];
        for (const s of e) {
            const o = s.publicKey.toString();
            r.has(o) || (r.add(o), n.push(s))
        }
        this.signatures = n.map(s => ({
            signature: null,
            publicKey: s.publicKey
        }));
        const i = this._compile();
        this._partialSign(i, ...n)
    }
    partialSign(...e) {
        if (e.length === 0) throw new Error("No signers");
        const r = new Set,
            n = [];
        for (const s of e) {
            const o = s.publicKey.toString();
            r.has(o) || (r.add(o), n.push(s))
        }
        const i = this._compile();
        this._partialSign(i, ...n)
    }
    _partialSign(e, ...r) {
        const n = e.serialize();
        r.forEach(i => {
            const s = Ud.sign.detached(n, i.secretKey);
            this._addSignature(i.publicKey, Bl(s))
        })
    }
    addSignature(e, r) {
        this._compile(), this._addSignature(e, r)
    }
    _addSignature(e, r) {
        Yn(r.length === 64);
        const n = this.signatures.findIndex(i => e.equals(i.publicKey));
        if (n < 0) throw new Error(`unknown signer: ${e.toString()}`);
        this.signatures[n].signature = Et.Buffer.from(r)
    }
    verifySignatures() {
        return this._verifySignatures(this.serializeMessage(), !0)
    }
    _verifySignatures(e, r) {
        for (const {
                signature: n,
                publicKey: i
            } of this.signatures)
            if (n === null) {
                if (r) return !1
            } else if (!Ud.sign.detached.verify(e, n, i.toBuffer())) return !1;
        return !0
    }
    serialize(e) {
        const {
            requireAllSignatures: r,
            verifySignatures: n
        } = Object.assign({
            requireAllSignatures: !0,
            verifySignatures: !0
        }, e), i = this.serializeMessage();
        if (n && !this._verifySignatures(i, r)) throw new Error("Signature verification failed");
        return this._serialize(i)
    }
    _serialize(e) {
        const {
            signatures: r
        } = this, n = [];
        Ru(n, r.length);
        const i = n.length + r.length * 64 + e.length,
            s = Et.Buffer.alloc(i);
        return Yn(r.length < 256), Et.Buffer.from(n).copy(s, 0), r.forEach(({
            signature: o
        }, a) => {
            o !== null && (Yn(o.length === 64, "signature has invalid length"), Et.Buffer.from(o).copy(s, n.length + a * 64))
        }), e.copy(s, n.length + r.length * 64), Yn(s.length <= Gd, `Transaction too large: ${s.length} > ${Gd}`), s
    }
    get keys() {
        return Yn(this.instructions.length === 1), this.instructions[0].keys.map(e => e.pubkey)
    }
    get programId() {
        return Yn(this.instructions.length === 1), this.instructions[0].programId
    }
    get data() {
        return Yn(this.instructions.length === 1), this.instructions[0].data
    }
    static from(e) {
        let r = [...e];
        const n = Ou(r);
        let i = [];
        for (let s = 0; s < n; s++) {
            const o = r.slice(0, Yd);
            r = r.slice(Yd), i.push(Ln.encode(Et.Buffer.from(o)))
        }
        return Ls.populate(qs.from(r), i)
    }
    static populate(e, r = []) {
        const n = new Ls;
        return n.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures > 0 && (n.feePayer = e.accountKeys[0]), r.forEach((i, s) => {
            const o = {
                signature: i == Ln.encode(z5) ? null : Ln.decode(i),
                publicKey: e.accountKeys[s]
            };
            n.signatures.push(o)
        }), e.instructions.forEach(i => {
            const s = i.accounts.map(o => {
                const a = e.accountKeys[o];
                return {
                    pubkey: a,
                    isSigner: n.signatures.some(c => c.publicKey.toString() === a.toString()) || e.isAccountSigner(o),
                    isWritable: e.isAccountWritable(o)
                }
            });
            n.instructions.push(new zv({
                keys: s,
                programId: e.accountKeys[i.programIdIndex],
                data: Ln.decode(i.data)
            }))
        }), n._message = e, n._json = n.toJSON(), n
    }
}
new bt("SysvarC1ock11111111111111111111111111111111");
new bt("SysvarEpochSchedu1e111111111111111111111111");
new bt("Sysvar1nstructions1111111111111111111111111");
new bt("SysvarRecentB1ockHashes11111111111111111111");
new bt("SysvarRent111111111111111111111111111111111");
new bt("SysvarRewards111111111111111111111111111111");
new bt("SysvarS1otHashes111111111111111111111111111");
new bt("SysvarS1otHistory11111111111111111111111111");
new bt("SysvarStakeHistory1111111111111111111111111");

function Rf(t) {
    return new Promise(e => setTimeout(e, t))
}
const j5 = hn("lamportsPerSignature"),
    Rx = pt([yt("version"), yt("state"), ir("authorizedPubkey"), ir("nonce"), pt([j5], "feeCalculator")]);
Rx.span;
class C1 {
    constructor(e) {
        this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = e.authorizedPubkey, this.nonce = e.nonce, this.feeCalculator = e.feeCalculator
    }
    static fromAccountData(e) {
        const r = Rx.decode(Bl(e), 0);
        return new C1({
            authorizedPubkey: new bt(r.authorizedPubkey),
            nonce: new bt(r.nonce).toString(),
            feeCalculator: r.feeCalculator
        })
    }
}
const $5 = t => {
        const e = t.decode.bind(t),
            r = t.encode.bind(t);
        return {
            decode: e,
            encode: r
        }
    },
    H5 = t => e => {
        const r = Xn(t, e),
            {
                encode: n,
                decode: i
            } = $5(r),
            s = r;
        return s.decode = (o, a) => {
            const c = i(o, a);
            return RA(Et.Buffer.from(c))
        }, s.encode = (o, a, c) => {
            const d = LA(o, t);
            return n(d, a, c)
        }, s
    },
    Kd = H5(8);
Object.freeze({
    Create: {
        index: 0,
        layout: pt([yt("instruction"), Pn("lamports"), Pn("space"), ir("programId")])
    },
    Assign: {
        index: 1,
        layout: pt([yt("instruction"), ir("programId")])
    },
    Transfer: {
        index: 2,
        layout: pt([yt("instruction"), Kd("lamports")])
    },
    CreateWithSeed: {
        index: 3,
        layout: pt([yt("instruction"), ir("base"), Tu("seed"), Pn("lamports"), Pn("space"), ir("programId")])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: pt([yt("instruction")])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: pt([yt("instruction"), Pn("lamports")])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: pt([yt("instruction"), ir("authorized")])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: pt([yt("instruction"), ir("authorized")])
    },
    Allocate: {
        index: 8,
        layout: pt([yt("instruction"), Pn("space")])
    },
    AllocateWithSeed: {
        index: 9,
        layout: pt([yt("instruction"), ir("base"), Tu("seed"), Pn("space"), ir("programId")])
    },
    AssignWithSeed: {
        index: 10,
        layout: pt([yt("instruction"), ir("base"), Tu("seed"), ir("programId")])
    },
    TransferWithSeed: {
        index: 11,
        layout: pt([yt("instruction"), Kd("lamports"), Tu("seed"), ir("programId")])
    }
});
new bt("11111111111111111111111111111111");
new bt("BPFLoader2111111111111111111111111111111111");
Object.freeze({
    RequestUnits: {
        index: 0,
        layout: pt([Rr("instruction"), yt("units"), yt("additionalFee")])
    },
    RequestHeapFrame: {
        index: 1,
        layout: pt([Rr("instruction"), yt("bytes")])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: pt([Rr("instruction"), yt("units")])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: pt([Rr("instruction"), Kd("microLamports")])
    }
});
new bt("ComputeBudget111111111111111111111111111111");
var Q5 = Object.prototype.toString,
    q5 = Object.keys || function(t) {
        var e = [];
        for (var r in t) e.push(r);
        return e
    };

function Du(t, e) {
    var r, n, i, s, o, a, c;
    if (t === !0) return "true";
    if (t === !1) return "false";
    switch (typeof t) {
        case "object":
            if (t === null) return null;
            if (t.toJSON && typeof t.toJSON == "function") return Du(t.toJSON(), e);
            if (c = Q5.call(t), c === "[object Array]") {
                for (i = "[", n = t.length - 1, r = 0; r < n; r++) i += Du(t[r], !0) + ",";
                return n > -1 && (i += Du(t[r], !0)), i + "]"
            } else if (c === "[object Object]") {
                for (s = q5(t).sort(), n = s.length, i = "", r = 0; r < n;) o = s[r], a = Du(t[o], !1), a !== void 0 && (i && (i += ","), i += JSON.stringify(o) + ":" + a), r++;
                return "{" + i + "}"
            } else return JSON.stringify(t);
        case "function":
        case "undefined":
            return e ? null : void 0;
        case "string":
            return JSON.stringify(t);
        default:
            return isFinite(t) ? t : null
    }
}
var W5 = function(t) {
        var e = Du(t, !1);
        if (e !== void 0) return "" + e
    },
    V5 = W5;
const bu = 32;

function B0(t) {
    let e = 0;
    for (; t > 1;) t /= 2, e++;
    return e
}

function G5(t) {
    return t === 0 ? 1 : (t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, t |= t >> 32, t + 1)
}
class Y5 {
    constructor(e, r, n, i, s) {
        this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = e, this.leaderScheduleSlotOffset = r, this.warmup = n, this.firstNormalEpoch = i, this.firstNormalSlot = s
    }
    getEpoch(e) {
        return this.getEpochAndSlotIndex(e)[0]
    }
    getEpochAndSlotIndex(e) {
        if (e < this.firstNormalSlot) {
            const r = B0(G5(e + bu + 1)) - B0(bu) - 1,
                n = this.getSlotsInEpoch(r),
                i = e - (n - bu);
            return [r, i]
        } else {
            const r = e - this.firstNormalSlot,
                n = Math.floor(r / this.slotsPerEpoch),
                i = this.firstNormalEpoch + n,
                s = r % this.slotsPerEpoch;
            return [i, s]
        }
    }
    getFirstSlotInEpoch(e) {
        return e <= this.firstNormalEpoch ? (Math.pow(2, e) - 1) * bu : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
    }
    getLastSlotInEpoch(e) {
        return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1
    }
    getSlotsInEpoch(e) {
        return e < this.firstNormalEpoch ? Math.pow(2, e + B0(bu)) : this.slotsPerEpoch
    }
}
class jv extends Error {
    constructor(e, r) {
        super(e), this.logs = void 0, this.logs = r
    }
}
var K5 = globalThis.fetch;
const Z5 = 160,
    J5 = 64,
    X5 = Z5 / J5,
    e_ = 1e3 / X5;
class Dx extends Error {
    constructor(e) {
        super(`Signature ${e} has expired: block height exceeded.`), this.signature = void 0, this.signature = e
    }
}
Object.defineProperty(Dx.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
});
class Px extends Error {
    constructor(e, r) {
        super(`Transaction was not confirmed in ${r.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = e
    }
}
Object.defineProperty(Px.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
});

function t_(t) {
    let e = new URL(t);
    const r = e.protocol === "https:";
    return e.protocol = r ? "wss:" : "ws:", e.host = "", e.port !== "" && (e.port = String(Number(e.port) + 1)), e.toString()
}
const Xr = _l(b1(bt), Fe(), t => new bt(t)),
    Lx = B2([Fe(), jr("base64")]),
    B1 = _l(b1(Et.Buffer), Lx, t => Et.Buffer.from(t[0], "base64")),
    r_ = 30 * 1e3;

function Fx(t) {
    return ui([Ee({
        jsonrpc: jr("2.0"),
        id: Fe(),
        result: t
    }), Ee({
        jsonrpc: jr("2.0"),
        id: Fe(),
        error: Ee({
            code: El(),
            message: Fe(),
            data: ar(qA())
        })
    })])
}
const n_ = Fx(El());

function Wt(t) {
    return _l(Fx(t), n_, e => "error" in e ? e : xt(Ce({}, e), {
        result: je(e.result, t)
    }))
}

function $r(t) {
    return Wt(Ee({
        context: Ee({
            slot: ue()
        }),
        value: t
    }))
}

function bh(t) {
    return Ee({
        context: Ee({
            slot: ue()
        }),
        value: t
    })
}
const i_ = Ee({
        foundation: ue(),
        foundationTerm: ue(),
        initial: ue(),
        taper: ue(),
        terminal: ue()
    }),
    s_ = Wt(nt(lt(Ee({
        epoch: ue(),
        effectiveSlot: ue(),
        amount: ue(),
        postBalance: ue()
    })))),
    o_ = Ee({
        epoch: ue(),
        slotIndex: ue(),
        slotsInEpoch: ue(),
        absoluteSlot: ue(),
        blockHeight: ar(ue()),
        transactionCount: ar(ue())
    }),
    a_ = Ee({
        slotsPerEpoch: ue(),
        leaderScheduleSlotOffset: ue(),
        warmup: gs(),
        firstNormalEpoch: ue(),
        firstNormalSlot: ue()
    }),
    u_ = C2(Fe(), nt(ue())),
    jo = lt(ui([Ee({}), Fe()])),
    l_ = Ee({
        err: jo
    }),
    f_ = jr("receivedSignature"),
    c_ = Ee({
        "solana-core": Fe(),
        "feature-set": ar(ue())
    }),
    h_ = $r(Ee({
        err: lt(ui([Ee({}), Fe()])),
        logs: lt(nt(Fe())),
        accounts: ar(lt(nt(lt(Ee({
            executable: gs(),
            owner: Fe(),
            lamports: ue(),
            data: nt(Fe()),
            rentEpoch: ar(ue())
        }))))),
        unitsConsumed: ar(ue())
    })),
    d_ = $r(Ee({
        byIdentity: C2(Fe(), nt(ue())),
        range: Ee({
            firstSlot: ue(),
            lastSlot: ue()
        })
    }));

function p_(t, e, r, n, i, s) {
    const o = n || K5;
    let a;
    return i && (a = async (d, y) => {
        const I = await new Promise((N, E) => {
            try {
                i(d, y, (T, j) => N([T, j]))
            } catch (T) {
                E(T)
            }
        });
        return await o(...I)
    }), new kS(async (d, y) => {
        const N = {
            method: "POST",
            body: d,
            agent: void 0,
            headers: Object.assign({
                "Content-Type": "application/json"
            }, r || {})
        };
        try {
            let E = 5,
                T, j = 500;
            for (; a ? T = await a(t, N) : T = await o(t, N), !(T.status !== 429 || s === !0 || (E -= 1, E === 0));) console.log(`Server responded with ${T.status} ${T.statusText}.  Retrying after ${j}ms delay...`), await Rf(j), j *= 2;
            const V = await T.text();
            T.ok ? y(null, V) : y(new Error(`${T.status} ${T.statusText}: ${V}`))
        } catch (E) {
            E instanceof Error && y(E)
        } finally {}
    }, {})
}

function m_(t) {
    return (e, r) => new Promise((n, i) => {
        t.request(e, r, (s, o) => {
            if (s) {
                i(s);
                return
            }
            n(o)
        })
    })
}

function v_(t) {
    return e => new Promise((r, n) => {
        e.length === 0 && r([]);
        const i = e.map(s => t.request(s.methodName, s.args));
        t.request(i, (s, o) => {
            if (s) {
                n(s);
                return
            }
            r(o)
        })
    })
}
const g_ = Wt(i_),
    y_ = Wt(o_),
    w_ = Wt(a_),
    x_ = Wt(u_),
    b_ = Wt(ue()),
    A_ = $r(Ee({
        total: ue(),
        circulating: ue(),
        nonCirculating: ue(),
        nonCirculatingAccounts: nt(Xr)
    })),
    Zd = Ee({
        amount: Fe(),
        uiAmount: lt(ue()),
        decimals: ue(),
        uiAmountString: ar(Fe())
    }),
    S_ = $r(nt(Ee({
        address: Xr,
        amount: Fe(),
        uiAmount: lt(ue()),
        decimals: ue(),
        uiAmountString: ar(Fe())
    }))),
    M_ = $r(nt(Ee({
        pubkey: Xr,
        account: Ee({
            executable: gs(),
            owner: Xr,
            lamports: ue(),
            data: B1,
            rentEpoch: ue()
        })
    }))),
    Jd = Ee({
        program: Fe(),
        parsed: El(),
        space: ue()
    }),
    E_ = $r(nt(Ee({
        pubkey: Xr,
        account: Ee({
            executable: gs(),
            owner: Xr,
            lamports: ue(),
            data: Jd,
            rentEpoch: ue()
        })
    }))),
    __ = $r(nt(Ee({
        lamports: ue(),
        address: Xr
    }))),
    vl = Ee({
        executable: gs(),
        owner: Xr,
        lamports: ue(),
        data: B1,
        rentEpoch: ue()
    }),
    I_ = Ee({
        pubkey: Xr,
        account: vl
    }),
    C_ = _l(ui([b1(Et.Buffer), Jd]), ui([Lx, Jd]), t => Array.isArray(t) ? je(t, B1) : t),
    Ux = Ee({
        executable: gs(),
        owner: Xr,
        lamports: ue(),
        data: C_,
        rentEpoch: ue()
    }),
    B_ = Ee({
        pubkey: Xr,
        account: Ux
    }),
    k_ = Ee({
        state: ui([jr("active"), jr("inactive"), jr("activating"), jr("deactivating")]),
        active: ue(),
        inactive: ue()
    }),
    N_ = Wt(nt(Ee({
        signature: Fe(),
        slot: ue(),
        err: jo,
        memo: lt(Fe()),
        blockTime: ar(lt(ue()))
    }))),
    T_ = Wt(nt(Ee({
        signature: Fe(),
        slot: ue(),
        err: jo,
        memo: lt(Fe()),
        blockTime: ar(lt(ue()))
    }))),
    O_ = Ee({
        subscription: ue(),
        result: bh(vl)
    }),
    R_ = Ee({
        pubkey: Xr,
        account: vl
    }),
    D_ = Ee({
        subscription: ue(),
        result: bh(R_)
    }),
    P_ = Ee({
        parent: ue(),
        slot: ue(),
        root: ue()
    }),
    L_ = Ee({
        subscription: ue(),
        result: P_
    }),
    F_ = ui([Ee({
        type: ui([jr("firstShredReceived"), jr("completed"), jr("optimisticConfirmation"), jr("root")]),
        slot: ue(),
        timestamp: ue()
    }), Ee({
        type: jr("createdBank"),
        parent: ue(),
        slot: ue(),
        timestamp: ue()
    }), Ee({
        type: jr("frozen"),
        slot: ue(),
        timestamp: ue(),
        stats: Ee({
            numTransactionEntries: ue(),
            numSuccessfulTransactions: ue(),
            numFailedTransactions: ue(),
            maxTransactionsPerEntry: ue()
        })
    }), Ee({
        type: jr("dead"),
        slot: ue(),
        timestamp: ue(),
        err: Fe()
    })]),
    U_ = Ee({
        subscription: ue(),
        result: F_
    }),
    z_ = Ee({
        subscription: ue(),
        result: bh(ui([l_, f_]))
    }),
    j_ = Ee({
        subscription: ue(),
        result: ue()
    }),
    $_ = Ee({
        pubkey: Fe(),
        gossip: lt(Fe()),
        tpu: lt(Fe()),
        rpc: lt(Fe()),
        version: lt(Fe())
    }),
    $v = Ee({
        votePubkey: Fe(),
        nodePubkey: Fe(),
        activatedStake: ue(),
        epochVoteAccount: gs(),
        epochCredits: nt(B2([ue(), ue(), ue()])),
        commission: ue(),
        lastVote: ue(),
        rootSlot: lt(ue())
    }),
    H_ = Wt(Ee({
        current: nt($v),
        delinquent: nt($v)
    })),
    Q_ = ui([jr("processed"), jr("confirmed"), jr("finalized")]),
    q_ = Ee({
        slot: ue(),
        confirmations: lt(ue()),
        err: jo,
        confirmationStatus: ar(Q_)
    }),
    W_ = $r(nt(lt(q_))),
    V_ = Wt(ue()),
    k1 = Ee({
        signatures: nt(Fe()),
        message: Ee({
            accountKeys: nt(Fe()),
            header: Ee({
                numRequiredSignatures: ue(),
                numReadonlySignedAccounts: ue(),
                numReadonlyUnsignedAccounts: ue()
            }),
            instructions: nt(Ee({
                accounts: nt(ue()),
                data: Fe(),
                programIdIndex: ue()
            })),
            recentBlockhash: Fe()
        })
    }),
    zx = Ee({
        parsed: El(),
        program: Fe(),
        programId: Xr
    }),
    jx = Ee({
        accounts: nt(Xr),
        data: Fe(),
        programId: Xr
    }),
    G_ = ui([jx, zx]),
    Y_ = ui([Ee({
        parsed: El(),
        program: Fe(),
        programId: Fe()
    }), Ee({
        accounts: nt(Fe()),
        data: Fe(),
        programId: Fe()
    })]),
    $x = _l(G_, Y_, t => "accounts" in t ? je(t, jx) : je(t, zx)),
    K_ = Ee({
        signatures: nt(Fe()),
        message: Ee({
            accountKeys: nt(Ee({
                pubkey: Xr,
                signer: gs(),
                writable: gs()
            })),
            instructions: nt($x),
            recentBlockhash: Fe()
        })
    }),
    bc = Ee({
        accountIndex: ue(),
        mint: Fe(),
        owner: ar(Fe()),
        uiTokenAmount: Zd
    }),
    N1 = Ee({
        err: jo,
        fee: ue(),
        innerInstructions: ar(lt(nt(Ee({
            index: ue(),
            instructions: nt(Ee({
                accounts: nt(ue()),
                data: Fe(),
                programIdIndex: ue()
            }))
        })))),
        preBalances: nt(ue()),
        postBalances: nt(ue()),
        logMessages: ar(lt(nt(Fe()))),
        preTokenBalances: ar(lt(nt(bc))),
        postTokenBalances: ar(lt(nt(bc)))
    }),
    Z_ = Ee({
        err: jo,
        fee: ue(),
        innerInstructions: ar(lt(nt(Ee({
            index: ue(),
            instructions: nt($x)
        })))),
        preBalances: nt(ue()),
        postBalances: nt(ue()),
        logMessages: ar(lt(nt(Fe()))),
        preTokenBalances: ar(lt(nt(bc))),
        postTokenBalances: ar(lt(nt(bc)))
    }),
    J_ = Wt(lt(Ee({
        blockhash: Fe(),
        previousBlockhash: Fe(),
        parentSlot: ue(),
        transactions: nt(Ee({
            transaction: k1,
            meta: lt(N1)
        })),
        rewards: ar(nt(Ee({
            pubkey: Fe(),
            lamports: ue(),
            postBalance: lt(ue()),
            rewardType: lt(Fe())
        }))),
        blockTime: lt(ue()),
        blockHeight: lt(ue())
    }))),
    X_ = Wt(lt(Ee({
        blockhash: Fe(),
        previousBlockhash: Fe(),
        parentSlot: ue(),
        transactions: nt(Ee({
            transaction: k1,
            meta: lt(N1)
        })),
        rewards: ar(nt(Ee({
            pubkey: Fe(),
            lamports: ue(),
            postBalance: lt(ue()),
            rewardType: lt(Fe())
        }))),
        blockTime: lt(ue())
    }))),
    Hv = Wt(lt(Ee({
        blockhash: Fe(),
        previousBlockhash: Fe(),
        parentSlot: ue(),
        signatures: nt(Fe()),
        blockTime: lt(ue())
    }))),
    k0 = Wt(lt(Ee({
        slot: ue(),
        meta: N1,
        blockTime: ar(lt(ue())),
        transaction: k1
    }))),
    cf = Wt(lt(Ee({
        slot: ue(),
        transaction: K_,
        meta: lt(Z_),
        blockTime: ar(lt(ue()))
    }))),
    eI = $r(Ee({
        blockhash: Fe(),
        feeCalculator: Ee({
            lamportsPerSignature: ue()
        })
    })),
    tI = $r(Ee({
        blockhash: Fe(),
        lastValidBlockHeight: ue()
    })),
    rI = Ee({
        slot: ue(),
        numTransactions: ue(),
        numSlots: ue(),
        samplePeriodSecs: ue()
    }),
    nI = Wt(nt(rI)),
    iI = $r(lt(Ee({
        feeCalculator: Ee({
            lamportsPerSignature: ue()
        })
    }))),
    sI = Wt(Fe()),
    oI = Wt(Fe()),
    aI = Ee({
        err: jo,
        logs: nt(Fe()),
        signature: Fe()
    }),
    uI = Ee({
        result: bh(aI),
        subscription: ue()
    });
class lI {
    constructor(e, r) {
        this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
        }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = new Set;
        let n = new URL(e);
        const i = n.protocol === "https:";
        let s, o, a, c, d;
        r && typeof r == "string" ? this._commitment = r : r && (this._commitment = r.commitment, this._confirmTransactionInitialTimeout = r.confirmTransactionInitialTimeout, s = r.wsEndpoint, o = r.httpHeaders, a = r.fetch, c = r.fetchMiddleware, d = r.disableRetryOnRateLimit), this._rpcEndpoint = e, this._rpcWsEndpoint = s || t_(e), this._rpcClient = p_(n.toString(), i, o, a, c, d), this._rpcRequest = m_(this._rpcClient), this._rpcBatchRequest = v_(this._rpcClient), this._rpcWebSocket = new P2(this._rpcWsEndpoint, {
            autoconnect: !1,
            max_reconnects: 1 / 0
        }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
    }
    get commitment() {
        return this._commitment
    }
    get rpcEndpoint() {
        return this._rpcEndpoint
    }
    async getBalanceAndContext(e, r) {
        const n = this._buildArgs([e.toBase58()], r),
            i = await this._rpcRequest("getBalance", n),
            s = je(i, $r(ue()));
        if ("error" in s) throw new Error("failed to get balance for " + e.toBase58() + ": " + s.error.message);
        return s.result
    }
    async getBalance(e, r) {
        return await this.getBalanceAndContext(e, r).then(n => n.value).catch(n => {
            throw new Error("failed to get balance of account " + e.toBase58() + ": " + n)
        })
    }
    async getBlockTime(e) {
        const r = await this._rpcRequest("getBlockTime", [e]),
            n = je(r, Wt(lt(ue())));
        if ("error" in n) throw new Error("failed to get block time for slot " + e + ": " + n.error.message);
        return n.result
    }
    async getMinimumLedgerSlot() {
        const e = await this._rpcRequest("minimumLedgerSlot", []),
            r = je(e, Wt(ue()));
        if ("error" in r) throw new Error("failed to get minimum ledger slot: " + r.error.message);
        return r.result
    }
    async getFirstAvailableBlock() {
        const e = await this._rpcRequest("getFirstAvailableBlock", []),
            r = je(e, b_);
        if ("error" in r) throw new Error("failed to get first available block: " + r.error.message);
        return r.result
    }
    async getSupply(e) {
        let r = {};
        typeof e == "string" ? r = {
            commitment: e
        } : e ? r = xt(Ce({}, e), {
            commitment: e && e.commitment || this.commitment
        }) : r = {
            commitment: this.commitment
        };
        const n = await this._rpcRequest("getSupply", [r]),
            i = je(n, A_);
        if ("error" in i) throw new Error("failed to get supply: " + i.error.message);
        return i.result
    }
    async getTokenSupply(e, r) {
        const n = this._buildArgs([e.toBase58()], r),
            i = await this._rpcRequest("getTokenSupply", n),
            s = je(i, $r(Zd));
        if ("error" in s) throw new Error("failed to get token supply: " + s.error.message);
        return s.result
    }
    async getTokenAccountBalance(e, r) {
        const n = this._buildArgs([e.toBase58()], r),
            i = await this._rpcRequest("getTokenAccountBalance", n),
            s = je(i, $r(Zd));
        if ("error" in s) throw new Error("failed to get token account balance: " + s.error.message);
        return s.result
    }
    async getTokenAccountsByOwner(e, r, n) {
        let i = [e.toBase58()];
        "mint" in r ? i.push({
            mint: r.mint.toBase58()
        }) : i.push({
            programId: r.programId.toBase58()
        });
        const s = this._buildArgs(i, n, "base64"),
            o = await this._rpcRequest("getTokenAccountsByOwner", s),
            a = je(o, M_);
        if ("error" in a) throw new Error("failed to get token accounts owned by account " + e.toBase58() + ": " + a.error.message);
        return a.result
    }
    async getParsedTokenAccountsByOwner(e, r, n) {
        let i = [e.toBase58()];
        "mint" in r ? i.push({
            mint: r.mint.toBase58()
        }) : i.push({
            programId: r.programId.toBase58()
        });
        const s = this._buildArgs(i, n, "jsonParsed"),
            o = await this._rpcRequest("getTokenAccountsByOwner", s),
            a = je(o, E_);
        if ("error" in a) throw new Error("failed to get token accounts owned by account " + e.toBase58() + ": " + a.error.message);
        return a.result
    }
    async getLargestAccounts(e) {
        const r = xt(Ce({}, e), {
                commitment: e && e.commitment || this.commitment
            }),
            n = r.filter || r.commitment ? [r] : [],
            i = await this._rpcRequest("getLargestAccounts", n),
            s = je(i, __);
        if ("error" in s) throw new Error("failed to get largest accounts: " + s.error.message);
        return s.result
    }
    async getTokenLargestAccounts(e, r) {
        const n = this._buildArgs([e.toBase58()], r),
            i = await this._rpcRequest("getTokenLargestAccounts", n),
            s = je(i, S_);
        if ("error" in s) throw new Error("failed to get token largest accounts: " + s.error.message);
        return s.result
    }
    async getAccountInfoAndContext(e, r) {
        const n = this._buildArgs([e.toBase58()], r, "base64"),
            i = await this._rpcRequest("getAccountInfo", n),
            s = je(i, $r(lt(vl)));
        if ("error" in s) throw new Error("failed to get info about account " + e.toBase58() + ": " + s.error.message);
        return s.result
    }
    async getParsedAccountInfo(e, r) {
        const n = this._buildArgs([e.toBase58()], r, "jsonParsed"),
            i = await this._rpcRequest("getAccountInfo", n),
            s = je(i, $r(lt(Ux)));
        if ("error" in s) throw new Error("failed to get info about account " + e.toBase58() + ": " + s.error.message);
        return s.result
    }
    async getAccountInfo(e, r) {
        try {
            return (await this.getAccountInfoAndContext(e, r)).value
        } catch (n) {
            throw new Error("failed to get info about account " + e.toBase58() + ": " + n)
        }
    }
    async getMultipleAccountsInfoAndContext(e, r) {
        const n = e.map(a => a.toBase58()),
            i = this._buildArgs([n], r, "base64"),
            s = await this._rpcRequest("getMultipleAccounts", i),
            o = je(s, $r(nt(lt(vl))));
        if ("error" in o) throw new Error("failed to get info for accounts " + n + ": " + o.error.message);
        return o.result
    }
    async getMultipleAccountsInfo(e, r) {
        return (await this.getMultipleAccountsInfoAndContext(e, r)).value
    }
    async getStakeActivation(e, r, n) {
        const i = this._buildArgs([e.toBase58()], r, void 0, n !== void 0 ? {
                epoch: n
            } : void 0),
            s = await this._rpcRequest("getStakeActivation", i),
            o = je(s, Wt(k_));
        if ("error" in o) throw new Error(`failed to get Stake Activation ${e.toBase58()}: ${o.error.message}`);
        return o.result
    }
    async getProgramAccounts(e, r) {
        const n = {};
        let i, s;
        r && (typeof r == "string" ? i = r : (i = r.commitment, s = r.encoding, r.dataSlice && (n.dataSlice = r.dataSlice), r.filters && (n.filters = r.filters)));
        const o = this._buildArgs([e.toBase58()], i, s || "base64", n),
            a = await this._rpcRequest("getProgramAccounts", o),
            c = je(a, Wt(nt(I_)));
        if ("error" in c) throw new Error("failed to get accounts owned by program " + e.toBase58() + ": " + c.error.message);
        return c.result
    }
    async getParsedProgramAccounts(e, r) {
        const n = {};
        let i;
        r && (typeof r == "string" ? i = r : (i = r.commitment, r.filters && (n.filters = r.filters)));
        const s = this._buildArgs([e.toBase58()], i, "jsonParsed", n),
            o = await this._rpcRequest("getProgramAccounts", s),
            a = je(o, Wt(nt(B_)));
        if ("error" in a) throw new Error("failed to get accounts owned by program " + e.toBase58() + ": " + a.error.message);
        return a.result
    }
    async confirmTransaction(e, r) {
        let n;
        typeof e == "string" ? n = e : n = e.signature;
        let i;
        try {
            i = Ln.decode(n)
        } catch {
            throw new Error("signature must be base58 encoded: " + n)
        }
        Yn(i.length === 64, "signature has invalid length");
        const s = r || this.commitment;
        let o, a, c = !1;
        const d = new Promise((E, T) => {
                try {
                    a = this.onSignature(n, (j, V) => {
                        a = void 0;
                        const P = {
                            context: V,
                            value: j
                        };
                        c = !0, E({
                            __type: Ns.PROCESSED,
                            response: P
                        })
                    }, s)
                } catch (j) {
                    T(j)
                }
            }),
            y = async () => {
                try {
                    return await this.getBlockHeight(r)
                } catch {
                    return -1
                }
            },
            I = new Promise(E => {
                if (typeof e == "string") {
                    let T = this._confirmTransactionInitialTimeout || 6e4;
                    switch (s) {
                        case "processed":
                        case "recent":
                        case "single":
                        case "confirmed":
                        case "singleGossip":
                            {
                                T = this._confirmTransactionInitialTimeout || 30 * 1e3;
                                break
                            }
                    }
                    o = setTimeout(() => E({
                        __type: Ns.TIMED_OUT,
                        timeoutMs: T
                    }), T)
                } else {
                    let T = e;
                    (async () => {
                        let j = await y();
                        if (!c) {
                            for (; j <= T.lastValidBlockHeight;)
                                if (await Rf(1e3), c || (j = await y(), c)) return;
                            E({
                                __type: Ns.BLOCKHEIGHT_EXCEEDED
                            })
                        }
                    })()
                }
            });
        let N;
        try {
            const E = await Promise.race([d, I]);
            switch (E.__type) {
                case Ns.BLOCKHEIGHT_EXCEEDED:
                    throw new Dx(n);
                case Ns.PROCESSED:
                    N = E.response;
                    break;
                case Ns.TIMED_OUT:
                    throw new Px(n, E.timeoutMs / 1e3)
            }
        } finally {
            clearTimeout(o), a && this.removeSignatureListener(a)
        }
        return N
    }
    async getClusterNodes() {
        const e = await this._rpcRequest("getClusterNodes", []),
            r = je(e, Wt(nt($_)));
        if ("error" in r) throw new Error("failed to get cluster nodes: " + r.error.message);
        return r.result
    }
    async getVoteAccounts(e) {
        const r = this._buildArgs([], e),
            n = await this._rpcRequest("getVoteAccounts", r),
            i = je(n, H_);
        if ("error" in i) throw new Error("failed to get vote accounts: " + i.error.message);
        return i.result
    }
    async getSlot(e) {
        const r = this._buildArgs([], e),
            n = await this._rpcRequest("getSlot", r),
            i = je(n, Wt(ue()));
        if ("error" in i) throw new Error("failed to get slot: " + i.error.message);
        return i.result
    }
    async getSlotLeader(e) {
        const r = this._buildArgs([], e),
            n = await this._rpcRequest("getSlotLeader", r),
            i = je(n, Wt(Fe()));
        if ("error" in i) throw new Error("failed to get slot leader: " + i.error.message);
        return i.result
    }
    async getSlotLeaders(e, r) {
        const n = [e, r],
            i = await this._rpcRequest("getSlotLeaders", n),
            s = je(i, Wt(nt(Xr)));
        if ("error" in s) throw new Error("failed to get slot leaders: " + s.error.message);
        return s.result
    }
    async getSignatureStatus(e, r) {
        const {
            context: n,
            value: i
        } = await this.getSignatureStatuses([e], r);
        Yn(i.length === 1);
        const s = i[0];
        return {
            context: n,
            value: s
        }
    }
    async getSignatureStatuses(e, r) {
        const n = [e];
        r && n.push(r);
        const i = await this._rpcRequest("getSignatureStatuses", n),
            s = je(i, W_);
        if ("error" in s) throw new Error("failed to get signature status: " + s.error.message);
        return s.result
    }
    async getTransactionCount(e) {
        const r = this._buildArgs([], e),
            n = await this._rpcRequest("getTransactionCount", r),
            i = je(n, Wt(ue()));
        if ("error" in i) throw new Error("failed to get transaction count: " + i.error.message);
        return i.result
    }
    async getTotalSupply(e) {
        return (await this.getSupply({
            commitment: e,
            excludeNonCirculatingAccountsList: !0
        })).value.total
    }
    async getInflationGovernor(e) {
        const r = this._buildArgs([], e),
            n = await this._rpcRequest("getInflationGovernor", r),
            i = je(n, g_);
        if ("error" in i) throw new Error("failed to get inflation: " + i.error.message);
        return i.result
    }
    async getInflationReward(e, r, n) {
        const i = this._buildArgs([e.map(a => a.toBase58())], n, void 0, {
                epoch: r
            }),
            s = await this._rpcRequest("getInflationReward", i),
            o = je(s, s_);
        if ("error" in o) throw new Error("failed to get inflation reward: " + o.error.message);
        return o.result
    }
    async getEpochInfo(e) {
        const r = this._buildArgs([], e),
            n = await this._rpcRequest("getEpochInfo", r),
            i = je(n, y_);
        if ("error" in i) throw new Error("failed to get epoch info: " + i.error.message);
        return i.result
    }
    async getEpochSchedule() {
        const e = await this._rpcRequest("getEpochSchedule", []),
            r = je(e, w_);
        if ("error" in r) throw new Error("failed to get epoch schedule: " + r.error.message);
        const n = r.result;
        return new Y5(n.slotsPerEpoch, n.leaderScheduleSlotOffset, n.warmup, n.firstNormalEpoch, n.firstNormalSlot)
    }
    async getLeaderSchedule() {
        const e = await this._rpcRequest("getLeaderSchedule", []),
            r = je(e, x_);
        if ("error" in r) throw new Error("failed to get leader schedule: " + r.error.message);
        return r.result
    }
    async getMinimumBalanceForRentExemption(e, r) {
        const n = this._buildArgs([e], r),
            i = await this._rpcRequest("getMinimumBalanceForRentExemption", n),
            s = je(i, V_);
        return "error" in s ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : s.result
    }
    async getRecentBlockhashAndContext(e) {
        const r = this._buildArgs([], e),
            n = await this._rpcRequest("getRecentBlockhash", r),
            i = je(n, eI);
        if ("error" in i) throw new Error("failed to get recent blockhash: " + i.error.message);
        return i.result
    }
    async getRecentPerformanceSamples(e) {
        const r = this._buildArgs(e ? [e] : []),
            n = await this._rpcRequest("getRecentPerformanceSamples", r),
            i = je(n, nI);
        if ("error" in i) throw new Error("failed to get recent performance samples: " + i.error.message);
        return i.result
    }
    async getFeeCalculatorForBlockhash(e, r) {
        const n = this._buildArgs([e], r),
            i = await this._rpcRequest("getFeeCalculatorForBlockhash", n),
            s = je(i, iI);
        if ("error" in s) throw new Error("failed to get fee calculator: " + s.error.message);
        const {
            context: o,
            value: a
        } = s.result;
        return {
            context: o,
            value: a !== null ? a.feeCalculator : null
        }
    }
    async getFeeForMessage(e, r) {
        const n = e.serialize().toString("base64"),
            i = this._buildArgs([n], r),
            s = await this._rpcRequest("getFeeForMessage", i),
            o = je(s, $r(lt(ue())));
        if ("error" in o) throw new Error("failed to get slot: " + o.error.message);
        if (o.result === null) throw new Error("invalid blockhash");
        return o.result
    }
    async getRecentBlockhash(e) {
        try {
            return (await this.getRecentBlockhashAndContext(e)).value
        } catch (r) {
            throw new Error("failed to get recent blockhash: " + r)
        }
    }
    async getLatestBlockhash(e) {
        try {
            return (await this.getLatestBlockhashAndContext(e)).value
        } catch (r) {
            throw new Error("failed to get recent blockhash: " + r)
        }
    }
    async getLatestBlockhashAndContext(e) {
        const r = this._buildArgs([], e),
            n = await this._rpcRequest("getLatestBlockhash", r),
            i = je(n, tI);
        if ("error" in i) throw new Error("failed to get latest blockhash: " + i.error.message);
        return i.result
    }
    async getVersion() {
        const e = await this._rpcRequest("getVersion", []),
            r = je(e, Wt(c_));
        if ("error" in r) throw new Error("failed to get version: " + r.error.message);
        return r.result
    }
    async getGenesisHash() {
        const e = await this._rpcRequest("getGenesisHash", []),
            r = je(e, Wt(Fe()));
        if ("error" in r) throw new Error("failed to get genesis hash: " + r.error.message);
        return r.result
    }
    async getBlock(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r && r.commitment),
            i = await this._rpcRequest("getBlock", n),
            s = je(i, J_);
        if ("error" in s) throw new Error("failed to get confirmed block: " + s.error.message);
        const o = s.result;
        return o && xt(Ce({}, o), {
            transactions: o.transactions.map(({
                transaction: a,
                meta: c
            }) => {
                const d = new qs(a.message);
                return {
                    meta: c,
                    transaction: xt(Ce({}, a), {
                        message: d
                    })
                }
            })
        })
    }
    async getBlockHeight(e) {
        const r = this._buildArgs([], e),
            n = await this._rpcRequest("getBlockHeight", r),
            i = je(n, Wt(ue()));
        if ("error" in i) throw new Error("failed to get block height information: " + i.error.message);
        return i.result
    }
    async getBlockProduction(e) {
        let r, n;
        if (typeof e == "string") n = e;
        else if (e) {
            const a = e,
                {
                    commitment: c
                } = a,
                d = Wn(a, ["commitment"]);
            n = c, r = d
        }
        const i = this._buildArgs([], n, "base64", r),
            s = await this._rpcRequest("getBlockProduction", i),
            o = je(s, d_);
        if ("error" in o) throw new Error("failed to get block production information: " + o.error.message);
        return o.result
    }
    async getTransaction(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r && r.commitment),
            i = await this._rpcRequest("getTransaction", n),
            s = je(i, k0);
        if ("error" in s) throw new Error("failed to get transaction: " + s.error.message);
        const o = s.result;
        return o && xt(Ce({}, o), {
            transaction: xt(Ce({}, o.transaction), {
                message: new qs(o.transaction.message)
            })
        })
    }
    async getParsedTransaction(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed"),
            i = await this._rpcRequest("getTransaction", n),
            s = je(i, cf);
        if ("error" in s) throw new Error("failed to get transaction: " + s.error.message);
        return s.result
    }
    async getParsedTransactions(e, r) {
        const n = e.map(o => {
            const a = this._buildArgsAtLeastConfirmed([o], r, "jsonParsed");
            return {
                methodName: "getTransaction",
                args: a
            }
        });
        return (await this._rpcBatchRequest(n)).map(o => {
            const a = je(o, cf);
            if ("error" in a) throw new Error("failed to get transactions: " + a.error.message);
            return a.result
        })
    }
    async getTransactions(e, r) {
        const n = e.map(o => {
            const a = this._buildArgsAtLeastConfirmed([o], r);
            return {
                methodName: "getTransaction",
                args: a
            }
        });
        return (await this._rpcBatchRequest(n)).map(o => {
            const a = je(o, k0);
            if ("error" in a) throw new Error("failed to get transactions: " + a.error.message);
            return a.result
        })
    }
    async getConfirmedBlock(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r),
            i = await this._rpcRequest("getConfirmedBlock", n),
            s = je(i, X_);
        if ("error" in s) throw new Error("failed to get confirmed block: " + s.error.message);
        const o = s.result;
        if (!o) throw new Error("Confirmed block " + e + " not found");
        const a = xt(Ce({}, o), {
            transactions: o.transactions.map(({
                transaction: c,
                meta: d
            }) => {
                const y = new qs(c.message);
                return {
                    meta: d,
                    transaction: xt(Ce({}, c), {
                        message: y
                    })
                }
            })
        });
        return xt(Ce({}, a), {
            transactions: a.transactions.map(({
                transaction: c,
                meta: d
            }) => ({
                meta: d,
                transaction: Ls.populate(c.message, c.signatures)
            }))
        })
    }
    async getBlocks(e, r, n) {
        const i = this._buildArgsAtLeastConfirmed(r !== void 0 ? [e, r] : [e], n),
            s = await this._rpcRequest("getBlocks", i),
            o = je(s, Wt(nt(ue())));
        if ("error" in o) throw new Error("failed to get blocks: " + o.error.message);
        return o.result
    }
    async getBlockSignatures(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            }),
            i = await this._rpcRequest("getBlock", n),
            s = je(i, Hv);
        if ("error" in s) throw new Error("failed to get block: " + s.error.message);
        const o = s.result;
        if (!o) throw new Error("Block " + e + " not found");
        return o
    }
    async getConfirmedBlockSignatures(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r, void 0, {
                transactionDetails: "signatures",
                rewards: !1
            }),
            i = await this._rpcRequest("getConfirmedBlock", n),
            s = je(i, Hv);
        if ("error" in s) throw new Error("failed to get confirmed block: " + s.error.message);
        const o = s.result;
        if (!o) throw new Error("Confirmed block " + e + " not found");
        return o
    }
    async getConfirmedTransaction(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r),
            i = await this._rpcRequest("getConfirmedTransaction", n),
            s = je(i, k0);
        if ("error" in s) throw new Error("failed to get transaction: " + s.error.message);
        const o = s.result;
        if (!o) return o;
        const a = new qs(o.transaction.message),
            c = o.transaction.signatures;
        return xt(Ce({}, o), {
            transaction: Ls.populate(a, c)
        })
    }
    async getParsedConfirmedTransaction(e, r) {
        const n = this._buildArgsAtLeastConfirmed([e], r, "jsonParsed"),
            i = await this._rpcRequest("getConfirmedTransaction", n),
            s = je(i, cf);
        if ("error" in s) throw new Error("failed to get confirmed transaction: " + s.error.message);
        return s.result
    }
    async getParsedConfirmedTransactions(e, r) {
        const n = e.map(o => {
            const a = this._buildArgsAtLeastConfirmed([o], r, "jsonParsed");
            return {
                methodName: "getConfirmedTransaction",
                args: a
            }
        });
        return (await this._rpcBatchRequest(n)).map(o => {
            const a = je(o, cf);
            if ("error" in a) throw new Error("failed to get confirmed transactions: " + a.error.message);
            return a.result
        })
    }
    async getConfirmedSignaturesForAddress(e, r, n) {
        let i = {},
            s = await this.getFirstAvailableBlock();
        for (; !("until" in i) && (r--, !(r <= 0 || r < s));) try {
            const c = await this.getConfirmedBlockSignatures(r, "finalized");
            c.signatures.length > 0 && (i.until = c.signatures[c.signatures.length - 1].toString())
        } catch (c) {
            if (c instanceof Error && c.message.includes("skipped")) continue;
            throw c
        }
        let o = await this.getSlot("finalized");
        for (; !("before" in i) && (n++, !(n > o));) try {
            const c = await this.getConfirmedBlockSignatures(n);
            c.signatures.length > 0 && (i.before = c.signatures[c.signatures.length - 1].toString())
        } catch (c) {
            if (c instanceof Error && c.message.includes("skipped")) continue;
            throw c
        }
        return (await this.getConfirmedSignaturesForAddress2(e, i)).map(c => c.signature)
    }
    async getConfirmedSignaturesForAddress2(e, r, n) {
        const i = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, r),
            s = await this._rpcRequest("getConfirmedSignaturesForAddress2", i),
            o = je(s, N_);
        if ("error" in o) throw new Error("failed to get confirmed signatures for address: " + o.error.message);
        return o.result
    }
    async getSignaturesForAddress(e, r, n) {
        const i = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, r),
            s = await this._rpcRequest("getSignaturesForAddress", i),
            o = je(s, T_);
        if ("error" in o) throw new Error("failed to get signatures for address: " + o.error.message);
        return o.result
    }
    async getNonceAndContext(e, r) {
        const {
            context: n,
            value: i
        } = await this.getAccountInfoAndContext(e, r);
        let s = null;
        return i !== null && (s = C1.fromAccountData(i.data)), {
            context: n,
            value: s
        }
    }
    async getNonce(e, r) {
        return await this.getNonceAndContext(e, r).then(n => n.value).catch(n => {
            throw new Error("failed to get nonce for account " + e.toBase58() + ": " + n)
        })
    }
    async requestAirdrop(e, r) {
        const n = await this._rpcRequest("requestAirdrop", [e.toBase58(), r]),
            i = je(n, sI);
        if ("error" in i) throw new Error("airdrop to " + e.toBase58() + " failed: " + i.error.message);
        return i.result
    }
    async _blockhashWithExpiryBlockHeight(e) {
        if (!e) {
            for (; this._pollingBlockhash;) await Rf(100);
            const n = Date.now() - this._blockhashInfo.lastFetch >= r_;
            if (this._blockhashInfo.latestBlockhash !== null && !n) return this._blockhashInfo.latestBlockhash
        }
        return await this._pollNewBlockhash()
    }
    async _pollNewBlockhash() {
        this._pollingBlockhash = !0;
        try {
            const e = Date.now(),
                r = this._blockhashInfo.latestBlockhash,
                n = r ? r.blockhash : null;
            for (let i = 0; i < 50; i++) {
                const s = await this.getLatestBlockhash("finalized");
                if (n !== s.blockhash) return this._blockhashInfo = {
                    latestBlockhash: s,
                    lastFetch: Date.now(),
                    transactionSignatures: [],
                    simulatedSignatures: []
                }, s;
                await Rf(e_ / 2)
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)
        } finally {
            this._pollingBlockhash = !1
        }
    }
    async simulateTransaction(e, r, n) {
        let i;
        if (e instanceof Ls) {
            let E = e;
            i = new Ls, i.feePayer = E.feePayer, i.instructions = e.instructions, i.nonceInfo = E.nonceInfo, i.signatures = E.signatures
        } else i = Ls.populate(e), i._message = i._json = void 0;
        if (i.nonceInfo && r) i.sign(...r);
        else {
            let E = this._disableBlockhashCaching;
            for (;;) {
                const T = await this._blockhashWithExpiryBlockHeight(E);
                if (i.lastValidBlockHeight = T.lastValidBlockHeight, i.recentBlockhash = T.blockhash, !r) break;
                if (i.sign(...r), !i.signature) throw new Error("!signature");
                const j = i.signature.toString("base64");
                if (!this._blockhashInfo.simulatedSignatures.includes(j) && !this._blockhashInfo.transactionSignatures.includes(j)) {
                    this._blockhashInfo.simulatedSignatures.push(j);
                    break
                } else E = !0
            }
        }
        const s = i._compile(),
            o = s.serialize(),
            c = i._serialize(o).toString("base64"),
            d = {
                encoding: "base64",
                commitment: this.commitment
            };
        if (n) {
            const E = (Array.isArray(n) ? n : s.nonProgramIds()).map(T => T.toBase58());
            d.accounts = {
                encoding: "base64",
                addresses: E
            }
        }
        r && (d.sigVerify = !0);
        const y = [c, d],
            I = await this._rpcRequest("simulateTransaction", y),
            N = je(I, h_);
        if ("error" in N) {
            let E;
            if ("data" in N.error && (E = N.error.data.logs, E && Array.isArray(E))) {
                const T = `
    `,
                    j = T + E.join(T);
                console.error(N.error.message, j)
            }
            throw new jv("failed to simulate transaction: " + N.error.message, E)
        }
        return N.result
    }
    async sendTransaction(e, r, n) {
        if (e.nonceInfo) e.sign(...r);
        else {
            let s = this._disableBlockhashCaching;
            for (;;) {
                const o = await this._blockhashWithExpiryBlockHeight(s);
                if (e.lastValidBlockHeight = o.lastValidBlockHeight, e.recentBlockhash = o.blockhash, e.sign(...r), !e.signature) throw new Error("!signature");
                const a = e.signature.toString("base64");
                if (this._blockhashInfo.transactionSignatures.includes(a)) s = !0;
                else {
                    this._blockhashInfo.transactionSignatures.push(a);
                    break
                }
            }
        }
        const i = e.serialize();
        return await this.sendRawTransaction(i, n)
    }
    async sendRawTransaction(e, r) {
        const n = Bl(e).toString("base64");
        return await this.sendEncodedTransaction(n, r)
    }
    async sendEncodedTransaction(e, r) {
        const n = {
                encoding: "base64"
            },
            i = r && r.skipPreflight,
            s = r && r.preflightCommitment || this.commitment;
        r && r.maxRetries && (n.maxRetries = r.maxRetries), i && (n.skipPreflight = i), s && (n.preflightCommitment = s);
        const o = [e, n],
            a = await this._rpcRequest("sendTransaction", o),
            c = je(a, oI);
        if ("error" in c) {
            let d;
            throw "data" in c.error && (d = c.error.data.logs), new jv("failed to send transaction: " + c.error.message, d)
        }
        return c.result
    }
    _wsOnOpen() {
        this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
            this._rpcWebSocket.notify("ping").catch(() => {})
        }, 5e3), this._updateSubscriptions()
    }
    _wsOnError(e) {
        this._rpcWebSocketConnected = !1, console.error("ws error:", e.message)
    }
    _wsOnClose(e) {
        if (this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration++, this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), e === 1e3) {
            this._updateSubscriptions();
            return
        }
        this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([r, n]) => {
            this._subscriptionsByHash[r] = xt(Ce({}, n), {
                state: "pending"
            })
        })
    }
    async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
            this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                    this._rpcWebSocket.close()
                } catch (n) {
                    n instanceof Error && console.log(`Error when closing socket connection: ${n.message}`)
                }
            }, 500));
            return
        }
        if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return
        }
        const e = this._rpcWebSocketGeneration,
            r = () => e === this._rpcWebSocketGeneration;
        await Promise.all(Object.keys(this._subscriptionsByHash).map(async n => {
            const i = this._subscriptionsByHash[n];
            if (i !== void 0) switch (i.state) {
                case "pending":
                case "unsubscribed":
                    if (i.callbacks.size === 0) {
                        delete this._subscriptionsByHash[n], i.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[i.serverSubscriptionId], await this._updateSubscriptions();
                        return
                    }
                    await (async () => {
                        const {
                            args: s,
                            method: o
                        } = i;
                        try {
                            this._subscriptionsByHash[n] = xt(Ce({}, i), {
                                state: "subscribing"
                            });
                            const a = await this._rpcWebSocket.call(o, s);
                            this._subscriptionsByHash[n] = xt(Ce({}, i), {
                                serverSubscriptionId: a,
                                state: "subscribed"
                            }), this._subscriptionCallbacksByServerSubscriptionId[a] = i.callbacks, await this._updateSubscriptions()
                        } catch (a) {
                            if (a instanceof Error && console.error(`${o} error for argument`, s, a.message), !r()) return;
                            this._subscriptionsByHash[n] = xt(Ce({}, i), {
                                state: "pending"
                            }), await this._updateSubscriptions()
                        }
                    })();
                    break;
                case "subscribed":
                    i.callbacks.size === 0 && await (async () => {
                        const {
                            serverSubscriptionId: s,
                            unsubscribeMethod: o
                        } = i;
                        if (this._subscriptionsAutoDisposedByRpc.has(s)) this._subscriptionsAutoDisposedByRpc.delete(s);
                        else {
                            this._subscriptionsByHash[n] = xt(Ce({}, i), {
                                state: "unsubscribing"
                            });
                            try {
                                await this._rpcWebSocket.call(o, [s])
                            } catch (a) {
                                if (a instanceof Error && console.error(`${o} error:`, a.message), !r()) return;
                                this._subscriptionsByHash[n] = xt(Ce({}, i), {
                                    state: "subscribed"
                                }), await this._updateSubscriptions();
                                return
                            }
                        }
                        this._subscriptionsByHash[n] = xt(Ce({}, i), {
                            state: "unsubscribed"
                        }), await this._updateSubscriptions()
                    })();
                    break
            }
        }))
    }
    _handleServerNotification(e, r) {
        const n = this._subscriptionCallbacksByServerSubscriptionId[e];
        n !== void 0 && n.forEach(i => {
            try {
                i(...r)
            } catch (s) {
                console.error(s)
            }
        })
    }
    _wsOnAccountNotification(e) {
        const {
            result: r,
            subscription: n
        } = je(e, O_);
        this._handleServerNotification(n, [r.value, r.context])
    }
    _makeSubscription(e, r) {
        const n = this._nextClientSubscriptionId++,
            i = V5([e.method, r]),
            s = this._subscriptionsByHash[i];
        return s === void 0 ? this._subscriptionsByHash[i] = xt(Ce({}, e), {
            args: r,
            callbacks: new Set([e.callback]),
            state: "pending"
        }) : s.callbacks.add(e.callback), this._subscriptionDisposeFunctionsByClientSubscriptionId[n] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n];
            const o = this._subscriptionsByHash[i];
            Yn(o !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${n}`), o.callbacks.delete(e.callback), await this._updateSubscriptions()
        }, this._updateSubscriptions(), n
    }
    onAccountChange(e, r, n) {
        const i = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64");
        return this._makeSubscription({
            callback: r,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
        }, i)
    }
    async removeAccountChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "account change")
    }
    _wsOnProgramAccountNotification(e) {
        const {
            result: r,
            subscription: n
        } = je(e, D_);
        this._handleServerNotification(n, [{
            accountId: r.value.pubkey,
            accountInfo: r.value.account
        }, r.context])
    }
    onProgramAccountChange(e, r, n, i) {
        const s = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64", i ? {
            filters: i
        } : void 0);
        return this._makeSubscription({
            callback: r,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
        }, s)
    }
    async removeProgramAccountChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "program account change")
    }
    onLogs(e, r, n) {
        const i = this._buildArgs([typeof e == "object" ? {
            mentions: [e.toString()]
        } : e], n || this._commitment || "finalized");
        return this._makeSubscription({
            callback: r,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
        }, i)
    }
    async removeOnLogsListener(e) {
        await this._unsubscribeClientSubscription(e, "logs")
    }
    _wsOnLogsNotification(e) {
        const {
            result: r,
            subscription: n
        } = je(e, uI);
        this._handleServerNotification(n, [r.value, r.context])
    }
    _wsOnSlotNotification(e) {
        const {
            result: r,
            subscription: n
        } = je(e, L_);
        this._handleServerNotification(n, [r])
    }
    onSlotChange(e) {
        return this._makeSubscription({
            callback: e,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
        }, [])
    }
    async removeSlotChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "slot change")
    }
    _wsOnSlotUpdatesNotification(e) {
        const {
            result: r,
            subscription: n
        } = je(e, U_);
        this._handleServerNotification(n, [r])
    }
    onSlotUpdate(e) {
        return this._makeSubscription({
            callback: e,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, [])
    }
    async removeSlotUpdateListener(e) {
        await this._unsubscribeClientSubscription(e, "slot update")
    }
    async _unsubscribeClientSubscription(e, r) {
        const n = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
        n ? await n() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${r}' events could not be found.`)
    }
    _buildArgs(e, r, n, i) {
        const s = r || this._commitment;
        if (s || n || i) {
            let o = {};
            n && (o.encoding = n), s && (o.commitment = s), i && (o = Object.assign(o, i)), e.push(o)
        }
        return e
    }
    _buildArgsAtLeastConfirmed(e, r, n, i) {
        const s = r || this._commitment;
        if (s && !["confirmed", "finalized"].includes(s)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        return this._buildArgs(e, r, n, i)
    }
    _wsOnSignatureNotification(e) {
        const {
            result: r,
            subscription: n
        } = je(e, z_);
        r.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(n), this._handleServerNotification(n, r.value === "receivedSignature" ? [{
            type: "received"
        }, r.context] : [{
            type: "status",
            result: r.value
        }, r.context])
    }
    onSignature(e, r, n) {
        const i = this._buildArgs([e], n || this._commitment || "finalized"),
            s = this._makeSubscription({
                callback: (o, a) => {
                    if (o.type === "status") {
                        r(o.result, a);
                        try {
                            this.removeSignatureListener(s)
                        } catch {}
                    }
                },
                method: "signatureSubscribe",
                unsubscribeMethod: "signatureUnsubscribe"
            }, i);
        return s
    }
    onSignatureWithOptions(e, r, n) {
        const c = xt(Ce({}, n), {
                commitment: n && n.commitment || this._commitment || "finalized"
            }),
            {
                commitment: i
            } = c,
            s = Wn(c, ["commitment"]),
            o = this._buildArgs([e], i, void 0, s),
            a = this._makeSubscription({
                callback: (d, y) => {
                    r(d, y);
                    try {
                        this.removeSignatureListener(a)
                    } catch {}
                },
                method: "signatureSubscribe",
                unsubscribeMethod: "signatureUnsubscribe"
            }, o);
        return a
    }
    async removeSignatureListener(e) {
        await this._unsubscribeClientSubscription(e, "signature result")
    }
    _wsOnRootNotification(e) {
        const {
            result: r,
            subscription: n
        } = je(e, j_);
        this._handleServerNotification(n, [r])
    }
    onRootChange(e) {
        return this._makeSubscription({
            callback: e,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
        }, [])
    }
    async removeRootChangeListener(e) {
        await this._unsubscribeClientSubscription(e, "root change")
    }
}
pt([Rr("numSignatures"), Rr("padding"), Kn("signatureOffset"), Kn("signatureInstructionIndex"), Kn("publicKeyOffset"), Kn("publicKeyInstructionIndex"), Kn("messageDataOffset"), Kn("messageDataSize"), Kn("messageInstructionIndex")]);
new bt("Ed25519SigVerify111111111111111111111111111");
new bt("StakeConfig11111111111111111111111111111111");
class Qv {
    constructor(e, r, n) {
        this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = r, this.custodian = n
    }
}
Qv.default = new Qv(0, 0, bt.default);
Object.freeze({
    Initialize: {
        index: 0,
        layout: pt([yt("instruction"), L5(), F5()])
    },
    Authorize: {
        index: 1,
        layout: pt([yt("instruction"), ir("newAuthorized"), yt("stakeAuthorizationType")])
    },
    Delegate: {
        index: 2,
        layout: pt([yt("instruction")])
    },
    Split: {
        index: 3,
        layout: pt([yt("instruction"), Pn("lamports")])
    },
    Withdraw: {
        index: 4,
        layout: pt([yt("instruction"), Pn("lamports")])
    },
    Deactivate: {
        index: 5,
        layout: pt([yt("instruction")])
    },
    Merge: {
        index: 7,
        layout: pt([yt("instruction")])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: pt([yt("instruction"), ir("newAuthorized"), yt("stakeAuthorizationType"), Tu("authoritySeed"), ir("authorityOwner")])
    }
});
Object.freeze({
    Staker: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
});
new bt("Stake11111111111111111111111111111111111111");
pt([Rr("numSignatures"), Kn("signatureOffset"), Rr("signatureInstructionIndex"), Kn("ethAddressOffset"), Rr("ethAddressInstructionIndex"), Kn("messageDataOffset"), Kn("messageDataSize"), Rr("messageInstructionIndex"), Xn(20, "ethAddress"), Xn(64, "signature"), Rr("recoveryId")]);
new bt("KeccakSecp256k11111111111111111111111111111");
new bt("Va1idator1nfo111111111111111111111111111111");
Ee({
    name: Fe(),
    website: ar(Fe()),
    details: ar(Fe()),
    keybaseUsername: ar(Fe())
});
new bt("Vote111111111111111111111111111111111111111");
pt([ir("nodePubkey"), ir("authorizedWithdrawer"), Rr("commission"), hn(), $s(pt([hn("slot"), yt("confirmationCount")]), Vu(yt(), -8), "votes"), Rr("rootSlotValid"), hn("rootSlot"), hn(), $s(pt([hn("epoch"), ir("authorizedVoter")]), Vu(yt(), -8), "authorizedVoters"), pt([$s(pt([ir("authorizedPubkey"), hn("epochOfLastAuthorizedSwitch"), hn("targetEpoch")]), 32, "buf"), hn("idx"), Rr("isEmpty")], "priorVoters"), hn(), $s(pt([hn("epoch"), hn("credits"), hn("prevCredits")]), Vu(yt(), -8), "epochCredits"), pt([hn("slot"), hn("timestamp")], "lastTimestamp")]);
Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: pt([yt("instruction"), U5()])
    },
    Authorize: {
        index: 1,
        layout: pt([yt("instruction"), ir("newAuthorized"), yt("voteAuthorizationType")])
    },
    Withdraw: {
        index: 3,
        layout: pt([yt("instruction"), Pn("lamports")])
    }
});
Object.freeze({
    Voter: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
});
new bt("Vote111111111111111111111111111111111111111");
const qv = {
    http: {
        devnet: "http://api.devnet.solana.com",
        testnet: "http://api.testnet.solana.com",
        "mainnet-beta": "http://api.mainnet-beta.solana.com/"
    },
    https: {
        devnet: "https://api.devnet.solana.com",
        testnet: "https://api.testnet.solana.com",
        "mainnet-beta": "https://api.mainnet-beta.solana.com/"
    }
};

function fI(t, e) {
    const r = e === !1 ? "http" : "https";
    if (!t) return qv[r].devnet;
    const n = qv[r][t];
    if (!n) throw new Error(`Unknown ${r} cluster: ${t}`);
    return n
}
const cI = _e.exports.createContext({});
var Ah = {
        exports: {}
    },
    Sh = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hI = _e.exports,
    dI = Symbol.for("react.element"),
    pI = Symbol.for("react.fragment"),
    mI = Object.prototype.hasOwnProperty,
    vI = hI.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    gI = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function Hx(t, e, r) {
    var n, i = {},
        s = null,
        o = null;
    r !== void 0 && (s = "" + r), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
    for (n in e) mI.call(e, n) && !gI.hasOwnProperty(n) && (i[n] = e[n]);
    if (t && t.defaultProps)
        for (n in e = t.defaultProps, e) i[n] === void 0 && (i[n] = e[n]);
    return {
        $$typeof: dI,
        type: t,
        key: s,
        ref: o,
        props: i,
        _owner: vI.current
    }
}
Sh.Fragment = pI;
Sh.jsx = Hx;
Sh.jsxs = Hx;
Ah.exports = Sh;
const qe = Ah.exports.jsx,
    vr = Ah.exports.jsxs,
    N0 = Ah.exports.Fragment,
    yI = ({
        children: t,
        endpoint: e,
        config: r = {
            commitment: "confirmed"
        }
    }) => {
        const n = _e.exports.useMemo(() => new lI(e, r), [e, r]);
        return qe(cI.Provider, {
            value: {
                connection: n
            },
            children: t
        })
    };
var kt;
(function(t) {
    t.Installed = "Installed", t.NotDetected = "NotDetected", t.Loadable = "Loadable", t.Unsupported = "Unsupported"
})(kt || (kt = {}));
class wI extends VA {
    get connected() {
        return !!this.publicKey
    }
}

function Mh(t) {
    if (typeof window == "undefined" || typeof document == "undefined") return;
    const e = [];

    function r() {
        if (t())
            for (const s of e) s()
    }
    const n = setInterval(r, 1e3);
    e.push(() => clearInterval(n)), document.readyState === "loading" && (document.addEventListener("DOMContentLoaded", r, {
        once: !0
    }), e.push(() => document.removeEventListener("DOMContentLoaded", r))), document.readyState !== "complete" && (window.addEventListener("load", r, {
        once: !0
    }), e.push(() => window.removeEventListener("load", r))), r()
}
class Fr extends Error {
    constructor(e, r) {
        super(e), this.error = r
    }
}
class eu extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletNotReadyError"
    }
}
class Qx extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletLoadError"
    }
}
class qx extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletConfigError"
    }
}
class Ra extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletConnectionError"
    }
}
class T1 extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletDisconnectedError"
    }
}
class Da extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletDisconnectionError"
    }
}
class Eh extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletAccountError"
    }
}
class Nl extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletPublicKeyError"
    }
}
class Pr extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletNotConnectedError"
    }
}
class xI extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletSendTransactionError"
    }
}
class Kr extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletSignTransactionError"
    }
}
class bI extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletWindowClosedError"
    }
}
class AI extends wI {
    async sendTransaction(e, r, n = {}) {
        let i = !0;
        try {
            try {
                e.feePayer = e.feePayer || this.publicKey || void 0, e.recentBlockhash = e.recentBlockhash || (await r.getRecentBlockhash("finalized")).blockhash;
                const s = n,
                    {
                        signers: o
                    } = s,
                    a = Wn(s, ["signers"]);
                o != null && o.length && e.partialSign(...o), e = await this.signTransaction(e);
                const c = e.serialize();
                return await r.sendRawTransaction(c, a)
            } catch (o) {
                throw o instanceof Fr ? (i = !1, o) : new xI(o == null ? void 0 : o.message, o)
            }
        } catch (o) {
            throw i && this.emit("error", o), o
        }
    }
}
class Tl extends AI {}
var Xd;
(function(t) {
    t.Mainnet = "mainnet-beta", t.Testnet = "testnet", t.Devnet = "devnet"
})(Xd || (Xd = {}));
class Wv extends Fr {
    constructor() {
        super(...arguments), this.name = "WalletNotSelectedError"
    }
}
const SI = [],
    _h = {
        autoConnect: !1,
        connecting: !1,
        connected: !1,
        disconnecting: !1,
        select(t) {
            console.error(Ri("get", "select"))
        },
        connect() {
            return Promise.reject(console.error(Ri("get", "connect")))
        },
        disconnect() {
            return Promise.reject(console.error(Ri("get", "disconnect")))
        },
        sendTransaction(t, e, r) {
            return Promise.reject(console.error(Ri("get", "sendTransaction")))
        },
        signTransaction(t) {
            return Promise.reject(console.error(Ri("get", "signTransaction")))
        },
        signAllTransactions(t) {
            return Promise.reject(console.error(Ri("get", "signAllTransactions")))
        },
        signMessage(t) {
            return Promise.reject(console.error(Ri("get", "signMessage")))
        }
    };
Object.defineProperty(_h, "wallets", {
    get() {
        return console.error(Ri("read", "wallets")), SI
    }
});
Object.defineProperty(_h, "wallet", {
    get() {
        return console.error(Ri("read", "wallet")), null
    }
});
Object.defineProperty(_h, "publicKey", {
    get() {
        return console.error(Ri("read", "publicKey")), null
    }
});

function Ri(t, e) {
    return `You have tried to  ${t} "${e}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext`
}
const Wx = _e.exports.createContext(_h);

function Ol() {
    return _e.exports.useContext(Wx)
}

function MI(t, e) {
    const r = _e.exports.useState(() => {
            try {
                const s = localStorage.getItem(t);
                if (s) return JSON.parse(s)
            } catch (s) {
                typeof window != "undefined" && console.error(s)
            }
            return e
        }),
        n = r[0],
        i = _e.exports.useRef(!0);
    return _e.exports.useEffect(() => {
        if (i.current) {
            i.current = !1;
            return
        }
        try {
            n === null ? localStorage.removeItem(t) : localStorage.setItem(t, JSON.stringify(n))
        } catch (s) {
            typeof window != "undefined" && console.error(s)
        }
    }, [n]), r
}
const Vv = {
        wallet: null,
        adapter: null,
        publicKey: null,
        connected: !1
    },
    EI = ({
        children: t,
        wallets: e,
        autoConnect: r = !1,
        onError: n,
        localStorageKey: i = "walletName"
    }) => {
        const [s, o] = MI(i, null), [{
            wallet: a,
            adapter: c,
            publicKey: d,
            connected: y
        }, I] = _e.exports.useState(Vv), N = (c == null ? void 0 : c.readyState) || kt.Unsupported, [E, T] = _e.exports.useState(!1), [j, V] = _e.exports.useState(!1), P = _e.exports.useRef(!1), O = _e.exports.useRef(!1), R = _e.exports.useRef(!1), [q, W] = _e.exports.useState(() => e.map(h => ({
            adapter: h,
            readyState: h.readyState
        })));
        _e.exports.useEffect(() => {
            function h(b) {
                W(C => {
                    const _ = C.findIndex(({
                        adapter: M
                    }) => M.name === this.name);
                    return _ === -1 ? C : [...C.slice(0, _), xt(Ce({}, C[_]), {
                        readyState: b
                    }), ...C.slice(_ + 1)]
                })
            }
            for (const b of e) b.on("readyStateChange", h, b);
            return () => {
                for (const b of e) b.off("readyStateChange", h, b)
            }
        }, [e]), _e.exports.useEffect(() => {
            const h = q.find(({
                adapter: b
            }) => b.name === s);
            I(h ? {
                wallet: h,
                adapter: h.adapter,
                connected: h.adapter.connected,
                publicKey: h.adapter.publicKey
            } : Vv)
        }, [s, q]), _e.exports.useEffect(() => {
            P.current || E || y || !r || !c || !(N === kt.Installed || N === kt.Loadable) || async function() {
                P.current = !0, T(!0);
                try {
                    await c.connect()
                } catch {
                    o(null)
                } finally {
                    T(!1), P.current = !1
                }
            }()
        }, [P, E, y, r, c, N]), _e.exports.useEffect(() => {
            function h() {
                R.current = !0
            }
            return window.addEventListener("beforeunload", h), () => window.removeEventListener("beforeunload", h)
        }, [R]);
        const Y = _e.exports.useCallback(() => {
                !c || I(h => xt(Ce({}, h), {
                    connected: c.connected,
                    publicKey: c.publicKey
                }))
            }, [c]),
            G = _e.exports.useCallback(() => {
                R.current || o(null)
            }, [R]),
            J = _e.exports.useCallback(h => (R.current || (n || console.error)(h), h), [R, n]);
        _e.exports.useEffect(() => {
            if (c) return c.on("connect", Y), c.on("disconnect", G), c.on("error", J), () => {
                c.off("connect", Y), c.off("disconnect", G), c.off("error", J)
            }
        }, [c, Y, G, J]), _e.exports.useEffect(() => () => {
            c == null || c.disconnect()
        }, [c]);
        const pe = _e.exports.useCallback(async () => {
                if (!(P.current || E || j || y)) {
                    if (!c) throw J(new Wv);
                    if (!(N === kt.Installed || N === kt.Loadable)) throw o(null), typeof window != "undefined" && window.open(c.url, "_blank"), J(new eu);
                    P.current = !0, T(!0);
                    try {
                        await c.connect()
                    } catch (h) {
                        throw o(null), h
                    } finally {
                        T(!1), P.current = !1
                    }
                }
            }, [P, E, j, y, c, N, J]),
            we = _e.exports.useCallback(async () => {
                if (!(O.current || j)) {
                    if (!c) return o(null);
                    O.current = !0, V(!0);
                    try {
                        await c.disconnect()
                    } catch (h) {
                        throw o(null), h
                    } finally {
                        V(!1), O.current = !1
                    }
                }
            }, [O, j, c]),
            H = _e.exports.useCallback(async (h, b, C) => {
                if (!c) throw J(new Wv);
                if (!y) throw J(new Pr);
                return await c.sendTransaction(h, b, C)
            }, [c, J, y]),
            w = _e.exports.useMemo(() => c && "signTransaction" in c ? async h => {
                if (!y) throw J(new Pr);
                return await c.signTransaction(h)
            } : void 0, [c, J, y]),
            p = _e.exports.useMemo(() => c && "signAllTransactions" in c ? async h => {
                if (!y) throw J(new Pr);
                return await c.signAllTransactions(h)
            } : void 0, [c, J, y]),
            f = _e.exports.useMemo(() => c && "signMessage" in c ? async h => {
                if (!y) throw J(new Pr);
                return await c.signMessage(h)
            } : void 0, [c, J, y]);
        return qe(Wx.Provider, {
            value: {
                autoConnect: r,
                wallets: q,
                wallet: a,
                publicKey: d,
                connected: y,
                connecting: E,
                disconnecting: j,
                select: o,
                connect: pe,
                disconnect: we,
                sendTransaction: H,
                signTransaction: w,
                signAllTransactions: p,
                signMessage: f
            },
            children: t
        })
    },
    _I = "modulepreload",
    Gv = {},
    II = "/",
    Vx = function(e, r) {
        return !r || r.length === 0 ? e() : Promise.all(r.map(n => {
            if (n = `${II}${n}`, n in Gv) return;
            Gv[n] = !0;
            const i = n.endsWith(".css"),
                s = i ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${n}"]${s}`)) return;
            const o = document.createElement("link");
            if (o.rel = i ? "stylesheet" : _I, i || (o.as = "script", o.crossOrigin = ""), o.href = n, document.head.appendChild(o), i) return new Promise((a, c) => {
                o.addEventListener("load", a), o.addEventListener("error", () => c(new Error(`Unable to preload CSS for ${n}`)))
            })
        })).then(() => e())
    },
    CI = "Glow";
class BI extends Tl {
    constructor(e = {}) {
        if (super(), this.name = CI, this.url = "https://glow.app", this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAB4FBMVEUAAACjON6dNNyjONd7C+GIHNq1S+K9W+O3TeLAVOe6TuSJHtqcMdPBVeiuQt2kOdeRJc7AVeeyRd95COR9DeF7CuKWKtCaL9KoPdr78/789/7//f+zPt7u0Pi7ROG5SuK9TOT67/315PzVYfHAT+bx1Pry4PuiMNWmMdaqN9moM9fv2vqvOdvtzff15/ysN9mxO9yzRN/13/ysPdz46Py/SeTFVemPE+/EUOe5QeC3P+DJW+y9SOOfLtPZYvT46/2TGOu2R+GNEPKaI9/PXO7t1fjbZfWgLNfu0/jIV+rQX++ZKdCQIdSWIOGmN9iYJNvCVOjRVe/CTOaKE+eZKNSgKd2TIdnLV+yECfGfKdqKEO2dJ9ylL9iNHdr02/uHC/KjLdp+BfCcKdbKU+t7B+eUJs+dLNKTHeG+ROXUW/GLGeCFFd6PHN+JDfOuQd3JS+vNWu2EEeGOF+WiNtbOUe2BDOf02fuSGuWOFOuUJdPWXfGFDuvMT+yVHOWIF9vCSOiZJteACeyLHNV9C+N4A+x1A+mGGOPHUOmKHN2aLtKFEOWXHubarPLXju7CfevoxvffuPXQmu7QfuvnvfXJje3dnPHBauTOcOu4bfDjp/SqUOytStugNu6yXd6bKueVNOUmkAxzAAAAGXRSTlMAIxB+3D9C/WLfo2CcxcXf34TffL6cvc/vU7i1KQAAOkJJREFUeNrElMFuqlAQhivICpLehFofgb6ET1CjCwk7drZNwA0SFqYJ8Upq1Ke+/wwz9hwurtT2m5lT0933z+jDLRgMPN/3w3AEnoihkAt1l10PU3SHN+aP8EwEQeC6ru973sB5+GWgHY4gW5jk1LlNjSFruy13FLEz5KGP/p9X5Xg8jp8D1/cGDz+N44WjYd6cKRorAozBDgHUaIX1YV13lo8WdS5OgKfrrxwFDsL1fuogHH80bHrcG/MEUAbqv6PC37ROU3v/zI7mjYb/ofZd/TfUUeyVyQQ9Du5/C174tGxsEEFViX7znYEF++/0AlJF/MmbS+Dtb2C7QZmQvHA2R5uM3Ttm4ITDJWg6EVTwRwsNHwBaqQ0QgrpTEa28wQat9Bx/+5q77/Lo3ycD72nJWOpsL/4NTV4Q3evP2krrQ4rz7zCdog3gzxFg/Wg27/nqvxvyR5qyLCPUJIomUeDdT395tucAyL8p+EEAyt5MwOBwsN0TLmRgAn3lLG4e/yvswdmerctyIoUUwNi/i76eAA3Loxu8NKeWYr/fFwu8pyzPEUSW11mW1TX1IevY69/pFC36SSL2cbyJ2RyNR3kXe4H0eaShj8H7eLsrGOj2vxo8/AlTVeTN6ixPb1GcsgL6GUWAb0IGyJ8TYFbpCtghYEg9QYM2gVh4pbHtgS4fq9fF4wi6BIMb/fSJPRfbV7AXOILWXi8A+idM1gvrrwiSp1a2WpsY+hguiuCSP906tPkC+nFvcf1DtV8qpE+jQF5ZIAHaPqYvgwPkoU9vukosNlr4SPom6m/IR2hOAK8ym83KWWlx9ffAGen1f9tTG/IoNlcWSgbWFy8A/miTrVYM7AhIHk36SiTAEto96PfAuW79JP5Fj/IX/gafmIXtvpcS5TXNCupo3j2eD06ASKnnsNf1b7cxdWzxrlj2ZfTyEkWia9RMX+bxil+CEOpfNEszgcriE71g4P/J5sJ6sRbIXAIgPmhA8pEw8/m8fbYEJ2DKm/r29l+QgOhe5IpfAmf0j9SyaWkjisIwrS0I7bbgIn/AUDBlFm4Ds8hKs2lloouQILrLIiATGAQDycZf3ed85c4dTTX2Oefe+LF6znlndGv2eQKUh7XKNzQ8oE5BigD6mFvxlam7OTef6N+r99h4CrL1z3/P74JcX+xzTuVw5Xz0Mfj0ZauE/kblOQ9afDbKs5hzuKhnTQDXMgLg9kupezEPrqgLs7+SekojwFtKL3D/3F5xccBeL/+CuwWPwUcef8jyr/pBs25aeAT0LGX90A0A8nSoI8/+XZ71y6Fh/jTPuZun+Ef2Q7+vgjgDd2EfoJ//MYFvBB+4N5tbGv3Zeq++FFxzHPbPZbD7WjMQj74yZgIXF2NPQHoIuvrJHlrr79v+T+mckC/8KCfHB/pvFey3txv8Z7cz/BNNhok3DIB2edG3DNS1qtPBlbgbZTkuYwREwNefE/LJX+j3+5f95Fvo9uOmikspvZSjg17/4c8ERB//dgAqumoPICH6Qo2/URvy7gt/2z/rl97p34wFVZ5oz0ejOTUy/46+4f7hzSn0FPY9aEiUo4P9Af3ZZqbs078mAKlSAuItWC/VnwkYZm5XaZg+TT3d2ADUH338R7hLOaGf9m/OdIIfKTEMncDB/gTAJ8DlEah2NHQ3AKuV+HNgpfrBfRuxd0pB9DlywWQ+gVEbt4+nP20fzpL4Ty86wa89DMcHPv9BSkCFv16N1nU1NfsUACbg21/VMoM6oea4O2OpFAHcXf9m4owS2V8/9++r/dkplcw5r3N5+d4JfL0N/7DfaK1lCFWbaTWdTq+b9v6BCbB7j0A2gMd72OmXbD8Y0+g7XXt4GQBfPnVWnLnkgJO+WFiZPingTXny6b3//4S+uQdVNaua2D76Qpb/AHd62B4A9o++/6BkAoEFwNiz/zwA7i9Y9tW6p6dHFxBDcMjA2/8PfO74awJcn9PZPvqcYJXA3dj5Gzt3lw9CPgUgi0CuH/4uj77lfoB3gm8W3Rgwgbf+K/6xNdzfymH/0EiZfh4AXgDOkh4OaZnDMA2ADAS5fjlO+kFXHzJ/DUCkfzAoegPoLVoFi0WWAV6G39/8A5DvP6MKEKdoKrE6TwkAnYDKox+8OoCbMtt/sDcA/vYHe/cNlF5ONgM6ZnD0zxeA+cf+YdPVb/RMXybg/Bx/118Nawp9G8AL/449144/O/3JngCEvQ1AMH0aYw5N/er1aPvJX9rN5bWpIIzi+BYFFz7AqOSWLBTflSKloQsTEFcuBR+BVHBbQUEUpIviMjFtbSmllv6tnvkePTN37qRW6ZmZGxvr4nfmfN8MCQKfMTgxtQHk/Y/5dzl+uv/OzwR81QTgdcU1Go1evsR8SX6sV3Tg1bs0AYM7gzuYoG8KAOBBpAb4tpuehAXpu3ORBVPawLW0/DFzA4ZhQGoB8Q8SMB/wJQMSA2hlRAMCfFjkBz6m0TMB0JImAPjgN/wkAbr7c6CfJbvimwFYeHovMBWL4EzS/+gA2PEwftUyxnDYRwSUHvhvA7zQm4z+2SjI8GHASGT8YJcl9K/wIP8SDBB6237Meybtf1IAef1z88GukjciC84WDKidgGkBEN8cEANE/f686huGw2OAHuOZ4pMfCwEYRfjGj2kGhOeLpRdLA5HwswCCAdx/zATf4amPmHiPKSgVwZVaAJRcZ7b/y8vgDwnoiwVmgEzh9weebgCeFgDDpwVAlwX5/mMGiQGDgd0ATcr/2NsfJiWZ73bJTx/owKniCQA5PwbF64/zQ8M+ZA0Q8gpgAr5KBFgBln5Mp9ceIOjUm7CWVANRHADQewBmzYFI3Vvdbneh+wQO9Gr8qIKg4klwjfyEfx0eQ+M/CD/xYQCWByBYUGsBkDuA7dfhGWACVPQB9W9SfnNA+EGv4glICf3CAvAXYEAPSm1wBy6VOmC9/0F5BcAAzP6yBiDil6fBf/YAIAIrGGkPBD5FAzwARp8HgAbMzTXhgx0jqIfpiqrAe+HZUgdUC8guz1oHcFkCpAWYvAnOB3ywi4TYEwDt7Uy2xutrnU7rpqjVub+2Pt6YnKtyA1Sof0zgqwGYNID4EOBdPRggj5CENARNEbioXwA4PS3AyPlZA6p5SughwfcegCXa35mMO0Au6v7mxrm75GcFRB8CCL/guwGsfvK32712L8oAliYA4lGYBeADO0C6/8N8/xv52QSUHvtvCdgj+yHqbE6qmL92CfLyB37Cj/B3ia8WVJEJUyNwJnwFCDEAbP/N/OgBhQBYBr56DGTnx4j7UdQZb98dDOhAnACI/HEFOL2pCqtHWRdojMA14ce3PzwANQJ5/pmAsgHGji6I+O9P1m7+k9Ymv5t64F29A0BpACDlT9SrggniQ9wGahE4cfAdsNKzBZT4+4UA1LW/C/p/1+YEBtzLWsADVUMCJPqJqoopEHq/DpxMvgeCYACvQAJPlfe/HACM3a1C8o9SC7/LPSA5AS0BNXgoFEJV7wPpdfA0+P0b0OYPQModsJwAbv7/6eF2/FF48yWILSDBD8tf1AD2gUtxC9QEQJL/1YS/0P+oZv6dqfg3dOrjUHUmtY8CD/hn4wuw81NAp5gBMSBqg1eiAKyyA/AAsNtfKQAU8W83UxOb5DfiUbLgl1qg/HkPzM4AaLFytWVUtaPgFCvA+YGPscoEJOkfEr/IT/ycnha4iFx+jxYEAx6zBbAC8v1fxAgGtDGzCHgGLvEMcPE7cOC78v5XdIC1nyNhMgEyigngr6UWbHsPVEkFMACgjwxok32x5oCHAOcAz4Afwv/+g9KTf+iiAYfw763X6ZOf/En0JBHsDvxNar1KL4LpHUDwGQFhl4HpOUgicJ63IJXhvwZ/Af/wApi0GuC5u3zBYDRu2Ip+lT9Eam2kPZABqDfARagK0yKgFvBKGBw45S2ABqgF+ArsSPtPA/aeJ/SOxx+zzJPTX5O/zEL0qCoYUA8AJPz2jKvAE3BZ+U9GLcBEAwr4BQO2ai3PFP0pfsr7GTTTIL+U18IGSyA2oJscAAeawZIU0AA6oE3gjLcASPFX2QBKNwDyU779hjRNtMbtoBl8W15pURSC5kMw5a+wPAfsA0kXOMtbQJIAsH9X/iOcAFr9bHT/p/q/T1LQ+mkGzBZKYJGamUEGsCoXbwPeBa/mFQB8LOcf/k0BjDaiA+wYlKZg/EQc4D0wSwAF+pm4EUT3wQtJD/zCCgj4UHr9L+Sf8Vf84+DPU/BoxvlZAbUO+FTgRfInJsAjYFehT94DvqQJ8Bvw3wRgt8XtP07RgkfbWQ+o7/9TYcfS13oNQNflHij/ASY2wL4ErtV/Tk9NDP8Y6WmB6w9v5/7aZhWHccVLRUHw9kO80L6hBrUaFdu1IJIpFBWVjnlBNm84UFj7SyeSiSjiYMY1TROb1Rrb+a/6fO/n5OStlzmfc96TqKB8nvOc75t0fb/uugHCXxqwsgITlB8GLKQGyGeB2+kmcMX41QDAWw2o/wJEwzX+3/jjpgBdTwPgDjj9wgpdC4nKCNBt4D4yQB8C0gAI/od/9xNAfwq/gesWKkLQdwPK/cfmqwF+BiIDbsA9dBcUA74W0W8Bx03wHP8haNCX+CU/1LDl1pgRGRiGAWGBJUCO/0qRgNSAO+ibABug+MiAHgDAn9Pb4GufFviJAetJ8Ws0MCG8ykL8eMF0W+LdTchq4dJ8+V1Y+FV/4QDdBx9OA8APAcCANAEn7v/O6qCyO5/BhwfhREhcMldkoVVl/ya3q0ZxCGBAyY+L+c2BxbIKmAF3SgL8CEBUACQBmPJnwHUGrA9Wj1rOX6/woRRnRC4FFvoiKeGIWFANHp97wmuACehMD15e8bIYEVjIDKCvQ5spP+DVAZZwY62vf50jfAgU/H+rR8MHUUQk3pcpeey5ucfnm6gDVgLiLuDxx8KvZkFEIAy4UhoAAV62/1x5/EP08be1c/ry4VLKfxNW8PAJYbUhHmPVAzLC5wAUYHXA9z9LANAJfsUPwfSNEF+GcwPUAvsNKFx5BBw/7v8j/F7A0ahxSxVumCWtuWcff/wX+TxA/O5A3AMF/+zK4uLiAl2lAfRJ6Hbm31b+LAEYLDhQ//kPWzGBAwhBQ1Vh3ALlh2T0Ir4MLTT1MyGdgcCPMwB8SgBbIJpfCAfEgLskALkD51LVff6dMD/UPoIB72YhqGzcGk/25ujPx1/Ys/vhr/4T0eC3/OPiCNghyMvg3TCABH6W8tMw5fQhFH+Iq99Qfkv+aMnRQ5kL/40T7fHTT9OPRHb9dtiYyz8IMz+T8/678kMgn4XvKxMAJftPi+OHdpwfOgQ/6XD9nyWg+jf4o5f4h+PPzi833IHWgpVA49ftF3otA5KBLAH3sAHcAKLmBOh9cHVaI+eHmjv6sNQfg8bfS0BF17+pGvizUv4Twpde6jcgc+C3tARqAII+IpA6IF8GHrqyLQG4RgZcKwwA+rnVkn9g/KIxJ+Aq5h+jEjB/X2H6q6sqnJo2ibQ/x78wSgn4pQFFBnbjBKQF0Oj51TKQnIE71AAE4Bqkz0GeS7U6S0eV8psm9tTwVbMAqipQJJxVAR//sFT5T/aP6bdm5bfl5lFwzAIpA8oPxR3wrPJHAEoD9FPANrUB0Mdf/9qAVsJfEefQ+cmCwbpsoe8l1KgdVb7/9jqVpHb/+BV/au7p568rv2fgkyIB2H58CMglBsQZeOC2R7a3v6bhDQC+pcc/DZ7GDI2dvzIdMj+m6HCdmTENqWI1Sn76R+EVzdw8qTLjr754RQzgBMwbfzhwPSkBtv8YZ/MUBD8bcC++DcMBiA3Qh4Czp0ASnaYJHQl/YOGltcMlIDQZVaVKfD/qNf+sIu0fywPEkYB+o3TgQAJg9DQXCZ9nmQAzYBuKBMgRwLAEkPhXYMsDQPgdQ+sMQB/axPjjcFjNNCETg2besOL90vgrbx9iCThopEoOARng4v3HsqYGlA7AgIe3SVkCsodAcGHRAOA6LQdA8t9JHGh1we0maC8l8uCmtDQ6juZB4IfIgOfyEumHIBKAIfSsxVBUwdSAa6IIAMZlOMD0wh9//l15AXB1MAaCHxG4aQ+G4+Op/jF6BAZWHXMHGqeSACySBSaEYHFN+HMD7mcDwgHgk/ghQMxVnr77GPCg7/wdF3nQ+i7n36Srt0nXZPyPTVgfHbzCjbSCP4rgEqHzCcnLwJ4bcJYdCBVVoM4APgTpU5CrMiIBkzgAUxok+GDH2sPa6232oC8ng/56x+NCk18wptUajo5/zvvnZQY8NeDsRQbiEPwaCWDsMGCtPANhwJUsAcYfFjA6Llar4De1uoGP2SP+ngzVxmQwHu4JepCHBet7o8HxV9FFL+2gZPzQvvB7qQwH3vA/EWD4OABra2vGv5hEAAZYR1Cit88BKb/8Dnzo0G4AnVKDogTABKX/HtfHNKA/fj8eDMaj/lA1Go3Gg4Pjr37+hhT4ZgDRYxr/XFXIHdjVBOQG0H1gdgQehAHKzxZwAtAR4TKG7b+hFwGojcDFi3QEeoSf6PuP2QLT24UMXy3w+Pv+awnsn2DAshhAnwCNXSZCMIOfDLBOmJQAa4AC/EhAxn/o/O1Ou8LAmzbT03oI9ovE30PrPNl6WuWd49fzg90TMLsCQr9Xs+QRKBIAer0TrpU3QjJAdJWWd6+GBSKCvlwGoGLkSoa+wJGh8GNhD1gRAOd/GwMz7aaZN1HEDE3tPwegPgPLOf8aLxBlwBQ1gBNwRR24ui3faC/RCAMu1wQAvApu/LBkQvS9q9h/zICP/e+FBbVNJIHPY2b+6R5Y60BEIHZfBimNwDxLDJBWoIQfjcDCAFYZAMaFBRBeXCPuGMcuyBL0zi5DE1AG4BvwJyr4B3zjqD8Eb2QBcC3yIppRBNmAbWXHoFczoAxARfD5YFXt1jvcMi/1gLUlAQhFAj7AAH/gSw/N8vzrs7P79B/CVBPKCPxKd0HbfSxYhd8DYA5EDUAb3DwCl1j+FLhpzwNQNw63ROQDzd4WsW9R+Le8i2YeAOCHyu0Peub/ndmxYC0MKCKwFlqUmUcABoBd+DEUXgZagAh86Ogv+dtDghcLMHHBAtHHNQFI+YV+6vNPdA+iHwbucgBUFc8iAil/fgoEPz0Dt20CHxc74Am4JNJH4N2GvhiAA1DvwA3BReM4lXXQpGGNdL9R/g+ijfJ7mNQ6EtPw38puf/rY4HrHpZ+k4zSoAb/FCWAFf/HTcTJAxQmwCHAbGEt/xKAVARCV/O3B1iXtm8aDuUWgtz66eAd4lrDTOqODquHHc7NzgR8hYCOiDDbOiAPBHg6o0gSorl2UBOgRgLgPSvTC8BIIzELE7mfgyxB7AAEdF1ags6SJLhblx+4zPhbb/ah+SeeIUadUJS5EBH6RBET+g39NzsDMBFgAQI+pNSBNwBAGcABO1A3tmCZT36cNVGX7pYsqVuw87T6GKGue7Pj22CyfgOXCAjsHEoEn9QyclIAFws8NoI9wYFd8PgTY+HgQ/sgrwIkaaLswdwGDuscx/Abv/gZetI3qD8Q+pS8Kfn9car5zkjwCp+pPwJmpM2AGXNzkLsCMbl2gTuc6tACcrCHgIfZAV+Br21S84JXpOQCEX9KXN3/rm/YLth+jTnYjuA7+mRYY/mKSABPzwwFeoK4UAH8I/vSeBeBkLd0g5ugXt4GZigygBrLcQRfCEvQqo4/tBzxpn+CX/zICT+oRKFR+I8wNIHShNwNCN+gERADqNbFOYRs09B2odUA/hNA41fQ5FLufGhB9k5YhOIBFFYaUZ6CsARhn3ADmLwzASPvA8QOgch/ACZAANNsna8z7XvQM8wQAO/idniX4UIb/jPVMeP5gWdShJSwIWRncXVH8+gjUJwBL1yXwmN1+BKDZbLoNpR3DIM+lm7+B6dvPw/QK0ef4WdeMZ0cM7+Io8BQrIgL7HoAyA6xIgP9PQDQBOb/gd2m2ogQ2obbMWboB/lLaM9Kap85QRp+dfusatW/obYxUHgM1oJEa8NOpIgJRBMwALYKSgK5Z8F0XDSCIf6c7kXsA6Bkdrzwg+2v7G83JLAMYH9d5mucz8NdJSm+KtnFp07A2sDEz+igLePEIvJwYcIouT8BaGPBqHIHvv/cEcACC/zSaP5AHh3YCmq62v9FVPRioAdErbQML6FneNvPzaBj3OVuAMdU3L7afdUAGGH+YkBYGM+B68Bt+fQLAbwZsSRvkpA0i8PFmpztMDGjxJYo3bfOgnwbg/eiWF/xZx7hQ0TVPy9+zqnHbIqBrqU5SBDj+GKd4YBJ+/oXwVTaA6MEvBmCgD3TCT+pGCWDUFkYTSzN945HYMwNAThbU8efw2e7nj4pbw4hhWxyIWQiHgA1YFgNAjxIARQL0ThgJQP2LAACfZAFwdW9wCaAAKG2bkf1Nlof3s0Zx3CMt2gWGMv5i+5P8m/baoghBfQTezIpgODD9o+HbLAAia4E/ZUCXamBWAmACLfEGw4LRnBC/4bPOswPWLC3k/KqsZ3RC/wIvhg9ZNaw1YPes4WsEwoLFMzgBJE1AHgHgk7L9RzUcSwngAADWlnhDabAwDBhfQ+AKenlFuyzf/Y+KpqnJ8beuYXOC7/zt2QZUXgVB/9MFOgai9PtA1ACgO34YAH2XaagnQHMur0quPkQ0xnoEYv9d2fZ/hvGRbD8cyPsFPa8GRL8U3ARSGXvpgFZBLv8/Af+C8mMm9wFLgP0/0KIGCH83d2A9NcAy0G61gj0OQrMv/FCQJx5oqzjGJ2UtI/OekYGPazfD57W+CCxLAuQEYLK8CCxEDQD7j/z/gepFDehSAMKALzHTEtDiBRJm5EFccO2l6T+fROAzDFpMH5mYvrz7RQBIfYMPE06ognoXvIBTAAOsDJgFkQDQs3oegUv6Ew2z4B28Wg0U7ta0mjKhFg8+Alz04AIug5c3oeAvm0VBwu7aF+bEAMzaIvAyGwD8C6gDloDAx7QEkAW9qIGQFoF3MCBaJlwDEQADTlV68ZLy57LNLwPwjPLnx3/agCfkkza4m/CB8We5oAbsEi1t/wWWOHBGIpAmwALQI36rAdEF/Ttc8OLQSkAddf76uycA+x/4uGp3vwyApd/VbsZXEFyqMgKZAT8RPE0xgEKgRSASoAbo7osB0Qedf7A1Lgw4UQfgB75l4LzhY6mPv/PXBOBPys7tJ64qjOJVY+o16otaK6WFTlERtQwYLV7SWJSi9mKaEqMSY2PFxAhJDYmmCY0vjQmUFgpIGv9X13fba1/mUF3nMjNeHtZvr+/bew4zZ05n7zfUPpJgAHBUTQAA9g2A2g//ECNQ9AD84Q4BoH+zT607gHLYubcAvhGx/X19YPm/kRNQ++XNchTAYZgPBraLvBJaANspAAUA+oc8Af4roLD/Hey3AJCAu+yBjHq37lysekBjH3t9u9Dy6ke4p3Z98CF95hSsIPIIGIBNser+CeC9S7EWZBOEDIAiwDXsFsCXm0fZA0dqBu3L+/5zCSkAHf0/3BfrX+w2AxLAqwagfvuN3aVdseyCPQJQBK5LeRMggLAfBVADmCWAjhZY1MM9vfIBVfa7OyAXQGo/BO/Y7bSlrtkICAMTgxAoAUx5CwgxA5dsKsxXghoAQ2B/zviy0qkAMO6m47GVA2j8d9qvbhfIBhjD/6oR2PJBj4dWU+CA08cG4PZtBMAInM8jcMmaABPACoD8V4CqAPx0AgB8EhhX/wcjWJcSeLh/I9B2ALNf3Tb8nY1klEGILBBJmgePZAF4FwhwSgAMgQGIFui/gxkFcLFsgkcdQG573DcRwRiA2v/XrX+6L94BVDeLo38DwPQz/ykAdo6FwG0oCJzHFgnQErAm4CVAAvUc+AkBaAnQN7aSBB7IYN1KwGe/cv3TUf8QO6DK218OYBI7VtqtyIEA3rtd9QACYA0gARAB6CSAv+PE7+Bgkxc/YSXcJIAswreDCADyxj/sU+0CMJTyT/sh4SAAaJePVAmAywCM/3lNACcCJiD3f/UX7QDZj+B4EpAAWQeN0HWbfr4MAHrhQ+wPaAAIvqu2b3eNHwgABCwEB4oJYAWgBbAJQHFJgAAgAIB9yAPwSYw/fhjNALxVuBwPGhx6fSQAqBn/jgCw/ov7hVKeAEyzxiFYtBHwpSAAsAMsnIfePZ+KQNyzBByBfHIBCWAAZPcewJWwe20fWAcG4GtV2f6prvzTfwtA7E8yBrKJ+LwBcNsBuOqJkADcPpTG3xKAXQGcUAAjZpGO/RgnCW+Ct3j1uwHQ+m8ngMEAJjH+CiEYpCBMYVMSUEyDt6Hcv7QC1oBfGQUAlSZAFQFQAgmALITYAzzu6jpynyOxEuj2X8e/vQRG+9TWJCKgG62ThR1AEQmYUvtOQErAqiAmQlUA+O7PlIAvr8YvAToDfUkAYrgoBI5/Vg73fgj7GYAu+yUA+m8BjFgGJsM2/WevIwGT6Y3AwoIQWDD/DqA7ARfhHs4pDcSmLYQ8ADb8yXdwYCDu4zcTTZ3pZ/7pvqMBMgGSgawR1idsLIFeJADOPQIkwIVA3QMuQjQvIdBF4d1YCI0PlFKxklDdAQBXd/dvABT+W+1OZjVg403/bAUBYCI6wAISgF3l/knAAXzBACQCFAisE0AHAT9qAB3L/3r9f/AEcEbPhydDWQ8clIApBbBtABauLUBKwWUEmADYVwCeAGw1AawM70cJjB8gMvgnADSrX9rv/hsA1PiHjk+SgJ1om3tKwH4AUPO0XyyFDIB8aNsB+Md46h/Du3iHCXiICOAz/dtf4/+Njvybe78CMFCTpQrjLAdbCuOiqANwkQEAMAIOQBPgAZAdrulf9Pf/A/BAAUDff1b6by+A0j8vgZQ/GwRZCibC+Sk7Ff75xAFsGQAYN7EPFguBQ2JfE/AFe4CcywT0/x8A/9yLMChXfy0Be/9XNEDaD9nL7SoAZRTSamDqhALYM//UiiNgDRgAIyD+2QPgWa1/YwHAyS+K/jcAQwDQ2Dfntf0k1n81+kSwU/g/hd02YpAtAGgASGBGM0ACJ50AAMSXtwyAC97FNwCYTuHd0H8GsH4FAExE0LZ/Eujof/QPGASQE4CMgrrXScAATBYAVlZWFlayubBNgAKIDHyDDQhkj5LAPJgAzGIL8SmFhSABcPrj5f9m+neJ/ToAlK2EOO7MgO9WAX5ZfKL2D5UALnkCYN0Q6KeXmQB7MBgxDWAtHI5BgU8rGHcSgG8/o30TAYgq+1Az/ARwuAnAIs6LiiBqIS0D9mMdCPtQICCAVAL86pKNPzzrZntoNwDAprknB4ehe8yC6ccim+7XPfxtB3zffj3MAQxn7rFxl5eL+jDCSSBLQALANhgAmICrmoCLkQEyMApfcxowl7O+EQifPUgVQP/Mf+X/7e7xf18kZ0cwAY9BgBDUvQeAPXAlJgECUARG4JITAACzbwREt2j+Gyh9tvWUTwNhk5sT4bOJK1ECY5qAdvLDHwAPan+8YbwpUrCPuOf2Pfl8IAB9M0z/LIK6DQKAILiqBYAIQBeVgQkUzP8tdkFGnb6LBKwTAET7B+XflLm38FNCYMesLqpVL/5F1gF29kADEPYZAb84RgAYf5N/iUPk/kkA/0y64MAEBASe7l+hf89+2/1oH2rLP90pNSewt7iItEvgZefQZ/UQPXAD9nMA56ILtAlIkgiYxDalAK72y2kg3OuZu/dAyD/8WF/9MP9R/V0XwCL/xyCc5VESMLy4CN8CYbFYCSAU8Sp64N5NAqCsDbIJEMBVScCtIPDND5n/H6QAQOCEdUF3HxD4klkYg/8PLQBV/Pl7ad3tjw0Q1pMsA5uIgMVeQHj64yQNIiYBtgAZfQgR4ExQJuDHmAR/D/8/AMDXsI5DdQsqm8BsBoGjP4vn0N0rP1zvAJB//rWq/9q/D3yJYGdRA6BFQAQ4DAqqw9eB2zdvOgDaZxvkRIhZIH2DXwBcDQBqHwDkQ+14eatqAux4DkMeoyruXZHvPjT+Ofqmjukv818A0G6wtQi5ddusF0QJsAUIgN8WFi7D/+VzJgVAAiyBHxUAhC+xiX3oa0oIQLdujflKQEfa7OLsDyZ7+s91AOB3Pvlzye34w34NoMh/HYFhA5AlINci3wuvSAAuw6xavywQuBpSRQ2kBEBXDEBFwPxDm/F+aLZS9Q/GrqMC1H85/cvsb+IHAAavf2m/JiBNQCGkEOQCAJsEewjAb7/BrJnvigAB/GgA4B87ARQJuJJqYPZArV/h9/7Ki99F+Lv6P/PfyJoACGBzAhoFChVgV4MUwOWFc3kCCCDvglYC9vVtVdgnANMVqwFrAgdplwD40Q8r/3b51z3/txIoux4AJyDmmQMCmJcOIC0gEsAIdCQgKoAEKgTy71gDB+nBdQAI/wMXPzg6/LP+g8AHVQSG1HwhEoirQRPWAi+7dSCYd//QIABMQADABU07cF1HauCK6B/OA93avp4BUO+Mfzn8fPvf+C9/MosEpAag8aIERJYDzgEggArA6HsC5ueFQQ3gkpeABYA1AMG3CQwSgbETnAc6db8JAPx31L/5J4D2F7Owf6B7ENhdXI0aoGI6iFXQ8s2b6AAWgJ9//lnME4AsB2dAIAHgFEAAMvCZtAag+1kbHJqNkz1hBbADMP3038a/+c28LAAiQ+A6OYQA6E6ldsBV0E34dwDnfsY+D5UJIACMf7QABqCS18CDsg3SOp9uf84AtG/9Wf2dy1/aJwArgyX9RzuWgGBAZS0QBcAEmOa1CLgaJIDnpQIaAESQA0AblIsCCmBIdhxVCHZRAc0X/zn3t/5pnwBY/5SHYGlvFd5Xx3GulFpgb1n9MwHz2ByASv5UEE3gSQCA8hJoAwAedRuEX9mwk4OeL6QAcPFL/53tn+Xf/lwOtXRsaenY0CrMrzYBKFrgbxEAAHCxCvQieQ0ACFoAlMZCIxAXxmAWMgi26b6OALADDux+NN+Mfwtg2o5pOS19sCQENlYXJQBCYRxHHYC2BcpG/wAww2mAAH7EDVxMrICKwHX8S74jUvtGQU/2uGsdkA2g6f2mgf4ZfwKgLANLSydXxb0icK0yAEckADmAeSAY/Xl+dHQeGEAgpoEZAuDd+zgJmMZ0U5l/SC4NTr1lAKA5bFAg2GYHzH4pPgfQ7d9U268QLEF3hYDEQM84VGkOFP/RAuAeCEZFFoEVAgABA0D7SuB6IkBhVJ3A53xDEO5xThzuMwCsfyn+7sVPs/4hgHBPLQEB2qAZt14gT4sAWAVAmP7UPgDMWwAsAjPoAYMAMAFyPSdCQAKobgD4/FTeBeYm5Mws9BmA8meyu6/9Mv7Y2vy3CDQClKcgOgADwP4HBCKLwLmVmRn41xKAagDXr4v9H+ifGbgO4T+qIgACc1b+eHaP/r0B9Duq//jx3b29rQ3X1tbe7u7Jevw7tLS0tVqrXAWrfxDwBojxH5UT2yAQeAIA4CUCAIG4i4td0cIhAocPIQGACMhaYMojMJtvCADv/RwNsF+O/tnDexs769tzcz3ss3Ozs71eb67nmri7v7G1d9KHv5vAV0MNgHoKgHTw//jj5z/EvkkJlACePfQiAcBeBkCMi+xRCWgE/knLQe99OGy/92EA8G//FZd9Tx/eugfnFKzDf6vt/Y29k5n/r3yjNjoDsMUASP/D4dZ187dE8L+gNfBuDYD+FQAFACIAgPCJMSwHIwLY49QvCiCb/mB+Y108z85RcC8HznKarSns7M1U3gPBUh0BaYHWAbeXAcD9ewJGM/lEcE67gDVBAjAFgBh9NaQA2AX6fFPIVQB0j/6L/nd4C+aH5nDImbI60ANnIWHexzMI9jsB78ntIBSHI9gYGICjR+ZTAMy9A/jDMyAR0HkA8hpoAfBWPpWI4D5XQ2HfA8AGEPYPb2yrb84Vg4UE0D61ub/1VRIQrE1Pr2F7b2i1h83EKXBf/AcAcc8AsAewBgzAM4MT4IIfJMDkAIBgln3QNJsFIC0AZOw3hyhNQKeQAOy0nzHYyxHkXaBXd8AiAAEAR0wDo04AALwHPAUA3QF4DTsJMAP6tnhqBATEu6tv/tP4n76zTt+y6Qs9wEF3ymqgS5sbM04AhbAm29pmr0f/fBvMDugRGC2lBGYgJAD+HQAJ0L8BoMoQ3GMRRATuZP4BYHhjk0tlWlcNToBs3WIMtAzW9no9+JejLgB2gI/U8kfYmAFNgAFgAtoCaP2/FgCMgRSBL4dMd/u5/8M++LZYnMAc4SMvmxKoO0Iv2mGrcY/BltmXA7rbE/vw3xQAhNH34Q8IKkUQACwCLxx6rADQjP8b2AZk4AFmgqIN7Ga3voV996fmITzB5gFozBMC9v+AQLWwqgQ4A9QFAOno0zwToDpfAWAHoH1jADkDpuC+LYcmT42rn/X0ZwCzPzE0MTE3IeM/FAlQFHje0Q57B9dAi2CjVyyBdqIAIPP/EQBg8HE4BJ8Iw78n4Onk/y8HkI9/CEFgBlRlG+hH/mHf/NuwT5hvP+P1rGxFAyyrgHXQhSAAXNssGsAyAfj4W/0rAPq3ElhRAJcA4IkcQBMAOKI0AmRwIbUBZOCON4Bhs2+b7ZZ+tS4IojOoPAqMAHUgguXltbXltT3xHw1gYbnugBp/kXIoegCnAQB4XAG0/nlVX8o6EMSyEEIbCALb9n/079O+JgCGgwIeZnFoEeCZcTAKZp8xEM2lbYD2Z0AACHbYAOfNPwNgBFQMQERgRmQA8IuT1RTY3tFMKbiiDwiDf45GI3yg/8edTfiESWfAk21zeCHuxbofegox/Q+Pwsay6NpQrAD22gIQ53pAZQKg6AHvAsAjBuAvCwCcVffzAwA7vBUIAYdw3wiM3Jf/48G62mUGsFebw4nh50YRgQWguw6EwF40wOXlpgN+hD2pXg3PpB7wCACwA0QA2m+0GYiog9A9JTBhw+9Df5D/WS8FeXAIOLI2kFrhw7V/DgT24Z8NkAGAfScw+qluXAxFBM5bCTx66FB0AAIob2lH4ZUAyBisg8DsAxl+eJMAQAGAIEjATt4WsUwwAL6r/VxD2LpgrC4O7YFATyeAfAnkAXD/nz4sAfjl6efVP0qAARCTvKOHHZoCy4ApCNwZe+3OOBZEUuO5e7LgFv9SW4IslHxlyNWwusauh51b+QIIyZ8/cXQbHGL86d/cf4qdTcACQAD469hhBUD/TQN4G7uLCAKAzAnj98b66/q+CBkwhVUcAaKgwDYJ/xMegCHPPk5BQFh0MPAF0OL88sYkht8bAN8FswF4GTADBiBWgs8CwIuSgDoAF/hnvVJMgan/2oNTRz5GJ5QMBAKPerite0L+JNogACgFaM4QYPNz63/SF0AnNpZXNP91AXgEIgHsAZn/GQfwDOyLCKD5Rnsfx5v9Nx1AMHAMm9oJfUU0MUiKoc5BahMiWw9g/MM23aeaoLJLIJPivl4BRP1bDbgGJ+ApAHjMAOQVcKFw3+/DPvwrAgj+k4TVuhPA+4JeTYBloQeHPxBwGvAnZp/55+7SN4Dx5cibzD9nAI4/xCbAJsgEvAAAT5ctEPYvXKhuakf12QsoJfAxCIw7gQ4KEgI9kwMB6FP4rHoAdxzuf4T+1T6U/EM+/h0AoCwBTwDA46kCxkiAf9fq93lbU1EiIIj881/3lMAUvrTERtApLpZqyehDDEC9M/42/6t7jn8RAHOvJ9GgaVAWggDwCAFAN8bMfwqAePfd1Q8ElN1sDgQYgg6xIKAKQk8OH+0O+/SP26aGfwLIGgBkCEaRAUlAaoPwr8KXBrAQ1HmQADwAr1+wHoDh7wsBV98gvF0ikGXC7sgrbAQMQZc4TRICJV47hz/8H9li/MM/J0DzzgQwAkUCsAyAXkpzwI0bYzcUQPhPACimoNDwSDQChGBubuI/qiVA89Uew/+xtf9RWC/8Q3kDZAKcQMcyAHrG/EM3UAL0/7oCoP1Xcwb9AgEycdpuOfifQ8CVUgXAoEQK2uG39neO7lXW/4IAAwDVACDxLwSeUgBPGwD6B4BIAOwXt7QqYoB/r977ViobJ17xXkgEne5dRFCItln9kxz+Izs+9ysA5p/+KSTAFoOpBUCcBESPA0D4v3Ej9w8ZANinLAtWCYDAzz9YGWgIJlcflgJeLxgsdU77HH6Jf9b96wUQ/ZcJ4CwQ7wRsEoAeZQLgvwTA73O3CMCm1s5RD8EIPrrYe3gh2DujLgA+J9C+3yz0Zlv+HH8CSHXQtIB4M/juo4dUzzMBJQBIC6BVtIRwjif64riEIBCsdiLg+6LODEz0aF/Tj7WPDv8e3/wX/jkD0L7tQDA4AeiB3gXZA9S/SyqbAajFnqhh0CfQzgmpgxNThmCcDLpAdKqnMvueflQ/F38Hjz81ygAUk6D2wOiCat9LAHL/TuDVbhUTpJ2P4/MDCQFjcPCaqB1/iOGP9E+M3hTV/q3+sdF+XQFcCfN6kLSAaAK6ChAGuX8I7gv/ZwZBwFbd/rVGAAZD/y8D7r6w38OFwNY/pP47AuAI0iTAOUDWga4X473wjQrAoI+0d3EwCHbecgSYEYzBuNTzAf2gY/BpH5e+9VJw65/V32m/bYKoAGkBoccsAfks2DcCdQCwq/AwgACzQASIgc4JqwhCXQ3F2yJ96BXuZeL30Yd9UVf+OxoAFwJ5ACIBL4R/rAQ8AFAEIAHgLR2S3vfHzqZABGRgEExptDkJ0rslfyT/0Zwhs88CoP9y/EeTCKCzB6ICQi/pm+G2BACAovX3/c4Gorocompw3poAApsVjYFBSBgoeod5uLfoq32v/RoA819eAoFz3UzpzUC9DJRFwJNqnTUwFj0AcgD1dzrju/xJXUGIyjl5V2MABg4BFBSDgaAWoUmId8Y195j49veWkzgDlv1fpGlX/yKF4BNBcTGAq4AnMgCPpiag9rH1X/cA/EoC4fwYDiIIKaMWxta2/14/GACCUQCHWiMq+6kg/obw0N41Mb6Ggx2ge/4f1RM3fc0CYAs8f0krgHqxnAUusAQq/3Rv32tXBl2N8YwyOYlSUAaA4BQcBMWfSUrm4X4H7s15HoBknzMA4x8MrAxsHTRKAvU7QbbBKgEO4NVIwGlYeT99pUFPOGyHoi2KX86TbJvDW6gFhwAKygEkku30o7FmHu6PbG9cW7PBl4d2BoB7VVn/Mf66Q6j/rgDYKogRiGkgawF4058K4PTpVACNLAZymP8ztZTP7samQRAOLlhW2+HcRn5qe2dmbc3th+Lyf9kAIdqPAOR1UAJw/1wE5BEggJgFISQgAHgABgOA2AzkqP0bvuG9nc1xWASIVkfN+9btNZfaX+uYANv6H/UDmz31BAz6qyBbICPgABgBUdh/9fSZM6cVQJcMQRRDq2zy2MUnxu9uTqyOHDmqOjI1NbS5vbOxNbO0tLaG3aXu6V8BVAEY5QogtpgCcOqqgBnOgXkE6N8yEAkwCPxWd5fMXetcdtZPDnGpFc2HmP92BqB/dcwm4C8+yqbAUQaAHaCIwFhFIEsAAnD6YQDS/NAMPHY5+fnYmaX3sZXu12xbSwS0+xX51w7QOf6Q9/7Bw99cDGz1CPxn82DfaiBmAahugh/IaXhwDBwDB9/+6RJ23+AaEUjuVeHfnVf5p//mCmAQ4AJAX5d/EWMAuAYo9Jh3QVXZBdEDAOAs/Wdf7tSzZ8BEwyaOP3zL0Z0A+s8SMNA/lwCcAXyvA8DxtwDwbVCpR58TAFwK9Z1AGYGzdG9nEf+Bq1gu6iv3zvF3BAwACbD7037rn1MACRQtwOy31wLZAes+2DQBSLqg+T8r9ulf86/usctWSQccUsNnjtG9RP8Y7ScItK8EOPzWAJJ9NsBR+rfUKwH3zjVw9akAdsBGz3ApxBqIAIDAaU2Al746H/5gePgDVw1hCf0uhh0vfGua/xrd19N/W//4LrT45x9BiUDEK+H2T8I/AYh/FkBbBDealYC6x24IIJh3Bm4dDMDBGTQQuHX5h6ax5/4h3Boe9pv+d84DYO3N/uSBs8545UXArABoXwLw5KOHOvVIXgNsAgHgrEi8GwMxHgoCpBBn9WxP3L4hYOPHN0AQgOks/V8pghj/azH8Nv7zVgFOADIAFM2XCwDOAN16LACwC8osQAAQnGMXJdfHSaBJgvrFA31XCdDvgDAAX4n929jUv98U7vLlFf82+LwkYBT+1X6a97KCkIMfEM8nQGwsgK424ASgvAaQAQUgXfCsRiAYwDn8Hz+OAximiQAHfIvUvj8WUuc4sLnM/W0WgN8STMcf0gTo+AcB2iaK0RD9138LOLANtF2APUC64FlxDgZmH7ax47BzLSkF2MfRaBoyBmF/TbL/3m3VtaQFIRD2kYBRBCAEAhECq4IMwDz2wv9BDYBtQAi4f9YAS4BtQCnoNGAR8BywKzAK0JId2vH4tVBjoOYh/7XoZRJQ97wlmBYAirr4MlAqAP9ILPZEoB7/J9kAugm8DACpBIiADLIeYC7NOxkcnwYGmCxugkEO04V93XX0Re6e/oXAyoLZRwSg5I8UfOCr3teO/2H6P0BPpwio+f6vv/pKiCEYzsQEZDJz8MqTGaf/TF/F8GsAVOV9oc9FA4BgrBJ983nr/zwvAvwvAkxAMRNk9mUHgW6pZ2NCtfbRAGGfHYD+IQUwLxVg5rDTcoWBX5Mtxp/+H6rHog1eIIHTTQaIQDPQyQD1EF7xorFvAHzscdB/DWAeAEZBwPtbGwX6Z/t3vcsV4H8jwC4A+0bg1wzA8Fmal/NxmQs7ExAg6D//Vvx708i+IIAMAX8fp0oAlAY4eaVvumf8PQD0/38IeBfQUxYBIggI0PFh+m01zYciBCenxbnsMK8A6J8JYASgPAE5DrpX87V95P9/6d/izp+1kRiI4l4vKOvFdvBVKY642ebKI7AEXLm0K5HmvkUI3PeHe9LM5K2klTnsmPz0x06KwHt6M1pIsd3TXysCMcEiAGZqANCDEogOW/z8PHuoH4bh7W2I8g15S7ae/8nkw4CPsxgQjjdLwJlDofyT6H+o6q8/D0xrAPz+WY1AbIMX9A/6CcnxR3wMyuswFQ/5StAPRL95AF1ngxlg7LX0Vb4ZYPf/NQ78kgjIZYgAvGMkjfAZg8CDug8DAj9ggw1T9HXgYgDW+DoKagCYWBCwJAS93Hn0qfzxSv1guQ4ZeDFgASPAEJTkwmWXGUkcCPKB7qMhAQhFAKgfU1C91B2X2EP5Wv79cnEd7acD75oBjMQE1sB/ZMAMqCbA4/iVUwTypQ+YB2gEMgC/qnZA9dTP9ndVGaANGNGCIgVVihgwBKUJwHtsdIAWiAMHyJeN0ifYr6byR3Bl/FkGvAmyDBwnPGfSGYecIawCy4CHAZ4OKAcxAaI+dKAUDvHYOQ6UzssP7JaL23CP9i8CZoBlYKTdkPL3WQXEmTng4xbVez96YAaEhYP8ozkQYepDmOSMlYU//pmVW9xOiypgBhILjvSAHTE3oWTI8TEE0I8ZGDFpAQi3GU2ow9r3PP6badZsBOIA9BtHsq9QGoBRWGA5MCwFYUghIAtiwrwRvPdOIn/TUMPNdfCShQBjzoNYCHlH0L3qgRf5r/pdsVaAKTmAOig0+Vgfc+oPo+A3bvGVdFv2gawOaEJZD7waZcMigwxM4NkRzQEM2mClcNKQJ4mPG+Rjp/yvxq1pgVC3YC/7bDVgowWYZoHXGfGAPmAG+OJUOeyTjpB6KOdrdUfIvwdN91hJAT3IfYDoI2MwfzlMrwa64DPGBFEr/YHSgfcbtL670bTbLAVhJNAEpqFoCLXeCNKCyCy4jA/q3eLONG6tJogBrISUoidgS/uCUvGAPmQ2YIRNpxjjw+dq1/Hs78vStf32iZUwfUC84MM+8YF1gZXfD9hYEIqv8rDpO3d/8WUWOviwfRITFH677ENigzBTEjqJxySrVd/vOtcsvpll41zXtW3b9zAE/FAgXGb+4CgWpGmQNfPYuFI2oAe73a7rnGu+RPc/7NDmX/6EDAkAAAAASUVORK5CYII=", this._readyState = typeof window == "undefined" || typeof document == "undefined" ? kt.Unsupported : kt.NotDetected, this._disconnected = () => {
                const r = this._wallet;
                r && (r.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null, this.emit("error", new T1), this.emit("disconnect"))
            }, this._connecting = !1, this._wallet = null, this._publicKey = null, this._readyState !== kt.Unsupported) {
            const r = n => {
                typeof n.data == "object" && n.data.__glow_loaded && (this._readyState !== kt.Installed && (this._readyState = kt.Installed, this.emit("readyStateChange", this._readyState)), window.removeEventListener("message", r))
            };
            window.addEventListener("message", r), Mh(() => {
                var n;
                return !((n = window.glowSolana) === null || n === void 0) && n.isGlow ? (window.removeEventListener("message", r), this._readyState !== kt.Installed && (this._readyState = kt.Installed, this.emit("readyStateChange", this._readyState)), !0) : !1
            })
        }
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        var e;
        return !!(!((e = this._wallet) === null || e === void 0) && e.isConnected)
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting) return;
            if (this._readyState !== kt.Installed) throw new eu;
            this._connecting = !0;
            const e = window.glowSolana;
            try {
                await e.connect()
            } catch (n) {
                throw n instanceof Fr ? n : new Ra(n == null ? void 0 : n.message, n)
            }
            if (!e.publicKey) throw new Eh;
            let r;
            try {
                r = new bt(e.publicKey.toBytes())
            } catch (n) {
                throw new Nl(n == null ? void 0 : n.message, n)
            }
            e.on("disconnect", this._disconnected), this._wallet = e, this._publicKey = r, this.emit("connect", r)
        } catch (e) {
            throw this.emit("error", e), e
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const e = this._wallet;
        if (e) {
            e.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null;
            try {
                await e.disconnect()
            } catch (r) {
                this.emit("error", new Da(r == null ? void 0 : r.message, r))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(e, r, n) {
        try {
            const i = this._wallet;
            if (i && "signAndSendTransaction" in i && !(n != null && n.signers)) {
                e.feePayer = e.feePayer || this.publicKey || void 0, e.recentBlockhash = e.recentBlockhash || (await r.getRecentBlockhash("finalized")).blockhash;
                const {
                    signature: s
                } = await i.signAndSendTransaction(e, n);
                return s
            }
        } catch (i) {
            throw this.emit("error", i), i
        }
        return await super.sendTransaction(e, r, n)
    }
    async signTransaction(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signTransaction(e) || e
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
    async signAllTransactions(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signAllTransactions(e) || e
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
    async signMessage(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                const {
                    signature: n
                } = await r.signMessage(e);
                return n
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
}
const kI = "Phantom";
class NI extends Tl {
    constructor(e = {}) {
        super(), this.name = kI, this.url = "https://phantom.app", this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjM0IiB3aWR0aD0iMzQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iLjUiIHgyPSIuNSIgeTE9IjAiIHkyPSIxIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiM1MzRiYjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM1NTFiZjkiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9Ii41IiB4Mj0iLjUiIHkxPSIwIiB5Mj0iMSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9Ii44MiIvPjwvbGluZWFyR3JhZGllbnQ+PGNpcmNsZSBjeD0iMTciIGN5PSIxNyIgZmlsbD0idXJsKCNhKSIgcj0iMTciLz48cGF0aCBkPSJtMjkuMTcwMiAxNy4yMDcxaC0yLjk5NjljMC02LjEwNzQtNC45NjgzLTExLjA1ODE3LTExLjA5NzUtMTEuMDU4MTctNi4wNTMyNSAwLTEwLjk3NDYzIDQuODI5NTctMTEuMDk1MDggMTAuODMyMzctLjEyNDYxIDYuMjA1IDUuNzE3NTIgMTEuNTkzMiAxMS45NDUzOCAxMS41OTMyaC43ODM0YzUuNDkwNiAwIDEyLjg0OTctNC4yODI5IDEzLjk5OTUtOS41MDEzLjIxMjMtLjk2MTktLjU1MDItMS44NjYxLTEuNTM4OC0xLjg2NjF6bS0xOC41NDc5LjI3MjFjMCAuODE2Ny0uNjcwMzggMS40ODQ3LTEuNDkwMDEgMS40ODQ3LS44MTk2NCAwLTEuNDg5OTgtLjY2ODMtMS40ODk5OC0xLjQ4NDd2LTIuNDAxOWMwLS44MTY3LjY3MDM0LTEuNDg0NyAxLjQ4OTk4LTEuNDg0Ny44MTk2MyAwIDEuNDkwMDEuNjY4IDEuNDkwMDEgMS40ODQ3em01LjE3MzggMGMwIC44MTY3LS42NzAzIDEuNDg0Ny0xLjQ4OTkgMS40ODQ3LS44MTk3IDAtMS40OS0uNjY4My0xLjQ5LTEuNDg0N3YtMi40MDE5YzAtLjgxNjcuNjcwNi0xLjQ4NDcgMS40OS0xLjQ4NDcuODE5NiAwIDEuNDg5OS42NjggMS40ODk5IDEuNDg0N3oiIGZpbGw9InVybCgjYikiLz48L3N2Zz4K", this._readyState = typeof window == "undefined" || typeof document == "undefined" ? kt.Unsupported : kt.NotDetected, this._disconnected = () => {
            const r = this._wallet;
            r && (r.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null, this.emit("error", new T1), this.emit("disconnect"))
        }, this._connecting = !1, this._wallet = null, this._publicKey = null, this._readyState !== kt.Unsupported && Mh(() => {
            var r;
            return !((r = window.solana) === null || r === void 0) && r.isPhantom ? (this._readyState = kt.Installed, this.emit("readyStateChange", this._readyState), !0) : !1
        })
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        var e;
        return !!(!((e = this._wallet) === null || e === void 0) && e.isConnected)
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting) return;
            if (this._readyState !== kt.Installed) throw new eu;
            this._connecting = !0;
            const e = window.solana;
            if (!e.isConnected) {
                const n = e._handleDisconnect;
                try {
                    await new Promise((i, s) => {
                        const o = () => {
                            e.off("connect", o), i()
                        };
                        e._handleDisconnect = (...a) => (e.off("connect", o), s(new bI), n.apply(e, a)), e.on("connect", o), e.connect().catch(a => {
                            e.off("connect", o), s(a)
                        })
                    })
                } catch (i) {
                    throw i instanceof Fr ? i : new Ra(i == null ? void 0 : i.message, i)
                } finally {
                    e._handleDisconnect = n
                }
            }
            if (!e.publicKey) throw new Eh;
            let r;
            try {
                r = new bt(e.publicKey.toBytes())
            } catch (n) {
                throw new Nl(n == null ? void 0 : n.message, n)
            }
            e.on("disconnect", this._disconnected), this._wallet = e, this._publicKey = r, this.emit("connect", r)
        } catch (e) {
            throw this.emit("error", e), e
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const e = this._wallet;
        if (e) {
            e.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null;
            try {
                await e.disconnect()
            } catch (r) {
                this.emit("error", new Da(r == null ? void 0 : r.message, r))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction(e, r, n) {
        try {
            const i = this._wallet;
            if (i && "signAndSendTransaction" in i && !(n != null && n.signers)) {
                e.feePayer = e.feePayer || this.publicKey || void 0, e.recentBlockhash = e.recentBlockhash || (await r.getRecentBlockhash("finalized")).blockhash;
                const {
                    signature: s
                } = await i.signAndSendTransaction(e, n);
                return s
            }
        } catch (i) {
            throw this.emit("error", i), i
        }
        return await super.sendTransaction(e, r, n)
    }
    async signTransaction(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signTransaction(e) || e
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
    async signAllTransactions(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signAllTransactions(e) || e
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
    async signMessage(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                const {
                    signature: n
                } = await r.signMessage(e);
                return n
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
}
var hf = pl.exports.Buffer;

function TI(t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), r = 0; r < e.length; r++) e[r] = 255;
    for (var n = 0; n < t.length; n++) {
        var i = t.charAt(n),
            s = i.charCodeAt(0);
        if (e[s] !== 255) throw new TypeError(i + " is ambiguous");
        e[s] = n
    }
    var o = t.length,
        a = t.charAt(0),
        c = Math.log(o) / Math.log(256),
        d = Math.log(256) / Math.log(o);

    function y(E) {
        if ((Array.isArray(E) || E instanceof Uint8Array) && (E = hf.from(E)), !hf.isBuffer(E)) throw new TypeError("Expected Buffer");
        if (E.length === 0) return "";
        for (var T = 0, j = 0, V = 0, P = E.length; V !== P && E[V] === 0;) V++, T++;
        for (var O = (P - V) * d + 1 >>> 0, R = new Uint8Array(O); V !== P;) {
            for (var q = E[V], W = 0, Y = O - 1;
                (q !== 0 || W < j) && Y !== -1; Y--, W++) q += 256 * R[Y] >>> 0, R[Y] = q % o >>> 0, q = q / o >>> 0;
            if (q !== 0) throw new Error("Non-zero carry");
            j = W, V++
        }
        for (var G = O - j; G !== O && R[G] === 0;) G++;
        for (var J = a.repeat(T); G < O; ++G) J += t.charAt(R[G]);
        return J
    }

    function I(E) {
        if (typeof E != "string") throw new TypeError("Expected String");
        if (E.length === 0) return hf.alloc(0);
        for (var T = 0, j = 0, V = 0; E[T] === a;) j++, T++;
        for (var P = (E.length - T) * c + 1 >>> 0, O = new Uint8Array(P); E[T];) {
            var R = e[E.charCodeAt(T)];
            if (R === 255) return;
            for (var q = 0, W = P - 1;
                (R !== 0 || q < V) && W !== -1; W--, q++) R += o * O[W] >>> 0, O[W] = R % 256 >>> 0, R = R / 256 >>> 0;
            if (R !== 0) throw new Error("Non-zero carry");
            V = q, T++
        }
        for (var Y = P - V; Y !== P && O[Y] === 0;) Y++;
        var G = hf.allocUnsafe(j + (P - Y));
        G.fill(0, 0, j);
        for (var J = j; Y !== P;) G[J++] = O[Y++];
        return G
    }

    function N(E) {
        var T = I(E);
        if (T) return T;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: y,
        decodeUnsafe: I,
        decode: N
    }
}
var OI = TI,
    RI = OI,
    DI = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
    Au = RI(DI);
const PI = "Slope";
class LI extends Tl {
    constructor(e = {}) {
        super(), this.name = PI, this.url = "https://slope.finance", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiByeD0iNjQiIGZpbGw9IiM2RTY2RkEiLz4KPHBhdGggZD0iTTI3Ljk0NzUgNTIuMTU5Nkw1MS45ODI2IDI4LjA1NzJMNzIuNjA5OCA3LjY1Mzg5QzczLjg3MzQgNi40MDQwMSA3Ni4wMTc4IDcuMjk5MSA3Ni4wMTc4IDkuMDc2NDJMNzYuMDE4NyA1Mi4xNTlMNTEuOTgzNiA3Ni4xMjY4TDI3Ljk0NzUgNTIuMTU5NloiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8zNzk1XzI1NTQzKSIvPgo8cGF0aCBkPSJNMTAwLjA1MyA3NS45OTNMNzYuMDE4IDUxLjk1OEw1MS45ODI5IDc1Ljk5MzFMNTEuOTgyOSAxMTguOTI0QzUxLjk4MjkgMTIwLjcwMyA1NC4xMzEyIDEyMS41OTcgNTUuMzkzNyAxMjAuMzQzTDEwMC4wNTMgNzUuOTkzWiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3OTVfMjU1NDMpIi8+CjxwYXRoIGQ9Ik0yNy45NDcgNTIuMTYwMUg0NC42ODM5QzQ4LjcxNDcgNTIuMTYwMSA1MS45ODIyIDU1LjQyNzYgNTEuOTgyMiA1OS40NTgzVjc2LjEyNjlIMzUuMjQ1M0MzMS4yMTQ2IDc2LjEyNjkgMjcuOTQ3IDcyLjg1OTQgMjcuOTQ3IDY4LjgyODdWNTIuMTYwMVoiIGZpbGw9IiNGMUYwRkYiLz4KPHBhdGggZD0iTTc2LjAxNzggNTIuMTYwMUg5Mi43NTQ3Qzk2Ljc4NTUgNTIuMTYwMSAxMDAuMDUzIDU1LjQyNzYgMTAwLjA1MyA1OS40NTgzVjc2LjEyNjlIODMuMzE2MUM3OS4yODU0IDc2LjEyNjkgNzYuMDE3OCA3Mi44NTk0IDc2LjAxNzggNjguODI4N1Y1Mi4xNjAxWiIgZmlsbD0iI0YxRjBGRiIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzM3OTVfMjU1NDMiIHgxPSI1MS45ODMxIiB5MT0iNy4wNzE1NSIgeDI9IjUxLjk4MzEiIHkyPSI3Ni4xMjY4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNBOEFERkYiLz4KPHN0b3Agb2Zmc2V0PSIwLjY0ODU1NiIgc3RvcC1jb2xvcj0id2hpdGUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3OTVfMjU1NDMiIHgxPSI3Ni4wMTgiIHkxPSI1MS45NTgiIHgyPSI3Ni4wMTgiIHkyPSIxMjAuOTI4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC4yNjA3ODQiIHN0b3AtY29sb3I9IiNCNkJBRkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRTRFMkZGIi8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==", this._readyState = typeof window == "undefined" || typeof document == "undefined" ? kt.Unsupported : kt.NotDetected, this._connecting = !1, this._wallet = null, this._publicKey = null, this._readyState !== kt.Unsupported && Mh(() => typeof window.Slope == "function" || window.slopeApp ? (this._readyState = kt.Installed, this.emit("readyStateChange", this._readyState), !0) : !1)
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting) return;
            if (this._readyState !== kt.Installed || !window.Slope) throw new eu;
            this._connecting = !0;
            const e = new window.Slope;
            let r;
            try {
                ({
                    data: r
                } = await e.connect())
            } catch (i) {
                throw new Ra(i == null ? void 0 : i.message, i)
            }
            if (!r.publicKey) throw new Eh;
            let n;
            try {
                n = new bt(r.publicKey)
            } catch (i) {
                throw new Nl(i == null ? void 0 : i.message, i)
            }
            this._wallet = e, this._publicKey = n, this.emit("connect", n)
        } catch (e) {
            throw this.emit("error", e), e
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const e = this._wallet;
        if (e) {
            this._wallet = null, this._publicKey = null;
            try {
                const {
                    msg: r
                } = await e.disconnect();
                if (r !== "ok") throw new Da(r)
            } catch (r) {
                r instanceof Fr || (r = new Da(r == null ? void 0 : r.message, r)), this.emit("error", r)
            }
        }
        this.emit("disconnect")
    }
    async signTransaction(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                const n = Au.encode(e.serializeMessage()),
                    {
                        msg: i,
                        data: s
                    } = await r.signTransaction(n);
                if (!s.publicKey || !s.signature) throw new Kr(i);
                const o = new bt(s.publicKey),
                    a = Au.decode(s.signature);
                return e.addSignature(o, a), e
            } catch (n) {
                throw n instanceof Fr ? n : new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
    async signAllTransactions(e) {
        var r;
        try {
            const n = this._wallet;
            if (!n) throw new Pr;
            try {
                const i = e.map(d => Au.encode(d.serializeMessage())),
                    {
                        msg: s,
                        data: o
                    } = await n.signAllTransactions(i),
                    a = e.length;
                if (!o.publicKey || ((r = o.signatures) === null || r === void 0 ? void 0 : r.length) !== a) throw new Kr(s);
                const c = new bt(o.publicKey);
                for (let d = 0; d < a; d++) e[d].addSignature(c, Au.decode(o.signatures[d]));
                return e
            } catch (i) {
                throw i instanceof Fr ? i : new Kr(i == null ? void 0 : i.message, i)
            }
        } catch (n) {
            throw this.emit("error", n), n
        }
    }
    async signMessage(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                const n = await r.signMessage(e);
                return Au.decode(n.data.signature)
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
}
const FI = "Solflare";
class UI extends Tl {
    constructor(e = {}) {
        super(), this.name = FI, this.url = "https://solflare.com", this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+", this._readyState = typeof window == "undefined" ? kt.Unsupported : kt.Loadable, this._disconnected = () => {
            const r = this._wallet;
            r && (r.off("disconnect", this._disconnected), this._publicKey = null, this.emit("error", new T1), this.emit("disconnect"))
        }, this._connecting = !1, this._publicKey = null, this._wallet = null, this._config = e, this._readyState !== kt.Unsupported && Mh(() => {
            var r;
            return ((r = window.solflare) === null || r === void 0 ? void 0 : r.isSolflare) || window.SolflareApp ? (this._readyState = kt.Installed, this.emit("readyStateChange", this._readyState), !0) : !1
        })
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        var e;
        return !!(!((e = this._wallet) === null || e === void 0) && e.connected)
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting) return;
            if (this._readyState !== kt.Loadable && this._readyState !== kt.Installed) throw new eu;
            let e;
            try {
                ({
                    default: e
                } = await Vx(() =>
                    import ("./index.9f865c18.js"), []))
            } catch (i) {
                throw new Qx(i == null ? void 0 : i.message, i)
            }
            let r;
            try {
                r = new e({
                    network: this._config.network
                })
            } catch (i) {
                throw new qx(i == null ? void 0 : i.message, i)
            }
            if (this._connecting = !0, !r.connected) try {
                await r.connect()
            } catch (i) {
                throw new Ra(i == null ? void 0 : i.message, i)
            }
            if (!r.publicKey) throw new Ra;
            let n;
            try {
                n = new bt(r.publicKey.toBytes())
            } catch (i) {
                throw new Nl(i == null ? void 0 : i.message, i)
            }
            r.on("disconnect", this._disconnected), this._wallet = r, this._publicKey = n, this.emit("connect", n)
        } catch (e) {
            throw this.emit("error", e), e
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const e = this._wallet;
        if (e) {
            e.off("disconnect", this._disconnected), this._publicKey = null;
            try {
                await e.disconnect()
            } catch (r) {
                this.emit("error", new Da(r == null ? void 0 : r.message, r))
            }
        }
        this.emit("disconnect")
    }
    async signTransaction(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signTransaction(e) || e
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
    async signAllTransactions(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signAllTransactions(e) || e
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
    async signMessage(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signMessage(e, "utf8")
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
}
const zI = "Torus";
class jI extends Tl {
    constructor({
        params: e = {
            showTorusButton: !1
        }
    } = {}) {
        super(), this.name = zI, this.url = "https://tor.us", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMyAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYuNSIgY3k9IjE2IiByPSIxNiIgZmlsbD0iIzAzNjRGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjIxODYgOS40OTIxOUMxMC40NTM5IDkuNDkyMTkgOS44MzM5OCAxMC4xMTIxIDkuODMzOTggMTAuODc2OFYxMi40ODk4QzkuODMzOTggMTMuMjU0NSAxMC40NTM5IDEzLjg3NDQgMTEuMjE4NiAxMy44NzQ0SDEzLjY2ODRWMjIuODk3NkMxMy42Njg0IDIzLjY2MjMgMTQuMjg4MyAyNC4yODIyIDE1LjA1MyAyNC4yODIySDE2LjY2NkMxNy40MzA3IDI0LjI4MjIgMTguMDUwNiAyMy42NjIzIDE4LjA1MDYgMjIuODk3NlYxMi41MDE1QzE4LjA1MDYgMTIuNDk3NiAxOC4wNTA2IDEyLjQ5MzcgMTguMDUwNiAxMi40ODk4VjEwLjg3NjhDMTguMDUwNiAxMC4xMTIxIDE3LjQzMDcgOS40OTIxOSAxNi42NjYgOS40OTIxOUgxNS4wNTNIMTEuMjE4NloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMS4zMzc2IDEzLjg3NDRDMjIuNTQ3NyAxMy44NzQ0IDIzLjUyODcgMTIuODkzNCAyMy41Mjg3IDExLjY4MzNDMjMuNTI4NyAxMC40NzMyIDIyLjU0NzcgOS40OTIxOSAyMS4zMzc2IDkuNDkyMTlDMjAuMTI3NSA5LjQ5MjE5IDE5LjE0NjUgMTAuNDczMiAxOS4xNDY1IDExLjY4MzNDMTkuMTQ2NSAxMi44OTM0IDIwLjEyNzUgMTMuODc0NCAyMS4zMzc2IDEzLjg3NDRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K", this._readyState = typeof window == "undefined" ? kt.Unsupported : kt.Loadable, this._connecting = !1, this._wallet = null, this._publicKey = null, this._params = e
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        var e;
        return !!(!((e = this._wallet) === null || e === void 0) && e.isLoggedIn)
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting) return;
            if (this._readyState !== kt.Loadable) throw new eu;
            this._connecting = !0;
            let e;
            try {
                ({
                    default: e
                } = await Vx(() =>
                    import ("./solanaEmbed.esm.841d0b14.js"), []))
            } catch (s) {
                throw new Qx(s == null ? void 0 : s.message, s)
            }
            let r;
            try {
                r = window.torus || new e
            } catch (s) {
                throw new qx(s == null ? void 0 : s.message, s)
            }
            if (!r.isInitialized) try {
                await r.init(this._params)
            } catch (s) {
                throw new Ra(s == null ? void 0 : s.message, s)
            }
            let n;
            try {
                n = await r.login()
            } catch (s) {
                throw new Eh(s == null ? void 0 : s.message, s)
            }
            let i;
            try {
                i = new bt(n[0])
            } catch (s) {
                throw new Nl(s == null ? void 0 : s.message, s)
            }
            this._wallet = r, this._publicKey = i, this.emit("connect", i)
        } catch (e) {
            throw this.emit("error", e), e
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const e = this._wallet;
        if (e) {
            this._wallet = null, this._publicKey = null;
            try {
                e.isLoggedIn && await e.cleanUp()
            } catch (r) {
                this.emit("error", new Da(r == null ? void 0 : r.message, r))
            }
        }
        this.emit("disconnect")
    }
    async signTransaction(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signTransaction(e) || e
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
    async signAllTransactions(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signAllTransactions(e) || e
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
    async signMessage(e) {
        try {
            const r = this._wallet;
            if (!r) throw new Pr;
            try {
                return await r.signMessage(e)
            } catch (n) {
                throw new Kr(n == null ? void 0 : n.message, n)
            }
        } catch (r) {
            throw this.emit("error", r), r
        }
    }
}
const Gx = {
    setVisible(t) {
        console.error(Yx("call", "setVisible"))
    },
    visible: !1
};
Object.defineProperty(Gx, "visible", {
    get() {
        return console.error(Yx("read", "visible")), !1
    }
});

function Yx(t, e) {
    return `You have tried to  ${t} "${e}" on a WalletModalContext without providing one. Make sure to render a WalletModalProvider as an ancestor of the component that uses WalletModalContext`
}
const Kx = _e.exports.createContext(Gx);

function O1() {
    return _e.exports.useContext(Kx)
}
const Ih = t => Qe.createElement("button", {
        className: `wallet-adapter-button ${t.className||""}`,
        disabled: t.disabled,
        onClick: t.onClick,
        tabIndex: t.tabIndex || 0,
        type: "button"
    }, t.startIcon && Qe.createElement("i", {
        className: "wallet-adapter-button-start-icon"
    }, t.startIcon), t.children, t.endIcon && Qe.createElement("i", {
        className: "wallet-adapter-button-end-icon"
    }, t.endIcon)),
    R1 = r => {
        var n = r,
            {
                wallet: t
            } = n,
            e = Wn(n, ["wallet"]);
        return t && Qe.createElement("img", Ce({
            src: t.adapter.icon,
            alt: `${t.adapter.name} icon`
        }, e))
    },
    $I = i => {
        var s = i,
            {
                children: t,
                disabled: e,
                onClick: r
            } = s,
            n = Wn(s, ["children", "disabled", "onClick"]);
        const {
            wallet: o,
            connect: a,
            connecting: c,
            connected: d
        } = Ol(), y = _e.exports.useCallback(N => {
            r && r(N), N.defaultPrevented || a().catch(() => {})
        }, [r, a]), I = _e.exports.useMemo(() => t || (c ? "Connecting ..." : d ? "Connected" : o ? "Connect" : "Connect Wallet"), [t, c, d, o]);
        return qe(Ih, xt(Ce({
            className: "wallet-adapter-button-trigger",
            disabled: e || !o || c || d,
            startIcon: o ? qe(R1, {
                wallet: o
            }) : void 0,
            onClick: y
        }, n), {
            children: I
        }))
    },
    Yv = ({
        id: t,
        children: e,
        expanded: r = !1
    }) => {
        const n = _e.exports.useRef(null),
            i = _e.exports.useRef(!0),
            s = "height 250ms ease-out",
            o = () => {
                const c = n.current;
                !c || requestAnimationFrame(() => {
                    c.style.height = c.scrollHeight + "px"
                })
            },
            a = () => {
                const c = n.current;
                !c || requestAnimationFrame(() => {
                    c.style.height = c.offsetHeight + "px", c.style.overflow = "hidden", requestAnimationFrame(() => {
                        c.style.height = "0"
                    })
                })
            };
        return _e.exports.useLayoutEffect(() => {
            r ? o() : a()
        }, [r]), _e.exports.useLayoutEffect(() => {
            const c = n.current;
            if (!c) return;

            function d() {
                !c || (c.style.overflow = r ? "initial" : "hidden", r && (c.style.height = "auto"))
            }

            function y(I) {
                c && I.target === c && I.propertyName === "height" && d()
            }
            return i.current && (d(), i.current = !1), c.addEventListener("transitionend", y), () => c.removeEventListener("transitionend", y)
        }, [r]), qe("div", {
            children: e,
            className: "wallet-adapter-collapse",
            id: t,
            ref: n,
            role: "region",
            style: {
                height: 0,
                transition: i.current ? void 0 : s
            }
        })
    },
    T0 = ({
        handleClick: t,
        tabIndex: e,
        wallet: r
    }) => Qe.createElement("li", null, Qe.createElement(Ih, {
        onClick: t,
        startIcon: Qe.createElement(R1, {
            wallet: r
        }),
        tabIndex: e
    }, r.adapter.name, r.readyState === kt.Installed && Qe.createElement("span", null, "Detected"))),
    HI = () => Qe.createElement("svg", {
        width: "97",
        height: "96",
        viewBox: "0 0 97 96",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, Qe.createElement("circle", {
        cx: "48.5",
        cy: "48",
        r: "48",
        fill: "url(#paint0_linear_880_5115)",
        fillOpacity: "0.1"
    }), Qe.createElement("circle", {
        cx: "48.5",
        cy: "48",
        r: "47",
        stroke: "url(#paint1_linear_880_5115)",
        strokeOpacity: "0.4",
        strokeWidth: "2"
    }), Qe.createElement("g", {
        clipPath: "url(#clip0_880_5115)"
    }, Qe.createElement("path", {
        d: "M65.5769 28.1523H31.4231C27.6057 28.1523 24.5 31.258 24.5 35.0754V60.9215C24.5 64.7389 27.6057 67.8446 31.4231 67.8446H65.5769C69.3943 67.8446 72.5 64.7389 72.5 60.9215V35.0754C72.5 31.258 69.3943 28.1523 65.5769 28.1523ZM69.7308 52.1523H59.5769C57.2865 52.1523 55.4231 50.289 55.4231 47.9985C55.4231 45.708 57.2864 43.8446 59.5769 43.8446H69.7308V52.1523ZM69.7308 41.0754H59.5769C55.7595 41.0754 52.6539 44.1811 52.6539 47.9985C52.6539 51.8159 55.7595 54.9215 59.5769 54.9215H69.7308V60.9215C69.7308 63.2119 67.8674 65.0754 65.5769 65.0754H31.4231C29.1327 65.0754 27.2692 63.212 27.2692 60.9215V35.0754C27.2692 32.785 29.1326 30.9215 31.4231 30.9215H65.5769C67.8673 30.9215 69.7308 32.7849 69.7308 35.0754V41.0754Z",
        fill: "url(#paint2_linear_880_5115)"
    }), Qe.createElement("path", {
        d: "M61.4231 46.6172H59.577C58.8123 46.6172 58.1924 47.2371 58.1924 48.0018C58.1924 48.7665 58.8123 49.3863 59.577 49.3863H61.4231C62.1878 49.3863 62.8077 48.7664 62.8077 48.0018C62.8077 47.2371 62.1878 46.6172 61.4231 46.6172Z",
        fill: "url(#paint3_linear_880_5115)"
    })), Qe.createElement("defs", null, Qe.createElement("linearGradient", {
        id: "paint0_linear_880_5115",
        x1: "3.41664",
        y1: "98.0933",
        x2: "103.05",
        y2: "8.42498",
        gradientUnits: "userSpaceOnUse"
    }, Qe.createElement("stop", {
        stopColor: "#9945FF"
    }), Qe.createElement("stop", {
        offset: "0.14",
        stopColor: "#8A53F4"
    }), Qe.createElement("stop", {
        offset: "0.42",
        stopColor: "#6377D6"
    }), Qe.createElement("stop", {
        offset: "0.79",
        stopColor: "#24B0A7"
    }), Qe.createElement("stop", {
        offset: "0.99",
        stopColor: "#00D18C"
    }), Qe.createElement("stop", {
        offset: "1",
        stopColor: "#00D18C"
    })), Qe.createElement("linearGradient", {
        id: "paint1_linear_880_5115",
        x1: "3.41664",
        y1: "98.0933",
        x2: "103.05",
        y2: "8.42498",
        gradientUnits: "userSpaceOnUse"
    }, Qe.createElement("stop", {
        stopColor: "#9945FF"
    }), Qe.createElement("stop", {
        offset: "0.14",
        stopColor: "#8A53F4"
    }), Qe.createElement("stop", {
        offset: "0.42",
        stopColor: "#6377D6"
    }), Qe.createElement("stop", {
        offset: "0.79",
        stopColor: "#24B0A7"
    }), Qe.createElement("stop", {
        offset: "0.99",
        stopColor: "#00D18C"
    }), Qe.createElement("stop", {
        offset: "1",
        stopColor: "#00D18C"
    })), Qe.createElement("linearGradient", {
        id: "paint2_linear_880_5115",
        x1: "25.9583",
        y1: "68.7101",
        x2: "67.2337",
        y2: "23.7879",
        gradientUnits: "userSpaceOnUse"
    }, Qe.createElement("stop", {
        stopColor: "#9945FF"
    }), Qe.createElement("stop", {
        offset: "0.14",
        stopColor: "#8A53F4"
    }), Qe.createElement("stop", {
        offset: "0.42",
        stopColor: "#6377D6"
    }), Qe.createElement("stop", {
        offset: "0.79",
        stopColor: "#24B0A7"
    }), Qe.createElement("stop", {
        offset: "0.99",
        stopColor: "#00D18C"
    }), Qe.createElement("stop", {
        offset: "1",
        stopColor: "#00D18C"
    })), Qe.createElement("linearGradient", {
        id: "paint3_linear_880_5115",
        x1: "58.3326",
        y1: "49.4467",
        x2: "61.0002",
        y2: "45.4453",
        gradientUnits: "userSpaceOnUse"
    }, Qe.createElement("stop", {
        stopColor: "#9945FF"
    }), Qe.createElement("stop", {
        offset: "0.14",
        stopColor: "#8A53F4"
    }), Qe.createElement("stop", {
        offset: "0.42",
        stopColor: "#6377D6"
    }), Qe.createElement("stop", {
        offset: "0.79",
        stopColor: "#24B0A7"
    }), Qe.createElement("stop", {
        offset: "0.99",
        stopColor: "#00D18C"
    }), Qe.createElement("stop", {
        offset: "1",
        stopColor: "#00D18C"
    })), Qe.createElement("clipPath", {
        id: "clip0_880_5115"
    }, Qe.createElement("rect", {
        width: "48",
        height: "48",
        fill: "white",
        transform: "translate(24.5 24)"
    })))),
    QI = ({
        className: t = "",
        container: e = "body"
    }) => {
        const r = _e.exports.useRef(null),
            {
                wallets: n,
                select: i
            } = Ol(),
            {
                setVisible: s
            } = O1(),
            [o, a] = _e.exports.useState(!1),
            [c, d] = _e.exports.useState(!1),
            [y, I] = _e.exports.useState(null),
            [N, E] = _e.exports.useMemo(() => {
                const q = [],
                    W = [],
                    Y = [];
                for (const G of n) G.readyState === kt.NotDetected ? W.push(G) : G.readyState === kt.Loadable ? Y.push(G) : G.readyState === kt.Installed && q.push(G);
                return [q, [...Y, ...W]]
            }, [n]),
            T = _e.exports.useMemo(() => N.length ? N[0] : n.find(q => q.adapter.name === "Torus") || n.find(q => q.adapter.name === "Phantom") || n.find(q => q.readyState === kt.Loadable) || E[0], [N, n, E]),
            j = _e.exports.useCallback(() => {
                d(!1), setTimeout(() => s(!1), 150)
            }, []),
            V = _e.exports.useCallback(q => {
                q.preventDefault(), j()
            }, [j]),
            P = _e.exports.useCallback((q, W) => {
                i(W), V(q)
            }, [i, V]),
            O = _e.exports.useCallback(() => a(!o), [o]),
            R = _e.exports.useCallback(q => {
                const W = r.current;
                if (!W) return;
                const Y = W.querySelectorAll("button"),
                    G = Y[0],
                    J = Y[Y.length - 1];
                q.shiftKey ? document.activeElement === G && (J.focus(), q.preventDefault()) : document.activeElement === J && (G.focus(), q.preventDefault())
            }, [r]);
        return _e.exports.useLayoutEffect(() => {
            const q = Y => {
                    Y.key === "Escape" ? j() : Y.key === "Tab" && R(Y)
                },
                {
                    overflow: W
                } = window.getComputedStyle(document.body);
            return setTimeout(() => d(!0), 0), document.body.style.overflow = "hidden", window.addEventListener("keydown", q, !1), () => {
                document.body.style.overflow = W, window.removeEventListener("keydown", q, !1)
            }
        }, [j, R]), _e.exports.useLayoutEffect(() => I(document.querySelector(e)), [e]), y && Tc.exports.createPortal(vr("div", {
            "aria-labelledby": "wallet-adapter-modal-title",
            "aria-modal": "true",
            className: `wallet-adapter-modal ${c&&"wallet-adapter-modal-fade-in"} ${t}`,
            ref: r,
            role: "dialog",
            children: [qe("div", {
                className: "wallet-adapter-modal-container",
                children: vr("div", {
                    className: "wallet-adapter-modal-wrapper",
                    children: [qe("button", {
                        onClick: V,
                        className: "wallet-adapter-modal-button-close",
                        children: qe("svg", {
                            width: "14",
                            height: "14",
                            children: qe("path", {
                                d: "M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z"
                            })
                        })
                    }), N.length ? vr(N0, {
                        children: [qe("h1", {
                            className: "wallet-adapter-modal-title",
                            children: "Connect a wallet on Solana to continue"
                        }), vr("ul", {
                            className: "wallet-adapter-modal-list",
                            children: [N.map(q => qe(T0, {
                                handleClick: W => P(W, q.adapter.name),
                                wallet: q
                            }, q.adapter.name)), E.length ? qe(Yv, {
                                expanded: o,
                                id: "wallet-adapter-modal-collapse",
                                children: E.map(q => qe(T0, {
                                    handleClick: W => P(W, q.adapter.name),
                                    tabIndex: o ? 0 : -1,
                                    wallet: q
                                }, q.adapter.name))
                            }) : null]
                        }), E.length ? vr("button", {
                            className: "wallet-adapter-modal-list-more",
                            onClick: O,
                            tabIndex: 0,
                            children: [vr("span", {
                                children: [o ? "Less " : "More ", "options"]
                            }), qe("svg", {
                                width: "13",
                                height: "7",
                                viewBox: "0 0 13 7",
                                xmlns: "http://www.w3.org/2000/svg",
                                className: `${o?"wallet-adapter-modal-list-more-icon-rotate":""}`,
                                children: qe("path", {
                                    d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
                                })
                            })]
                        }) : null]
                    }) : vr(N0, {
                        children: [qe("h1", {
                            className: "wallet-adapter-modal-title",
                            children: "You'll need a wallet on Solana to continue"
                        }), vr("div", {
                            className: "wallet-adapter-modal-middle",
                            children: [qe(HI, {}), qe("button", {
                                type: "button",
                                className: "wallet-adapter-modal-middle-button",
                                onClick: q => P(q, T.adapter.name),
                                children: "Get started"
                            })]
                        }), E.length ? vr(N0, {
                            children: [vr("button", {
                                className: "wallet-adapter-modal-list-more",
                                onClick: O,
                                tabIndex: 0,
                                children: [vr("span", {
                                    children: [o ? "Hide " : "Already have a wallet? View ", "options"]
                                }), qe("svg", {
                                    width: "13",
                                    height: "7",
                                    viewBox: "0 0 13 7",
                                    xmlns: "http://www.w3.org/2000/svg",
                                    className: `${o?"wallet-adapter-modal-list-more-icon-rotate":""}`,
                                    children: qe("path", {
                                        d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
                                    })
                                })]
                            }), qe(Yv, {
                                expanded: o,
                                id: "wallet-adapter-modal-collapse",
                                children: qe("ul", {
                                    className: "wallet-adapter-modal-list",
                                    children: E.map(q => qe(T0, {
                                        handleClick: W => P(W, q.adapter.name),
                                        tabIndex: o ? 0 : -1,
                                        wallet: q
                                    }, q.adapter.name))
                                })
                            })]
                        }) : null]
                    })]
                })
            }), qe("div", {
                className: "wallet-adapter-modal-overlay",
                onMouseDown: V
            })]
        }), y)
    },
    qI = n => {
        var i = n,
            {
                children: t = "Select Wallet",
                onClick: e
            } = i,
            r = Wn(i, ["children", "onClick"]);
        const {
            visible: s,
            setVisible: o
        } = O1(), a = _e.exports.useCallback(c => {
            e && e(c), c.defaultPrevented || o(!s)
        }, [e, s]);
        return qe(Ih, xt(Ce({
            className: "wallet-adapter-button-trigger",
            onClick: a
        }, r), {
            children: t
        }))
    },
    WI = r => {
        var n = r,
            {
                children: t
            } = n,
            e = Wn(n, ["children"]);
        const [i, s] = _e.exports.useState(!1);
        return vr(Kx.Provider, {
            value: {
                visible: i,
                setVisible: s
            },
            children: [t, i && qe(QI, Ce({}, e))]
        })
    },
    VI = r => {
        var n = r,
            {
                children: t
            } = n,
            e = Wn(n, ["children"]);
        const {
            publicKey: i,
            wallet: s,
            disconnect: o
        } = Ol(), {
            setVisible: a
        } = O1(), [c, d] = _e.exports.useState(!1), [y, I] = _e.exports.useState(!1), N = _e.exports.useRef(null), E = _e.exports.useMemo(() => i == null ? void 0 : i.toBase58(), [i]), T = _e.exports.useMemo(() => t || (!s || !E ? null : E.slice(0, 4) + ".." + E.slice(-4)), [t, s, E]), j = _e.exports.useCallback(async () => {
            E && (await navigator.clipboard.writeText(E), d(!0), setTimeout(() => d(!1), 400))
        }, [E]), V = _e.exports.useCallback(() => {
            I(!0)
        }, []), P = _e.exports.useCallback(() => {
            I(!1)
        }, []), O = _e.exports.useCallback(() => {
            a(!0), P()
        }, [P]);
        return _e.exports.useEffect(() => {
            const R = q => {
                const W = N.current;
                !W || W.contains(q.target) || P()
            };
            return document.addEventListener("mousedown", R), document.addEventListener("touchstart", R), () => {
                document.removeEventListener("mousedown", R), document.removeEventListener("touchstart", R)
            }
        }, [N, P]), s ? E ? vr("div", {
            className: "wallet-adapter-dropdown",
            children: [qe(Ih, xt(Ce({
                "aria-expanded": y,
                className: "wallet-adapter-button-trigger",
                style: Ce({
                    pointerEvents: y ? "none" : "auto"
                }, e.style),
                onClick: V,
                startIcon: qe(R1, {
                    wallet: s
                })
            }, e), {
                children: T
            })), vr("ul", {
                "aria-label": "dropdown-list",
                className: `wallet-adapter-dropdown-list ${y&&"wallet-adapter-dropdown-list-active"}`,
                ref: N,
                role: "menu",
                children: [qe("li", {
                    onClick: j,
                    className: "wallet-adapter-dropdown-list-item",
                    role: "menuitem",
                    children: c ? "Copied" : "Copy address"
                }), qe("li", {
                    onClick: O,
                    className: "wallet-adapter-dropdown-list-item",
                    role: "menuitem",
                    children: "Change wallet"
                }), qe("li", {
                    onClick: o,
                    className: "wallet-adapter-dropdown-list-item",
                    role: "menuitem",
                    children: "Disconnect"
                })]
            })]
        }) : qe($I, xt(Ce({}, e), {
            children: t
        })) : qe(qI, xt(Ce({}, e), {
            children: t
        }))
    };

function _t() {
    return _t = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
        }
        return t
    }, _t.apply(this, arguments)
}
var xo;
(function(t) {
    t.Pop = "POP", t.Push = "PUSH", t.Replace = "REPLACE"
})(xo || (xo = {}));
var Kv = function(t) {
        return t
    },
    Zv = "beforeunload",
    GI = "popstate";

function YI(t) {
    t === void 0 && (t = {});
    var e = t,
        r = e.window,
        n = r === void 0 ? document.defaultView : r,
        i = n.history;

    function s() {
        var G = n.location,
            J = G.pathname,
            pe = G.search,
            we = G.hash,
            H = i.state || {};
        return [H.idx, Kv({
            pathname: J,
            search: pe,
            hash: we,
            state: H.usr || null,
            key: H.key || "default"
        })]
    }
    var o = null;

    function a() {
        if (o) E.call(o), o = null;
        else {
            var G = xo.Pop,
                J = s(),
                pe = J[0],
                we = J[1];
            if (E.length) {
                if (pe != null) {
                    var H = y - pe;
                    H && (o = {
                        action: G,
                        location: we,
                        retry: function() {
                            W(H * -1)
                        }
                    }, W(H))
                }
            } else O(G)
        }
    }
    n.addEventListener(GI, a);
    var c = xo.Pop,
        d = s(),
        y = d[0],
        I = d[1],
        N = Xv(),
        E = Xv();
    y == null && (y = 0, i.replaceState(_t({}, i.state, {
        idx: y
    }), ""));

    function T(G) {
        return typeof G == "string" ? G : ZI(G)
    }

    function j(G, J) {
        return J === void 0 && (J = null), Kv(_t({
            pathname: I.pathname,
            hash: "",
            search: ""
        }, typeof G == "string" ? Ch(G) : G, {
            state: J,
            key: KI()
        }))
    }

    function V(G, J) {
        return [{
            usr: G.state,
            key: G.key,
            idx: J
        }, T(G)]
    }

    function P(G, J, pe) {
        return !E.length || (E.call({
            action: G,
            location: J,
            retry: pe
        }), !1)
    }

    function O(G) {
        c = G;
        var J = s();
        y = J[0], I = J[1], N.call({
            action: c,
            location: I
        })
    }

    function R(G, J) {
        var pe = xo.Push,
            we = j(G, J);

        function H() {
            R(G, J)
        }
        if (P(pe, we, H)) {
            var w = V(we, y + 1),
                p = w[0],
                f = w[1];
            try {
                i.pushState(p, "", f)
            } catch {
                n.location.assign(f)
            }
            O(pe)
        }
    }

    function q(G, J) {
        var pe = xo.Replace,
            we = j(G, J);

        function H() {
            q(G, J)
        }
        if (P(pe, we, H)) {
            var w = V(we, y),
                p = w[0],
                f = w[1];
            i.replaceState(p, "", f), O(pe)
        }
    }

    function W(G) {
        i.go(G)
    }
    var Y = {
        get action() {
            return c
        },
        get location() {
            return I
        },
        createHref: T,
        push: R,
        replace: q,
        go: W,
        back: function() {
            W(-1)
        },
        forward: function() {
            W(1)
        },
        listen: function(J) {
            return N.push(J)
        },
        block: function(J) {
            var pe = E.push(J);
            return E.length === 1 && n.addEventListener(Zv, Jv),
                function() {
                    pe(), E.length || n.removeEventListener(Zv, Jv)
                }
        }
    };
    return Y
}

function Jv(t) {
    t.preventDefault(), t.returnValue = ""
}

function Xv() {
    var t = [];
    return {
        get length() {
            return t.length
        },
        push: function(r) {
            return t.push(r),
                function() {
                    t = t.filter(function(n) {
                        return n !== r
                    })
                }
        },
        call: function(r) {
            t.forEach(function(n) {
                return n && n(r)
            })
        }
    }
}

function KI() {
    return Math.random().toString(36).substr(2, 8)
}

function ZI(t) {
    var e = t.pathname,
        r = e === void 0 ? "/" : e,
        n = t.search,
        i = n === void 0 ? "" : n,
        s = t.hash,
        o = s === void 0 ? "" : s;
    return i && i !== "?" && (r += i.charAt(0) === "?" ? i : "?" + i), o && o !== "#" && (r += o.charAt(0) === "#" ? o : "#" + o), r
}

function Ch(t) {
    var e = {};
    if (t) {
        var r = t.indexOf("#");
        r >= 0 && (e.hash = t.substr(r), t = t.substr(0, r));
        var n = t.indexOf("?");
        n >= 0 && (e.search = t.substr(n), t = t.substr(0, n)), t && (e.pathname = t)
    }
    return e
}
/**
 * React Router v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const JI = _e.exports.createContext(null),
    D1 = _e.exports.createContext(null),
    Zx = _e.exports.createContext({
        outlet: null,
        matches: []
    });

function no(t, e) {
    if (!t) throw new Error(e)
}

function XI(t, e, r) {
    r === void 0 && (r = "/");
    let n = typeof e == "string" ? Ch(e) : e,
        i = Xx(n.pathname || "/", r);
    if (i == null) return null;
    let s = Jx(t);
    eC(s);
    let o = null;
    for (let a = 0; o == null && a < s.length; ++a) o = lC(s[a], i);
    return o
}

function Jx(t, e, r, n) {
    return e === void 0 && (e = []), r === void 0 && (r = []), n === void 0 && (n = ""), t.forEach((i, s) => {
        let o = {
            relativePath: i.path || "",
            caseSensitive: i.caseSensitive === !0,
            childrenIndex: s,
            route: i
        };
        o.relativePath.startsWith("/") && (o.relativePath.startsWith(n) || no(!1), o.relativePath = o.relativePath.slice(n.length));
        let a = va([n, o.relativePath]),
            c = r.concat(o);
        i.children && i.children.length > 0 && (i.index === !0 && no(!1), Jx(i.children, e, c, a)), !(i.path == null && !i.index) && e.push({
            path: a,
            score: aC(a, i.index),
            routesMeta: c
        })
    }), e
}

function eC(t) {
    t.sort((e, r) => e.score !== r.score ? r.score - e.score : uC(e.routesMeta.map(n => n.childrenIndex), r.routesMeta.map(n => n.childrenIndex)))
}
const tC = /^:\w+$/,
    rC = 3,
    nC = 2,
    iC = 1,
    sC = 10,
    oC = -2,
    eg = t => t === "*";

function aC(t, e) {
    let r = t.split("/"),
        n = r.length;
    return r.some(eg) && (n += oC), e && (n += nC), r.filter(i => !eg(i)).reduce((i, s) => i + (tC.test(s) ? rC : s === "" ? iC : sC), n)
}

function uC(t, e) {
    return t.length === e.length && t.slice(0, -1).every((n, i) => n === e[i]) ? t[t.length - 1] - e[e.length - 1] : 0
}

function lC(t, e) {
    let {
        routesMeta: r
    } = t, n = {}, i = "/", s = [];
    for (let o = 0; o < r.length; ++o) {
        let a = r[o],
            c = o === r.length - 1,
            d = i === "/" ? e : e.slice(i.length) || "/",
            y = fC({
                path: a.relativePath,
                caseSensitive: a.caseSensitive,
                end: c
            }, d);
        if (!y) return null;
        Object.assign(n, y.params);
        let I = a.route;
        s.push({
            params: n,
            pathname: va([i, y.pathname]),
            pathnameBase: e3(va([i, y.pathnameBase])),
            route: I
        }), y.pathnameBase !== "/" && (i = va([i, y.pathnameBase]))
    }
    return s
}

function fC(t, e) {
    typeof t == "string" && (t = {
        path: t,
        caseSensitive: !1,
        end: !0
    });
    let [r, n] = cC(t.path, t.caseSensitive, t.end), i = e.match(r);
    if (!i) return null;
    let s = i[0],
        o = s.replace(/(.)\/+$/, "$1"),
        a = i.slice(1);
    return {
        params: n.reduce((d, y, I) => {
            if (y === "*") {
                let N = a[I] || "";
                o = s.slice(0, s.length - N.length).replace(/(.)\/+$/, "$1")
            }
            return d[y] = hC(a[I] || ""), d
        }, {}),
        pathname: s,
        pathnameBase: o,
        pattern: t
    }
}

function cC(t, e, r) {
    e === void 0 && (e = !1), r === void 0 && (r = !0);
    let n = [],
        i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (o, a) => (n.push(a), "([^\\/]+)"));
    return t.endsWith("*") ? (n.push("*"), i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : i += r ? "\\/*$" : "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)", [new RegExp(i, e ? void 0 : "i"), n]
}

function hC(t, e) {
    try {
        return decodeURIComponent(t)
    } catch {
        return t
    }
}

function Xx(t, e) {
    if (e === "/") return t;
    if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
    let r = t.charAt(e.length);
    return r && r !== "/" ? null : t.slice(e.length) || "/"
}
const va = t => t.join("/").replace(/\/\/+/g, "/"),
    e3 = t => t.replace(/\/+$/, "").replace(/^\/*/, "/");

function P1() {
    return _e.exports.useContext(D1) != null
}

function dC() {
    return P1() || no(!1), _e.exports.useContext(D1).location
}

function pC(t, e) {
    P1() || no(!1);
    let {
        matches: r
    } = _e.exports.useContext(Zx), n = r[r.length - 1], i = n ? n.params : {};
    n && n.pathname;
    let s = n ? n.pathnameBase : "/";
    n && n.route;
    let o = dC(),
        a;
    if (e) {
        var c;
        let N = typeof e == "string" ? Ch(e) : e;
        s === "/" || ((c = N.pathname) == null ? void 0 : c.startsWith(s)) || no(!1), a = N
    } else a = o;
    let d = a.pathname || "/",
        y = s === "/" ? d : d.slice(s.length) || "/",
        I = XI(t, {
            pathname: y
        });
    return mC(I && I.map(N => Object.assign({}, N, {
        params: Object.assign({}, i, N.params),
        pathname: va([s, N.pathname]),
        pathnameBase: N.pathnameBase === "/" ? s : va([s, N.pathnameBase])
    })), r)
}

function mC(t, e) {
    return e === void 0 && (e = []), t == null ? null : t.reduceRight((r, n, i) => _e.exports.createElement(Zx.Provider, {
        children: n.route.element !== void 0 ? n.route.element : r,
        value: {
            outlet: r,
            matches: e.concat(t.slice(0, i + 1))
        }
    }), null)
}

function t3(t) {
    no(!1)
}

function vC(t) {
    let {
        basename: e = "/",
        children: r = null,
        location: n,
        navigationType: i = xo.Pop,
        navigator: s,
        static: o = !1
    } = t;
    P1() && no(!1);
    let a = e3(e),
        c = _e.exports.useMemo(() => ({
            basename: a,
            navigator: s,
            static: o
        }), [a, s, o]);
    typeof n == "string" && (n = Ch(n));
    let {
        pathname: d = "/",
        search: y = "",
        hash: I = "",
        state: N = null,
        key: E = "default"
    } = n, T = _e.exports.useMemo(() => {
        let j = Xx(d, a);
        return j == null ? null : {
            pathname: j,
            search: y,
            hash: I,
            state: N,
            key: E
        }
    }, [a, d, y, I, N, E]);
    return T == null ? null : _e.exports.createElement(JI.Provider, {
        value: c
    }, _e.exports.createElement(D1.Provider, {
        children: r,
        value: {
            location: T,
            navigationType: i
        }
    }))
}

function gC(t) {
    let {
        children: e,
        location: r
    } = t;
    return pC(ep(e), r)
}

function ep(t) {
    let e = [];
    return _e.exports.Children.forEach(t, r => {
        if (!_e.exports.isValidElement(r)) return;
        if (r.type === _e.exports.Fragment) {
            e.push.apply(e, ep(r.props.children));
            return
        }
        r.type !== t3 && no(!1);
        let n = {
            caseSensitive: r.props.caseSensitive,
            element: r.props.element,
            index: r.props.index,
            path: r.props.path
        };
        r.props.children && (n.children = ep(r.props.children)), e.push(n)
    }), e
}
/**
 * React Router DOM v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function yC(t) {
    let {
        basename: e,
        children: r,
        window: n
    } = t, i = _e.exports.useRef();
    i.current == null && (i.current = YI({
        window: n
    }));
    let s = i.current,
        [o, a] = _e.exports.useState({
            action: s.action,
            location: s.location
        });
    return _e.exports.useLayoutEffect(() => s.listen(a), [s]), _e.exports.createElement(vC, {
        basename: e,
        children: r,
        location: o.location,
        navigationType: o.action,
        navigator: s
    })
}

function tp(t, e) {
    return tp = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
        return n.__proto__ = i, n
    }, tp(t, e)
}

function tu(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, tp(t, e)
}
var ru = function() {
        function t() {
            this.listeners = []
        }
        var e = t.prototype;
        return e.subscribe = function(n) {
            var i = this,
                s = n || function() {};
            return this.listeners.push(s), this.onSubscribe(),
                function() {
                    i.listeners = i.listeners.filter(function(o) {
                        return o !== s
                    }), i.onUnsubscribe()
                }
        }, e.hasListeners = function() {
            return this.listeners.length > 0
        }, e.onSubscribe = function() {}, e.onUnsubscribe = function() {}, t
    }(),
    Ac = typeof window == "undefined";

function Gr() {}

function wC(t, e) {
    return typeof t == "function" ? t(e) : t
}

function rp(t) {
    return typeof t == "number" && t >= 0 && t !== 1 / 0
}

function Sc(t) {
    return Array.isArray(t) ? t : [t]
}

function r3(t, e) {
    return Math.max(t + (e || 0) - Date.now(), 0)
}

function Df(t, e, r) {
    return Rl(t) ? typeof e == "function" ? _t({}, r, {
        queryKey: t,
        queryFn: e
    }) : _t({}, e, {
        queryKey: t
    }) : t
}

function xC(t, e, r) {
    return Rl(t) ? typeof e == "function" ? _t({}, r, {
        mutationKey: t,
        mutationFn: e
    }) : _t({}, e, {
        mutationKey: t
    }) : typeof t == "function" ? _t({}, e, {
        mutationFn: t
    }) : _t({}, t)
}

function Ts(t, e, r) {
    return Rl(t) ? [_t({}, e, {
        queryKey: t
    }), r] : [t || {}, e]
}

function bC(t, e) {
    if (t === !0 && e === !0 || t == null && e == null) return "all";
    if (t === !1 && e === !1) return "none";
    var r = t != null ? t : !e;
    return r ? "active" : "inactive"
}

function tg(t, e) {
    var r = t.active,
        n = t.exact,
        i = t.fetching,
        s = t.inactive,
        o = t.predicate,
        a = t.queryKey,
        c = t.stale;
    if (Rl(a)) {
        if (n) {
            if (e.queryHash !== L1(a, e.options)) return !1
        } else if (!Mc(e.queryKey, a)) return !1
    }
    var d = bC(r, s);
    if (d === "none") return !1;
    if (d !== "all") {
        var y = e.isActive();
        if (d === "active" && !y || d === "inactive" && y) return !1
    }
    return !(typeof c == "boolean" && e.isStale() !== c || typeof i == "boolean" && e.isFetching() !== i || o && !o(e))
}

function rg(t, e) {
    var r = t.exact,
        n = t.fetching,
        i = t.predicate,
        s = t.mutationKey;
    if (Rl(s)) {
        if (!e.options.mutationKey) return !1;
        if (r) {
            if (bo(e.options.mutationKey) !== bo(s)) return !1
        } else if (!Mc(e.options.mutationKey, s)) return !1
    }
    return !(typeof n == "boolean" && e.state.status === "loading" !== n || i && !i(e))
}

function L1(t, e) {
    var r = (e == null ? void 0 : e.queryKeyHashFn) || bo;
    return r(t)
}

function bo(t) {
    var e = Sc(t);
    return AC(e)
}

function AC(t) {
    return JSON.stringify(t, function(e, r) {
        return np(r) ? Object.keys(r).sort().reduce(function(n, i) {
            return n[i] = r[i], n
        }, {}) : r
    })
}

function Mc(t, e) {
    return n3(Sc(t), Sc(e))
}

function n3(t, e) {
    return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? !Object.keys(e).some(function(r) {
        return !n3(t[r], e[r])
    }) : !1
}

function Ec(t, e) {
    if (t === e) return t;
    var r = Array.isArray(t) && Array.isArray(e);
    if (r || np(t) && np(e)) {
        for (var n = r ? t.length : Object.keys(t).length, i = r ? e : Object.keys(e), s = i.length, o = r ? [] : {}, a = 0, c = 0; c < s; c++) {
            var d = r ? c : i[c];
            o[d] = Ec(t[d], e[d]), o[d] === t[d] && a++
        }
        return n === s && a === n ? t : o
    }
    return e
}

function SC(t, e) {
    if (t && !e || e && !t) return !1;
    for (var r in t)
        if (t[r] !== e[r]) return !1;
    return !0
}

function np(t) {
    if (!ng(t)) return !1;
    var e = t.constructor;
    if (typeof e == "undefined") return !0;
    var r = e.prototype;
    return !(!ng(r) || !r.hasOwnProperty("isPrototypeOf"))
}

function ng(t) {
    return Object.prototype.toString.call(t) === "[object Object]"
}

function Rl(t) {
    return typeof t == "string" || Array.isArray(t)
}

function MC(t) {
    return new Promise(function(e) {
        setTimeout(e, t)
    })
}

function ig(t) {
    Promise.resolve().then(t).catch(function(e) {
        return setTimeout(function() {
            throw e
        })
    })
}

function i3() {
    if (typeof AbortController == "function") return new AbortController
}
var EC = function(t) {
        tu(e, t);

        function e() {
            var n;
            return n = t.call(this) || this, n.setup = function(i) {
                var s;
                if (!Ac && ((s = window) == null ? void 0 : s.addEventListener)) {
                    var o = function() {
                        return i()
                    };
                    return window.addEventListener("visibilitychange", o, !1), window.addEventListener("focus", o, !1),
                        function() {
                            window.removeEventListener("visibilitychange", o), window.removeEventListener("focus", o)
                        }
                }
            }, n
        }
        var r = e.prototype;
        return r.onSubscribe = function() {
            this.cleanup || this.setEventListener(this.setup)
        }, r.onUnsubscribe = function() {
            if (!this.hasListeners()) {
                var i;
                (i = this.cleanup) == null || i.call(this), this.cleanup = void 0
            }
        }, r.setEventListener = function(i) {
            var s, o = this;
            this.setup = i, (s = this.cleanup) == null || s.call(this), this.cleanup = i(function(a) {
                typeof a == "boolean" ? o.setFocused(a) : o.onFocus()
            })
        }, r.setFocused = function(i) {
            this.focused = i, i && this.onFocus()
        }, r.onFocus = function() {
            this.listeners.forEach(function(i) {
                i()
            })
        }, r.isFocused = function() {
            return typeof this.focused == "boolean" ? this.focused : typeof document == "undefined" ? !0 : [void 0, "visible", "prerender"].includes(document.visibilityState)
        }, e
    }(ru),
    Gu = new EC,
    _C = function(t) {
        tu(e, t);

        function e() {
            var n;
            return n = t.call(this) || this, n.setup = function(i) {
                var s;
                if (!Ac && ((s = window) == null ? void 0 : s.addEventListener)) {
                    var o = function() {
                        return i()
                    };
                    return window.addEventListener("online", o, !1), window.addEventListener("offline", o, !1),
                        function() {
                            window.removeEventListener("online", o), window.removeEventListener("offline", o)
                        }
                }
            }, n
        }
        var r = e.prototype;
        return r.onSubscribe = function() {
            this.cleanup || this.setEventListener(this.setup)
        }, r.onUnsubscribe = function() {
            if (!this.hasListeners()) {
                var i;
                (i = this.cleanup) == null || i.call(this), this.cleanup = void 0
            }
        }, r.setEventListener = function(i) {
            var s, o = this;
            this.setup = i, (s = this.cleanup) == null || s.call(this), this.cleanup = i(function(a) {
                typeof a == "boolean" ? o.setOnline(a) : o.onOnline()
            })
        }, r.setOnline = function(i) {
            this.online = i, i && this.onOnline()
        }, r.onOnline = function() {
            this.listeners.forEach(function(i) {
                i()
            })
        }, r.isOnline = function() {
            return typeof this.online == "boolean" ? this.online : typeof navigator == "undefined" || typeof navigator.onLine == "undefined" ? !0 : navigator.onLine
        }, e
    }(ru),
    Pf = new _C;

function IC(t) {
    return Math.min(1e3 * Math.pow(2, t), 3e4)
}

function _c(t) {
    return typeof(t == null ? void 0 : t.cancel) == "function"
}
var s3 = function(e) {
    this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent
};

function Lf(t) {
    return t instanceof s3
}
var o3 = function(e) {
        var r = this,
            n = !1,
            i, s, o, a;
        this.abort = e.abort, this.cancel = function(N) {
            return i == null ? void 0 : i(N)
        }, this.cancelRetry = function() {
            n = !0
        }, this.continueRetry = function() {
            n = !1
        }, this.continue = function() {
            return s == null ? void 0 : s()
        }, this.failureCount = 0, this.isPaused = !1, this.isResolved = !1, this.isTransportCancelable = !1, this.promise = new Promise(function(N, E) {
            o = N, a = E
        });
        var c = function(E) {
                r.isResolved || (r.isResolved = !0, e.onSuccess == null || e.onSuccess(E), s == null || s(), o(E))
            },
            d = function(E) {
                r.isResolved || (r.isResolved = !0, e.onError == null || e.onError(E), s == null || s(), a(E))
            },
            y = function() {
                return new Promise(function(E) {
                    s = E, r.isPaused = !0, e.onPause == null || e.onPause()
                }).then(function() {
                    s = void 0, r.isPaused = !1, e.onContinue == null || e.onContinue()
                })
            },
            I = function N() {
                if (!r.isResolved) {
                    var E;
                    try {
                        E = e.fn()
                    } catch (T) {
                        E = Promise.reject(T)
                    }
                    i = function(j) {
                        if (!r.isResolved && (d(new s3(j)), r.abort == null || r.abort(), _c(E))) try {
                            E.cancel()
                        } catch {}
                    }, r.isTransportCancelable = _c(E), Promise.resolve(E).then(c).catch(function(T) {
                        var j, V;
                        if (!r.isResolved) {
                            var P = (j = e.retry) != null ? j : 3,
                                O = (V = e.retryDelay) != null ? V : IC,
                                R = typeof O == "function" ? O(r.failureCount, T) : O,
                                q = P === !0 || typeof P == "number" && r.failureCount < P || typeof P == "function" && P(r.failureCount, T);
                            if (n || !q) {
                                d(T);
                                return
                            }
                            r.failureCount++, e.onFail == null || e.onFail(r.failureCount, T), MC(R).then(function() {
                                if (!Gu.isFocused() || !Pf.isOnline()) return y()
                            }).then(function() {
                                n ? d(T) : N()
                            })
                        }
                    })
                }
            };
        I()
    },
    CC = function() {
        function t() {
            this.queue = [], this.transactions = 0, this.notifyFn = function(r) {
                r()
            }, this.batchNotifyFn = function(r) {
                r()
            }
        }
        var e = t.prototype;
        return e.batch = function(n) {
            var i;
            this.transactions++;
            try {
                i = n()
            } finally {
                this.transactions--, this.transactions || this.flush()
            }
            return i
        }, e.schedule = function(n) {
            var i = this;
            this.transactions ? this.queue.push(n) : ig(function() {
                i.notifyFn(n)
            })
        }, e.batchCalls = function(n) {
            var i = this;
            return function() {
                for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++) o[a] = arguments[a];
                i.schedule(function() {
                    n.apply(void 0, o)
                })
            }
        }, e.flush = function() {
            var n = this,
                i = this.queue;
            this.queue = [], i.length && ig(function() {
                n.batchNotifyFn(function() {
                    i.forEach(function(s) {
                        n.notifyFn(s)
                    })
                })
            })
        }, e.setNotifyFunction = function(n) {
            this.notifyFn = n
        }, e.setBatchNotifyFunction = function(n) {
            this.batchNotifyFn = n
        }, t
    }(),
    dr = new CC,
    a3 = console;

function Ic() {
    return a3
}

function BC(t) {
    a3 = t
}
var kC = function() {
        function t(r) {
            this.abortSignalConsumed = !1, this.hadObservers = !1, this.defaultOptions = r.defaultOptions, this.setOptions(r.options), this.observers = [], this.cache = r.cache, this.queryKey = r.queryKey, this.queryHash = r.queryHash, this.initialState = r.state || this.getDefaultState(this.options), this.state = this.initialState, this.meta = r.meta, this.scheduleGc()
        }
        var e = t.prototype;
        return e.setOptions = function(n) {
            var i;
            this.options = _t({}, this.defaultOptions, n), this.meta = n == null ? void 0 : n.meta, this.cacheTime = Math.max(this.cacheTime || 0, (i = this.options.cacheTime) != null ? i : 5 * 60 * 1e3)
        }, e.setDefaultOptions = function(n) {
            this.defaultOptions = n
        }, e.scheduleGc = function() {
            var n = this;
            this.clearGcTimeout(), rp(this.cacheTime) && (this.gcTimeout = setTimeout(function() {
                n.optionalRemove()
            }, this.cacheTime))
        }, e.clearGcTimeout = function() {
            clearTimeout(this.gcTimeout), this.gcTimeout = void 0
        }, e.optionalRemove = function() {
            this.observers.length || (this.state.isFetching ? this.hadObservers && this.scheduleGc() : this.cache.remove(this))
        }, e.setData = function(n, i) {
            var s, o, a = this.state.data,
                c = wC(n, a);
            return (s = (o = this.options).isDataEqual) != null && s.call(o, a, c) ? c = a : this.options.structuralSharing !== !1 && (c = Ec(a, c)), this.dispatch({
                data: c,
                type: "success",
                dataUpdatedAt: i == null ? void 0 : i.updatedAt
            }), c
        }, e.setState = function(n, i) {
            this.dispatch({
                type: "setState",
                state: n,
                setStateOptions: i
            })
        }, e.cancel = function(n) {
            var i, s = this.promise;
            return (i = this.retryer) == null || i.cancel(n), s ? s.then(Gr).catch(Gr) : Promise.resolve()
        }, e.destroy = function() {
            this.clearGcTimeout(), this.cancel({
                silent: !0
            })
        }, e.reset = function() {
            this.destroy(), this.setState(this.initialState)
        }, e.isActive = function() {
            return this.observers.some(function(n) {
                return n.options.enabled !== !1
            })
        }, e.isFetching = function() {
            return this.state.isFetching
        }, e.isStale = function() {
            return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function(n) {
                return n.getCurrentResult().isStale
            })
        }, e.isStaleByTime = function(n) {
            return n === void 0 && (n = 0), this.state.isInvalidated || !this.state.dataUpdatedAt || !r3(this.state.dataUpdatedAt, n)
        }, e.onFocus = function() {
            var n, i = this.observers.find(function(s) {
                return s.shouldFetchOnWindowFocus()
            });
            i && i.refetch(), (n = this.retryer) == null || n.continue()
        }, e.onOnline = function() {
            var n, i = this.observers.find(function(s) {
                return s.shouldFetchOnReconnect()
            });
            i && i.refetch(), (n = this.retryer) == null || n.continue()
        }, e.addObserver = function(n) {
            this.observers.indexOf(n) === -1 && (this.observers.push(n), this.hadObservers = !0, this.clearGcTimeout(), this.cache.notify({
                type: "observerAdded",
                query: this,
                observer: n
            }))
        }, e.removeObserver = function(n) {
            this.observers.indexOf(n) !== -1 && (this.observers = this.observers.filter(function(i) {
                return i !== n
            }), this.observers.length || (this.retryer && (this.retryer.isTransportCancelable || this.abortSignalConsumed ? this.retryer.cancel({
                revert: !0
            }) : this.retryer.cancelRetry()), this.cacheTime ? this.scheduleGc() : this.cache.remove(this)), this.cache.notify({
                type: "observerRemoved",
                query: this,
                observer: n
            }))
        }, e.getObserversCount = function() {
            return this.observers.length
        }, e.invalidate = function() {
            this.state.isInvalidated || this.dispatch({
                type: "invalidate"
            })
        }, e.fetch = function(n, i) {
            var s = this,
                o, a, c;
            if (this.state.isFetching) {
                if (this.state.dataUpdatedAt && (i == null ? void 0 : i.cancelRefetch)) this.cancel({
                    silent: !0
                });
                else if (this.promise) {
                    var d;
                    return (d = this.retryer) == null || d.continueRetry(), this.promise
                }
            }
            if (n && this.setOptions(n), !this.options.queryFn) {
                var y = this.observers.find(function(O) {
                    return O.options.queryFn
                });
                y && this.setOptions(y.options)
            }
            var I = Sc(this.queryKey),
                N = i3(),
                E = {
                    queryKey: I,
                    pageParam: void 0,
                    meta: this.meta
                };
            Object.defineProperty(E, "signal", {
                enumerable: !0,
                get: function() {
                    if (N) return s.abortSignalConsumed = !0, N.signal
                }
            });
            var T = function() {
                    return s.options.queryFn ? (s.abortSignalConsumed = !1, s.options.queryFn(E)) : Promise.reject("Missing queryFn")
                },
                j = {
                    fetchOptions: i,
                    options: this.options,
                    queryKey: I,
                    state: this.state,
                    fetchFn: T,
                    meta: this.meta
                };
            if ((o = this.options.behavior) != null && o.onFetch) {
                var V;
                (V = this.options.behavior) == null || V.onFetch(j)
            }
            if (this.revertState = this.state, !this.state.isFetching || this.state.fetchMeta !== ((a = j.fetchOptions) == null ? void 0 : a.meta)) {
                var P;
                this.dispatch({
                    type: "fetch",
                    meta: (P = j.fetchOptions) == null ? void 0 : P.meta
                })
            }
            return this.retryer = new o3({
                fn: j.fetchFn,
                abort: N == null || (c = N.abort) == null ? void 0 : c.bind(N),
                onSuccess: function(R) {
                    s.setData(R), s.cache.config.onSuccess == null || s.cache.config.onSuccess(R, s), s.cacheTime === 0 && s.optionalRemove()
                },
                onError: function(R) {
                    Lf(R) && R.silent || s.dispatch({
                        type: "error",
                        error: R
                    }), Lf(R) || (s.cache.config.onError == null || s.cache.config.onError(R, s), Ic().error(R)), s.cacheTime === 0 && s.optionalRemove()
                },
                onFail: function() {
                    s.dispatch({
                        type: "failed"
                    })
                },
                onPause: function() {
                    s.dispatch({
                        type: "pause"
                    })
                },
                onContinue: function() {
                    s.dispatch({
                        type: "continue"
                    })
                },
                retry: j.options.retry,
                retryDelay: j.options.retryDelay
            }), this.promise = this.retryer.promise, this.promise
        }, e.dispatch = function(n) {
            var i = this;
            this.state = this.reducer(this.state, n), dr.batch(function() {
                i.observers.forEach(function(s) {
                    s.onQueryUpdate(n)
                }), i.cache.notify({
                    query: i,
                    type: "queryUpdated",
                    action: n
                })
            })
        }, e.getDefaultState = function(n) {
            var i = typeof n.initialData == "function" ? n.initialData() : n.initialData,
                s = typeof n.initialData != "undefined",
                o = s ? typeof n.initialDataUpdatedAt == "function" ? n.initialDataUpdatedAt() : n.initialDataUpdatedAt : 0,
                a = typeof i != "undefined";
            return {
                data: i,
                dataUpdateCount: 0,
                dataUpdatedAt: a ? o != null ? o : Date.now() : 0,
                error: null,
                errorUpdateCount: 0,
                errorUpdatedAt: 0,
                fetchFailureCount: 0,
                fetchMeta: null,
                isFetching: !1,
                isInvalidated: !1,
                isPaused: !1,
                status: a ? "success" : "idle"
            }
        }, e.reducer = function(n, i) {
            var s, o;
            switch (i.type) {
                case "failed":
                    return _t({}, n, {
                        fetchFailureCount: n.fetchFailureCount + 1
                    });
                case "pause":
                    return _t({}, n, {
                        isPaused: !0
                    });
                case "continue":
                    return _t({}, n, {
                        isPaused: !1
                    });
                case "fetch":
                    return _t({}, n, {
                        fetchFailureCount: 0,
                        fetchMeta: (s = i.meta) != null ? s : null,
                        isFetching: !0,
                        isPaused: !1
                    }, !n.dataUpdatedAt && {
                        error: null,
                        status: "loading"
                    });
                case "success":
                    return _t({}, n, {
                        data: i.data,
                        dataUpdateCount: n.dataUpdateCount + 1,
                        dataUpdatedAt: (o = i.dataUpdatedAt) != null ? o : Date.now(),
                        error: null,
                        fetchFailureCount: 0,
                        isFetching: !1,
                        isInvalidated: !1,
                        isPaused: !1,
                        status: "success"
                    });
                case "error":
                    var a = i.error;
                    return Lf(a) && a.revert && this.revertState ? _t({}, this.revertState) : _t({}, n, {
                        error: a,
                        errorUpdateCount: n.errorUpdateCount + 1,
                        errorUpdatedAt: Date.now(),
                        fetchFailureCount: n.fetchFailureCount + 1,
                        isFetching: !1,
                        isPaused: !1,
                        status: "error"
                    });
                case "invalidate":
                    return _t({}, n, {
                        isInvalidated: !0
                    });
                case "setState":
                    return _t({}, n, i.state);
                default:
                    return n
            }
        }, t
    }(),
    NC = function(t) {
        tu(e, t);

        function e(n) {
            var i;
            return i = t.call(this) || this, i.config = n || {}, i.queries = [], i.queriesMap = {}, i
        }
        var r = e.prototype;
        return r.build = function(i, s, o) {
            var a, c = s.queryKey,
                d = (a = s.queryHash) != null ? a : L1(c, s),
                y = this.get(d);
            return y || (y = new kC({
                cache: this,
                queryKey: c,
                queryHash: d,
                options: i.defaultQueryOptions(s),
                state: o,
                defaultOptions: i.getQueryDefaults(c),
                meta: s.meta
            }), this.add(y)), y
        }, r.add = function(i) {
            this.queriesMap[i.queryHash] || (this.queriesMap[i.queryHash] = i, this.queries.push(i), this.notify({
                type: "queryAdded",
                query: i
            }))
        }, r.remove = function(i) {
            var s = this.queriesMap[i.queryHash];
            s && (i.destroy(), this.queries = this.queries.filter(function(o) {
                return o !== i
            }), s === i && delete this.queriesMap[i.queryHash], this.notify({
                type: "queryRemoved",
                query: i
            }))
        }, r.clear = function() {
            var i = this;
            dr.batch(function() {
                i.queries.forEach(function(s) {
                    i.remove(s)
                })
            })
        }, r.get = function(i) {
            return this.queriesMap[i]
        }, r.getAll = function() {
            return this.queries
        }, r.find = function(i, s) {
            var o = Ts(i, s),
                a = o[0];
            return typeof a.exact == "undefined" && (a.exact = !0), this.queries.find(function(c) {
                return tg(a, c)
            })
        }, r.findAll = function(i, s) {
            var o = Ts(i, s),
                a = o[0];
            return Object.keys(a).length > 0 ? this.queries.filter(function(c) {
                return tg(a, c)
            }) : this.queries
        }, r.notify = function(i) {
            var s = this;
            dr.batch(function() {
                s.listeners.forEach(function(o) {
                    o(i)
                })
            })
        }, r.onFocus = function() {
            var i = this;
            dr.batch(function() {
                i.queries.forEach(function(s) {
                    s.onFocus()
                })
            })
        }, r.onOnline = function() {
            var i = this;
            dr.batch(function() {
                i.queries.forEach(function(s) {
                    s.onOnline()
                })
            })
        }, e
    }(ru),
    TC = function() {
        function t(r) {
            this.options = _t({}, r.defaultOptions, r.options), this.mutationId = r.mutationId, this.mutationCache = r.mutationCache, this.observers = [], this.state = r.state || u3(), this.meta = r.meta
        }
        var e = t.prototype;
        return e.setState = function(n) {
            this.dispatch({
                type: "setState",
                state: n
            })
        }, e.addObserver = function(n) {
            this.observers.indexOf(n) === -1 && this.observers.push(n)
        }, e.removeObserver = function(n) {
            this.observers = this.observers.filter(function(i) {
                return i !== n
            })
        }, e.cancel = function() {
            return this.retryer ? (this.retryer.cancel(), this.retryer.promise.then(Gr).catch(Gr)) : Promise.resolve()
        }, e.continue = function() {
            return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute()
        }, e.execute = function() {
            var n = this,
                i, s = this.state.status === "loading",
                o = Promise.resolve();
            return s || (this.dispatch({
                type: "loading",
                variables: this.options.variables
            }), o = o.then(function() {
                n.mutationCache.config.onMutate == null || n.mutationCache.config.onMutate(n.state.variables, n)
            }).then(function() {
                return n.options.onMutate == null ? void 0 : n.options.onMutate(n.state.variables)
            }).then(function(a) {
                a !== n.state.context && n.dispatch({
                    type: "loading",
                    context: a,
                    variables: n.state.variables
                })
            })), o.then(function() {
                return n.executeMutation()
            }).then(function(a) {
                i = a, n.mutationCache.config.onSuccess == null || n.mutationCache.config.onSuccess(i, n.state.variables, n.state.context, n)
            }).then(function() {
                return n.options.onSuccess == null ? void 0 : n.options.onSuccess(i, n.state.variables, n.state.context)
            }).then(function() {
                return n.options.onSettled == null ? void 0 : n.options.onSettled(i, null, n.state.variables, n.state.context)
            }).then(function() {
                return n.dispatch({
                    type: "success",
                    data: i
                }), i
            }).catch(function(a) {
                return n.mutationCache.config.onError == null || n.mutationCache.config.onError(a, n.state.variables, n.state.context, n), Ic().error(a), Promise.resolve().then(function() {
                    return n.options.onError == null ? void 0 : n.options.onError(a, n.state.variables, n.state.context)
                }).then(function() {
                    return n.options.onSettled == null ? void 0 : n.options.onSettled(void 0, a, n.state.variables, n.state.context)
                }).then(function() {
                    throw n.dispatch({
                        type: "error",
                        error: a
                    }), a
                })
            })
        }, e.executeMutation = function() {
            var n = this,
                i;
            return this.retryer = new o3({
                fn: function() {
                    return n.options.mutationFn ? n.options.mutationFn(n.state.variables) : Promise.reject("No mutationFn found")
                },
                onFail: function() {
                    n.dispatch({
                        type: "failed"
                    })
                },
                onPause: function() {
                    n.dispatch({
                        type: "pause"
                    })
                },
                onContinue: function() {
                    n.dispatch({
                        type: "continue"
                    })
                },
                retry: (i = this.options.retry) != null ? i : 0,
                retryDelay: this.options.retryDelay
            }), this.retryer.promise
        }, e.dispatch = function(n) {
            var i = this;
            this.state = OC(this.state, n), dr.batch(function() {
                i.observers.forEach(function(s) {
                    s.onMutationUpdate(n)
                }), i.mutationCache.notify(i)
            })
        }, t
    }();

function u3() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        isPaused: !1,
        status: "idle",
        variables: void 0
    }
}

function OC(t, e) {
    switch (e.type) {
        case "failed":
            return _t({}, t, {
                failureCount: t.failureCount + 1
            });
        case "pause":
            return _t({}, t, {
                isPaused: !0
            });
        case "continue":
            return _t({}, t, {
                isPaused: !1
            });
        case "loading":
            return _t({}, t, {
                context: e.context,
                data: void 0,
                error: null,
                isPaused: !1,
                status: "loading",
                variables: e.variables
            });
        case "success":
            return _t({}, t, {
                data: e.data,
                error: null,
                status: "success",
                isPaused: !1
            });
        case "error":
            return _t({}, t, {
                data: void 0,
                error: e.error,
                failureCount: t.failureCount + 1,
                isPaused: !1,
                status: "error"
            });
        case "setState":
            return _t({}, t, e.state);
        default:
            return t
    }
}
var RC = function(t) {
    tu(e, t);

    function e(n) {
        var i;
        return i = t.call(this) || this, i.config = n || {}, i.mutations = [], i.mutationId = 0, i
    }
    var r = e.prototype;
    return r.build = function(i, s, o) {
        var a = new TC({
            mutationCache: this,
            mutationId: ++this.mutationId,
            options: i.defaultMutationOptions(s),
            state: o,
            defaultOptions: s.mutationKey ? i.getMutationDefaults(s.mutationKey) : void 0,
            meta: s.meta
        });
        return this.add(a), a
    }, r.add = function(i) {
        this.mutations.push(i), this.notify(i)
    }, r.remove = function(i) {
        this.mutations = this.mutations.filter(function(s) {
            return s !== i
        }), i.cancel(), this.notify(i)
    }, r.clear = function() {
        var i = this;
        dr.batch(function() {
            i.mutations.forEach(function(s) {
                i.remove(s)
            })
        })
    }, r.getAll = function() {
        return this.mutations
    }, r.find = function(i) {
        return typeof i.exact == "undefined" && (i.exact = !0), this.mutations.find(function(s) {
            return rg(i, s)
        })
    }, r.findAll = function(i) {
        return this.mutations.filter(function(s) {
            return rg(i, s)
        })
    }, r.notify = function(i) {
        var s = this;
        dr.batch(function() {
            s.listeners.forEach(function(o) {
                o(i)
            })
        })
    }, r.onFocus = function() {
        this.resumePausedMutations()
    }, r.onOnline = function() {
        this.resumePausedMutations()
    }, r.resumePausedMutations = function() {
        var i = this.mutations.filter(function(s) {
            return s.state.isPaused
        });
        return dr.batch(function() {
            return i.reduce(function(s, o) {
                return s.then(function() {
                    return o.continue().catch(Gr)
                })
            }, Promise.resolve())
        })
    }, e
}(ru);

function DC() {
    return {
        onFetch: function(e) {
            e.fetchFn = function() {
                var r, n, i, s, o, a, c = (r = e.fetchOptions) == null || (n = r.meta) == null ? void 0 : n.refetchPage,
                    d = (i = e.fetchOptions) == null || (s = i.meta) == null ? void 0 : s.fetchMore,
                    y = d == null ? void 0 : d.pageParam,
                    I = (d == null ? void 0 : d.direction) === "forward",
                    N = (d == null ? void 0 : d.direction) === "backward",
                    E = ((o = e.state.data) == null ? void 0 : o.pages) || [],
                    T = ((a = e.state.data) == null ? void 0 : a.pageParams) || [],
                    j = i3(),
                    V = j == null ? void 0 : j.signal,
                    P = T,
                    O = !1,
                    R = e.options.queryFn || function() {
                        return Promise.reject("Missing queryFn")
                    },
                    q = function(f, h, b, C) {
                        return P = C ? [h].concat(P) : [].concat(P, [h]), C ? [b].concat(f) : [].concat(f, [b])
                    },
                    W = function(f, h, b, C) {
                        if (O) return Promise.reject("Cancelled");
                        if (typeof b == "undefined" && !h && f.length) return Promise.resolve(f);
                        var _ = {
                                queryKey: e.queryKey,
                                signal: V,
                                pageParam: b,
                                meta: e.meta
                            },
                            M = R(_),
                            m = Promise.resolve(M).then(function(x) {
                                return q(f, b, x, C)
                            });
                        if (_c(M)) {
                            var A = m;
                            A.cancel = M.cancel
                        }
                        return m
                    },
                    Y;
                if (!E.length) Y = W([]);
                else if (I) {
                    var G = typeof y != "undefined",
                        J = G ? y : sg(e.options, E);
                    Y = W(E, G, J)
                } else if (N) {
                    var pe = typeof y != "undefined",
                        we = pe ? y : PC(e.options, E);
                    Y = W(E, pe, we, !0)
                } else(function() {
                    P = [];
                    var p = typeof e.options.getNextPageParam == "undefined",
                        f = c && E[0] ? c(E[0], 0, E) : !0;
                    Y = f ? W([], p, T[0]) : Promise.resolve(q([], T[0], E[0]));
                    for (var h = function(_) {
                            Y = Y.then(function(M) {
                                var m = c && E[_] ? c(E[_], _, E) : !0;
                                if (m) {
                                    var A = p ? T[_] : sg(e.options, M);
                                    return W(M, p, A)
                                }
                                return Promise.resolve(q(M, T[_], E[_]))
                            })
                        }, b = 1; b < E.length; b++) h(b)
                })();
                var H = Y.then(function(p) {
                        return {
                            pages: p,
                            pageParams: P
                        }
                    }),
                    w = H;
                return w.cancel = function() {
                    O = !0, j == null || j.abort(), _c(Y) && Y.cancel()
                }, H
            }
        }
    }
}

function sg(t, e) {
    return t.getNextPageParam == null ? void 0 : t.getNextPageParam(e[e.length - 1], e)
}

function PC(t, e) {
    return t.getPreviousPageParam == null ? void 0 : t.getPreviousPageParam(e[0], e)
}
var LC = function() {
        function t(r) {
            r === void 0 && (r = {}), this.queryCache = r.queryCache || new NC, this.mutationCache = r.mutationCache || new RC, this.defaultOptions = r.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = []
        }
        var e = t.prototype;
        return e.mount = function() {
            var n = this;
            this.unsubscribeFocus = Gu.subscribe(function() {
                Gu.isFocused() && Pf.isOnline() && (n.mutationCache.onFocus(), n.queryCache.onFocus())
            }), this.unsubscribeOnline = Pf.subscribe(function() {
                Gu.isFocused() && Pf.isOnline() && (n.mutationCache.onOnline(), n.queryCache.onOnline())
            })
        }, e.unmount = function() {
            var n, i;
            (n = this.unsubscribeFocus) == null || n.call(this), (i = this.unsubscribeOnline) == null || i.call(this)
        }, e.isFetching = function(n, i) {
            var s = Ts(n, i),
                o = s[0];
            return o.fetching = !0, this.queryCache.findAll(o).length
        }, e.isMutating = function(n) {
            return this.mutationCache.findAll(_t({}, n, {
                fetching: !0
            })).length
        }, e.getQueryData = function(n, i) {
            var s;
            return (s = this.queryCache.find(n, i)) == null ? void 0 : s.state.data
        }, e.getQueriesData = function(n) {
            return this.getQueryCache().findAll(n).map(function(i) {
                var s = i.queryKey,
                    o = i.state,
                    a = o.data;
                return [s, a]
            })
        }, e.setQueryData = function(n, i, s) {
            var o = Df(n),
                a = this.defaultQueryOptions(o);
            return this.queryCache.build(this, a).setData(i, s)
        }, e.setQueriesData = function(n, i, s) {
            var o = this;
            return dr.batch(function() {
                return o.getQueryCache().findAll(n).map(function(a) {
                    var c = a.queryKey;
                    return [c, o.setQueryData(c, i, s)]
                })
            })
        }, e.getQueryState = function(n, i) {
            var s;
            return (s = this.queryCache.find(n, i)) == null ? void 0 : s.state
        }, e.removeQueries = function(n, i) {
            var s = Ts(n, i),
                o = s[0],
                a = this.queryCache;
            dr.batch(function() {
                a.findAll(o).forEach(function(c) {
                    a.remove(c)
                })
            })
        }, e.resetQueries = function(n, i, s) {
            var o = this,
                a = Ts(n, i, s),
                c = a[0],
                d = a[1],
                y = this.queryCache,
                I = _t({}, c, {
                    active: !0
                });
            return dr.batch(function() {
                return y.findAll(c).forEach(function(N) {
                    N.reset()
                }), o.refetchQueries(I, d)
            })
        }, e.cancelQueries = function(n, i, s) {
            var o = this,
                a = Ts(n, i, s),
                c = a[0],
                d = a[1],
                y = d === void 0 ? {} : d;
            typeof y.revert == "undefined" && (y.revert = !0);
            var I = dr.batch(function() {
                return o.queryCache.findAll(c).map(function(N) {
                    return N.cancel(y)
                })
            });
            return Promise.all(I).then(Gr).catch(Gr)
        }, e.invalidateQueries = function(n, i, s) {
            var o, a, c, d = this,
                y = Ts(n, i, s),
                I = y[0],
                N = y[1],
                E = _t({}, I, {
                    active: (o = (a = I.refetchActive) != null ? a : I.active) != null ? o : !0,
                    inactive: (c = I.refetchInactive) != null ? c : !1
                });
            return dr.batch(function() {
                return d.queryCache.findAll(I).forEach(function(T) {
                    T.invalidate()
                }), d.refetchQueries(E, N)
            })
        }, e.refetchQueries = function(n, i, s) {
            var o = this,
                a = Ts(n, i, s),
                c = a[0],
                d = a[1],
                y = dr.batch(function() {
                    return o.queryCache.findAll(c).map(function(N) {
                        return N.fetch(void 0, _t({}, d, {
                            meta: {
                                refetchPage: c == null ? void 0 : c.refetchPage
                            }
                        }))
                    })
                }),
                I = Promise.all(y).then(Gr);
            return d != null && d.throwOnError || (I = I.catch(Gr)), I
        }, e.fetchQuery = function(n, i, s) {
            var o = Df(n, i, s),
                a = this.defaultQueryOptions(o);
            typeof a.retry == "undefined" && (a.retry = !1);
            var c = this.queryCache.build(this, a);
            return c.isStaleByTime(a.staleTime) ? c.fetch(a) : Promise.resolve(c.state.data)
        }, e.prefetchQuery = function(n, i, s) {
            return this.fetchQuery(n, i, s).then(Gr).catch(Gr)
        }, e.fetchInfiniteQuery = function(n, i, s) {
            var o = Df(n, i, s);
            return o.behavior = DC(), this.fetchQuery(o)
        }, e.prefetchInfiniteQuery = function(n, i, s) {
            return this.fetchInfiniteQuery(n, i, s).then(Gr).catch(Gr)
        }, e.cancelMutations = function() {
            var n = this,
                i = dr.batch(function() {
                    return n.mutationCache.getAll().map(function(s) {
                        return s.cancel()
                    })
                });
            return Promise.all(i).then(Gr).catch(Gr)
        }, e.resumePausedMutations = function() {
            return this.getMutationCache().resumePausedMutations()
        }, e.executeMutation = function(n) {
            return this.mutationCache.build(this, n).execute()
        }, e.getQueryCache = function() {
            return this.queryCache
        }, e.getMutationCache = function() {
            return this.mutationCache
        }, e.getDefaultOptions = function() {
            return this.defaultOptions
        }, e.setDefaultOptions = function(n) {
            this.defaultOptions = n
        }, e.setQueryDefaults = function(n, i) {
            var s = this.queryDefaults.find(function(o) {
                return bo(n) === bo(o.queryKey)
            });
            s ? s.defaultOptions = i : this.queryDefaults.push({
                queryKey: n,
                defaultOptions: i
            })
        }, e.getQueryDefaults = function(n) {
            var i;
            return n ? (i = this.queryDefaults.find(function(s) {
                return Mc(n, s.queryKey)
            })) == null ? void 0 : i.defaultOptions : void 0
        }, e.setMutationDefaults = function(n, i) {
            var s = this.mutationDefaults.find(function(o) {
                return bo(n) === bo(o.mutationKey)
            });
            s ? s.defaultOptions = i : this.mutationDefaults.push({
                mutationKey: n,
                defaultOptions: i
            })
        }, e.getMutationDefaults = function(n) {
            var i;
            return n ? (i = this.mutationDefaults.find(function(s) {
                return Mc(n, s.mutationKey)
            })) == null ? void 0 : i.defaultOptions : void 0
        }, e.defaultQueryOptions = function(n) {
            if (n != null && n._defaulted) return n;
            var i = _t({}, this.defaultOptions.queries, this.getQueryDefaults(n == null ? void 0 : n.queryKey), n, {
                _defaulted: !0
            });
            return !i.queryHash && i.queryKey && (i.queryHash = L1(i.queryKey, i)), i
        }, e.defaultQueryObserverOptions = function(n) {
            return this.defaultQueryOptions(n)
        }, e.defaultMutationOptions = function(n) {
            return n != null && n._defaulted ? n : _t({}, this.defaultOptions.mutations, this.getMutationDefaults(n == null ? void 0 : n.mutationKey), n, {
                _defaulted: !0
            })
        }, e.clear = function() {
            this.queryCache.clear(), this.mutationCache.clear()
        }, t
    }(),
    FC = function(t) {
        tu(e, t);

        function e(n, i) {
            var s;
            return s = t.call(this) || this, s.client = n, s.options = i, s.trackedProps = [], s.selectError = null, s.bindMethods(), s.setOptions(i), s
        }
        var r = e.prototype;
        return r.bindMethods = function() {
            this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this)
        }, r.onSubscribe = function() {
            this.listeners.length === 1 && (this.currentQuery.addObserver(this), og(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers())
        }, r.onUnsubscribe = function() {
            this.listeners.length || this.destroy()
        }, r.shouldFetchOnReconnect = function() {
            return ip(this.currentQuery, this.options, this.options.refetchOnReconnect)
        }, r.shouldFetchOnWindowFocus = function() {
            return ip(this.currentQuery, this.options, this.options.refetchOnWindowFocus)
        }, r.destroy = function() {
            this.listeners = [], this.clearTimers(), this.currentQuery.removeObserver(this)
        }, r.setOptions = function(i, s) {
            var o = this.options,
                a = this.currentQuery;
            if (this.options = this.client.defaultQueryObserverOptions(i), typeof this.options.enabled != "undefined" && typeof this.options.enabled != "boolean") throw new Error("Expected enabled to be a boolean");
            this.options.queryKey || (this.options.queryKey = o.queryKey), this.updateQuery();
            var c = this.hasListeners();
            c && ag(this.currentQuery, a, this.options, o) && this.executeFetch(), this.updateResult(s), c && (this.currentQuery !== a || this.options.enabled !== o.enabled || this.options.staleTime !== o.staleTime) && this.updateStaleTimeout();
            var d = this.computeRefetchInterval();
            c && (this.currentQuery !== a || this.options.enabled !== o.enabled || d !== this.currentRefetchInterval) && this.updateRefetchInterval(d)
        }, r.getOptimisticResult = function(i) {
            var s = this.client.defaultQueryObserverOptions(i),
                o = this.client.getQueryCache().build(this.client, s);
            return this.createResult(o, s)
        }, r.getCurrentResult = function() {
            return this.currentResult
        }, r.trackResult = function(i, s) {
            var o = this,
                a = {},
                c = function(y) {
                    o.trackedProps.includes(y) || o.trackedProps.push(y)
                };
            return Object.keys(i).forEach(function(d) {
                Object.defineProperty(a, d, {
                    configurable: !1,
                    enumerable: !0,
                    get: function() {
                        return c(d), i[d]
                    }
                })
            }), (s.useErrorBoundary || s.suspense) && c("error"), a
        }, r.getNextResult = function(i) {
            var s = this;
            return new Promise(function(o, a) {
                var c = s.subscribe(function(d) {
                    d.isFetching || (c(), d.isError && (i == null ? void 0 : i.throwOnError) ? a(d.error) : o(d))
                })
            })
        }, r.getCurrentQuery = function() {
            return this.currentQuery
        }, r.remove = function() {
            this.client.getQueryCache().remove(this.currentQuery)
        }, r.refetch = function(i) {
            return this.fetch(_t({}, i, {
                meta: {
                    refetchPage: i == null ? void 0 : i.refetchPage
                }
            }))
        }, r.fetchOptimistic = function(i) {
            var s = this,
                o = this.client.defaultQueryObserverOptions(i),
                a = this.client.getQueryCache().build(this.client, o);
            return a.fetch().then(function() {
                return s.createResult(a, o)
            })
        }, r.fetch = function(i) {
            var s = this;
            return this.executeFetch(i).then(function() {
                return s.updateResult(), s.currentResult
            })
        }, r.executeFetch = function(i) {
            this.updateQuery();
            var s = this.currentQuery.fetch(this.options, i);
            return i != null && i.throwOnError || (s = s.catch(Gr)), s
        }, r.updateStaleTimeout = function() {
            var i = this;
            if (this.clearStaleTimeout(), !(Ac || this.currentResult.isStale || !rp(this.options.staleTime))) {
                var s = r3(this.currentResult.dataUpdatedAt, this.options.staleTime),
                    o = s + 1;
                this.staleTimeoutId = setTimeout(function() {
                    i.currentResult.isStale || i.updateResult()
                }, o)
            }
        }, r.computeRefetchInterval = function() {
            var i;
            return typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (i = this.options.refetchInterval) != null ? i : !1
        }, r.updateRefetchInterval = function(i) {
            var s = this;
            this.clearRefetchInterval(), this.currentRefetchInterval = i, !(Ac || this.options.enabled === !1 || !rp(this.currentRefetchInterval) || this.currentRefetchInterval === 0) && (this.refetchIntervalId = setInterval(function() {
                (s.options.refetchIntervalInBackground || Gu.isFocused()) && s.executeFetch()
            }, this.currentRefetchInterval))
        }, r.updateTimers = function() {
            this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval())
        }, r.clearTimers = function() {
            this.clearStaleTimeout(), this.clearRefetchInterval()
        }, r.clearStaleTimeout = function() {
            clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0
        }, r.clearRefetchInterval = function() {
            clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0
        }, r.createResult = function(i, s) {
            var o = this.currentQuery,
                a = this.options,
                c = this.currentResult,
                d = this.currentResultState,
                y = this.currentResultOptions,
                I = i !== o,
                N = I ? i.state : this.currentQueryInitialState,
                E = I ? this.currentResult : this.previousQueryResult,
                T = i.state,
                j = T.dataUpdatedAt,
                V = T.error,
                P = T.errorUpdatedAt,
                O = T.isFetching,
                R = T.status,
                q = !1,
                W = !1,
                Y;
            if (s.optimisticResults) {
                var G = this.hasListeners(),
                    J = !G && og(i, s),
                    pe = G && ag(i, o, s, a);
                (J || pe) && (O = !0, j || (R = "loading"))
            }
            if (s.keepPreviousData && !T.dataUpdateCount && (E == null ? void 0 : E.isSuccess) && R !== "error") Y = E.data, j = E.dataUpdatedAt, R = E.status, q = !0;
            else if (s.select && typeof T.data != "undefined")
                if (c && T.data === (d == null ? void 0 : d.data) && s.select === this.selectFn) Y = this.selectResult;
                else try {
                    this.selectFn = s.select, Y = s.select(T.data), s.structuralSharing !== !1 && (Y = Ec(c == null ? void 0 : c.data, Y)), this.selectResult = Y, this.selectError = null
                } catch (w) {
                    Ic().error(w), this.selectError = w
                } else Y = T.data;
            if (typeof s.placeholderData != "undefined" && typeof Y == "undefined" && (R === "loading" || R === "idle")) {
                var we;
                if ((c == null ? void 0 : c.isPlaceholderData) && s.placeholderData === (y == null ? void 0 : y.placeholderData)) we = c.data;
                else if (we = typeof s.placeholderData == "function" ? s.placeholderData() : s.placeholderData, s.select && typeof we != "undefined") try {
                    we = s.select(we), s.structuralSharing !== !1 && (we = Ec(c == null ? void 0 : c.data, we)), this.selectError = null
                } catch (w) {
                    Ic().error(w), this.selectError = w
                }
                typeof we != "undefined" && (R = "success", Y = we, W = !0)
            }
            this.selectError && (V = this.selectError, Y = this.selectResult, P = Date.now(), R = "error");
            var H = {
                status: R,
                isLoading: R === "loading",
                isSuccess: R === "success",
                isError: R === "error",
                isIdle: R === "idle",
                data: Y,
                dataUpdatedAt: j,
                error: V,
                errorUpdatedAt: P,
                failureCount: T.fetchFailureCount,
                errorUpdateCount: T.errorUpdateCount,
                isFetched: T.dataUpdateCount > 0 || T.errorUpdateCount > 0,
                isFetchedAfterMount: T.dataUpdateCount > N.dataUpdateCount || T.errorUpdateCount > N.errorUpdateCount,
                isFetching: O,
                isRefetching: O && R !== "loading",
                isLoadingError: R === "error" && T.dataUpdatedAt === 0,
                isPlaceholderData: W,
                isPreviousData: q,
                isRefetchError: R === "error" && T.dataUpdatedAt !== 0,
                isStale: F1(i, s),
                refetch: this.refetch,
                remove: this.remove
            };
            return H
        }, r.shouldNotifyListeners = function(i, s) {
            if (!s) return !0;
            var o = this.options,
                a = o.notifyOnChangeProps,
                c = o.notifyOnChangePropsExclusions;
            if (!a && !c || a === "tracked" && !this.trackedProps.length) return !0;
            var d = a === "tracked" ? this.trackedProps : a;
            return Object.keys(i).some(function(y) {
                var I = y,
                    N = i[I] !== s[I],
                    E = d == null ? void 0 : d.some(function(j) {
                        return j === y
                    }),
                    T = c == null ? void 0 : c.some(function(j) {
                        return j === y
                    });
                return N && !T && (!d || E)
            })
        }, r.updateResult = function(i) {
            var s = this.currentResult;
            if (this.currentResult = this.createResult(this.currentQuery, this.options), this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, !SC(this.currentResult, s)) {
                var o = {
                    cache: !0
                };
                (i == null ? void 0 : i.listeners) !== !1 && this.shouldNotifyListeners(this.currentResult, s) && (o.listeners = !0), this.notify(_t({}, o, i))
            }
        }, r.updateQuery = function() {
            var i = this.client.getQueryCache().build(this.client, this.options);
            if (i !== this.currentQuery) {
                var s = this.currentQuery;
                this.currentQuery = i, this.currentQueryInitialState = i.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (s == null || s.removeObserver(this), i.addObserver(this))
            }
        }, r.onQueryUpdate = function(i) {
            var s = {};
            i.type === "success" ? s.onSuccess = !0 : i.type === "error" && !Lf(i.error) && (s.onError = !0), this.updateResult(s), this.hasListeners() && this.updateTimers()
        }, r.notify = function(i) {
            var s = this;
            dr.batch(function() {
                i.onSuccess ? (s.options.onSuccess == null || s.options.onSuccess(s.currentResult.data), s.options.onSettled == null || s.options.onSettled(s.currentResult.data, null)) : i.onError && (s.options.onError == null || s.options.onError(s.currentResult.error), s.options.onSettled == null || s.options.onSettled(void 0, s.currentResult.error)), i.listeners && s.listeners.forEach(function(o) {
                    o(s.currentResult)
                }), i.cache && s.client.getQueryCache().notify({
                    query: s.currentQuery,
                    type: "observerResultsUpdated"
                })
            })
        }, e
    }(ru);

function UC(t, e) {
    return e.enabled !== !1 && !t.state.dataUpdatedAt && !(t.state.status === "error" && e.retryOnMount === !1)
}

function og(t, e) {
    return UC(t, e) || t.state.dataUpdatedAt > 0 && ip(t, e, e.refetchOnMount)
}

function ip(t, e, r) {
    if (e.enabled !== !1) {
        var n = typeof r == "function" ? r(t) : r;
        return n === "always" || n !== !1 && F1(t, e)
    }
    return !1
}

function ag(t, e, r, n) {
    return r.enabled !== !1 && (t !== e || n.enabled === !1) && (!r.suspense || t.state.status !== "error") && F1(t, r)
}

function F1(t, e) {
    return t.isStaleByTime(e.staleTime)
}
var zC = function(t) {
        tu(e, t);

        function e(n, i) {
            var s;
            return s = t.call(this) || this, s.client = n, s.setOptions(i), s.bindMethods(), s.updateResult(), s
        }
        var r = e.prototype;
        return r.bindMethods = function() {
            this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this)
        }, r.setOptions = function(i) {
            this.options = this.client.defaultMutationOptions(i)
        }, r.onUnsubscribe = function() {
            if (!this.listeners.length) {
                var i;
                (i = this.currentMutation) == null || i.removeObserver(this)
            }
        }, r.onMutationUpdate = function(i) {
            this.updateResult();
            var s = {
                listeners: !0
            };
            i.type === "success" ? s.onSuccess = !0 : i.type === "error" && (s.onError = !0), this.notify(s)
        }, r.getCurrentResult = function() {
            return this.currentResult
        }, r.reset = function() {
            this.currentMutation = void 0, this.updateResult(), this.notify({
                listeners: !0
            })
        }, r.mutate = function(i, s) {
            return this.mutateOptions = s, this.currentMutation && this.currentMutation.removeObserver(this), this.currentMutation = this.client.getMutationCache().build(this.client, _t({}, this.options, {
                variables: typeof i != "undefined" ? i : this.options.variables
            })), this.currentMutation.addObserver(this), this.currentMutation.execute()
        }, r.updateResult = function() {
            var i = this.currentMutation ? this.currentMutation.state : u3(),
                s = _t({}, i, {
                    isLoading: i.status === "loading",
                    isSuccess: i.status === "success",
                    isError: i.status === "error",
                    isIdle: i.status === "idle",
                    mutate: this.mutate,
                    reset: this.reset
                });
            this.currentResult = s
        }, r.notify = function(i) {
            var s = this;
            dr.batch(function() {
                s.mutateOptions && (i.onSuccess ? (s.mutateOptions.onSuccess == null || s.mutateOptions.onSuccess(s.currentResult.data, s.currentResult.variables, s.currentResult.context), s.mutateOptions.onSettled == null || s.mutateOptions.onSettled(s.currentResult.data, null, s.currentResult.variables, s.currentResult.context)) : i.onError && (s.mutateOptions.onError == null || s.mutateOptions.onError(s.currentResult.error, s.currentResult.variables, s.currentResult.context), s.mutateOptions.onSettled == null || s.mutateOptions.onSettled(void 0, s.currentResult.error, s.currentResult.variables, s.currentResult.context))), i.listeners && s.listeners.forEach(function(o) {
                    o(s.currentResult)
                })
            })
        }, e
    }(ru),
    jC = Gb.unstable_batchedUpdates;
dr.setBatchNotifyFunction(jC);
var $C = console;
BC($C);
var ug = Qe.createContext(void 0),
    l3 = Qe.createContext(!1);

function f3(t) {
    return t && typeof window != "undefined" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = ug), window.ReactQueryClientContext) : ug
}
var c3 = function() {
        var e = Qe.useContext(f3(Qe.useContext(l3)));
        if (!e) throw new Error("No QueryClient set, use QueryClientProvider to set one");
        return e
    },
    HC = function(e) {
        var r = e.client,
            n = e.contextSharing,
            i = n === void 0 ? !1 : n,
            s = e.children;
        Qe.useEffect(function() {
            return r.mount(),
                function() {
                    r.unmount()
                }
        }, [r]);
        var o = f3(i);
        return Qe.createElement(l3.Provider, {
            value: i
        }, Qe.createElement(o.Provider, {
            value: r
        }, s))
    };

function QC() {
    var t = !1;
    return {
        clearReset: function() {
            t = !1
        },
        reset: function() {
            t = !0
        },
        isReset: function() {
            return t
        }
    }
}
var qC = Qe.createContext(QC()),
    WC = function() {
        return Qe.useContext(qC)
    };

function h3(t, e, r) {
    return typeof e == "function" ? e.apply(void 0, r) : typeof e == "boolean" ? e : !!t
}

function lg(t, e, r) {
    var n = Qe.useRef(!1),
        i = Qe.useState(0),
        s = i[1],
        o = xC(t, e, r),
        a = c3(),
        c = Qe.useRef();
    c.current ? c.current.setOptions(o) : c.current = new zC(a, o);
    var d = c.current.getCurrentResult();
    Qe.useEffect(function() {
        n.current = !0;
        var I = c.current.subscribe(dr.batchCalls(function() {
            n.current && s(function(N) {
                return N + 1
            })
        }));
        return function() {
            n.current = !1, I()
        }
    }, []);
    var y = Qe.useCallback(function(I, N) {
        c.current.mutate(I, N).catch(Gr)
    }, []);
    if (d.error && h3(void 0, c.current.options.useErrorBoundary, [d.error])) throw d.error;
    return _t({}, d, {
        mutate: y,
        mutateAsync: d.mutate
    })
}

function VC(t, e) {
    var r = Qe.useRef(!1),
        n = Qe.useState(0),
        i = n[1],
        s = c3(),
        o = WC(),
        a = s.defaultQueryObserverOptions(t);
    a.optimisticResults = !0, a.onError && (a.onError = dr.batchCalls(a.onError)), a.onSuccess && (a.onSuccess = dr.batchCalls(a.onSuccess)), a.onSettled && (a.onSettled = dr.batchCalls(a.onSettled)), a.suspense && (typeof a.staleTime != "number" && (a.staleTime = 1e3), a.cacheTime === 0 && (a.cacheTime = 1)), (a.suspense || a.useErrorBoundary) && (o.isReset() || (a.retryOnMount = !1));
    var c = Qe.useState(function() {
            return new e(s, a)
        }),
        d = c[0],
        y = d.getOptimisticResult(a);
    if (Qe.useEffect(function() {
            r.current = !0, o.clearReset();
            var I = d.subscribe(dr.batchCalls(function() {
                r.current && i(function(N) {
                    return N + 1
                })
            }));
            return d.updateResult(),
                function() {
                    r.current = !1, I()
                }
        }, [o, d]), Qe.useEffect(function() {
            d.setOptions(a, {
                listeners: !1
            })
        }, [a, d]), a.suspense && y.isLoading) throw d.fetchOptimistic(a).then(function(I) {
        var N = I.data;
        a.onSuccess == null || a.onSuccess(N), a.onSettled == null || a.onSettled(N, null)
    }).catch(function(I) {
        o.clearReset(), a.onError == null || a.onError(I), a.onSettled == null || a.onSettled(void 0, I)
    });
    if (y.isError && !o.isReset() && !y.isFetching && h3(a.suspense, a.useErrorBoundary, [y.error, d.getCurrentQuery()])) throw y.error;
    return a.notifyOnChangeProps === "tracked" && (y = d.trackResult(y, a)), y
}

function GC(t, e, r) {
    var n = Df(t, e, r);
    return VC(n, FC)
}
var U1 = {
        exports: {}
    },
    d3 = function(e, r) {
        return function() {
            for (var i = new Array(arguments.length), s = 0; s < i.length; s++) i[s] = arguments[s];
            return e.apply(r, i)
        }
    },
    YC = d3,
    z1 = Object.prototype.toString,
    j1 = function(t) {
        return function(e) {
            var r = z1.call(e);
            return t[r] || (t[r] = r.slice(8, -1).toLowerCase())
        }
    }(Object.create(null));

function $o(t) {
    return t = t.toLowerCase(),
        function(r) {
            return j1(r) === t
        }
}

function $1(t) {
    return Array.isArray(t)
}

function Cc(t) {
    return typeof t == "undefined"
}

function KC(t) {
    return t !== null && !Cc(t) && t.constructor !== null && !Cc(t.constructor) && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t)
}
var p3 = $o("ArrayBuffer");

function ZC(t) {
    var e;
    return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && p3(t.buffer), e
}

function JC(t) {
    return typeof t == "string"
}

function XC(t) {
    return typeof t == "number"
}

function m3(t) {
    return t !== null && typeof t == "object"
}

function Ff(t) {
    if (j1(t) !== "object") return !1;
    var e = Object.getPrototypeOf(t);
    return e === null || e === Object.prototype
}
var eB = $o("Date"),
    tB = $o("File"),
    rB = $o("Blob"),
    nB = $o("FileList");

function H1(t) {
    return z1.call(t) === "[object Function]"
}

function iB(t) {
    return m3(t) && H1(t.pipe)
}

function sB(t) {
    var e = "[object FormData]";
    return t && (typeof FormData == "function" && t instanceof FormData || z1.call(t) === e || H1(t.toString) && t.toString() === e)
}
var oB = $o("URLSearchParams");

function aB(t) {
    return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
}

function uB() {
    return typeof navigator != "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window != "undefined" && typeof document != "undefined"
}

function Q1(t, e) {
    if (!(t === null || typeof t == "undefined"))
        if (typeof t != "object" && (t = [t]), $1(t))
            for (var r = 0, n = t.length; r < n; r++) e.call(null, t[r], r, t);
        else
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.call(null, t[i], i, t)
}

function sp() {
    var t = {};

    function e(i, s) {
        Ff(t[s]) && Ff(i) ? t[s] = sp(t[s], i) : Ff(i) ? t[s] = sp({}, i) : $1(i) ? t[s] = i.slice() : t[s] = i
    }
    for (var r = 0, n = arguments.length; r < n; r++) Q1(arguments[r], e);
    return t
}

function lB(t, e, r) {
    return Q1(e, function(i, s) {
        r && typeof i == "function" ? t[s] = YC(i, r) : t[s] = i
    }), t
}

function fB(t) {
    return t.charCodeAt(0) === 65279 && (t = t.slice(1)), t
}

function cB(t, e, r, n) {
    t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, r && Object.assign(t.prototype, r)
}

function hB(t, e, r) {
    var n, i, s, o = {};
    e = e || {};
    do {
        for (n = Object.getOwnPropertyNames(t), i = n.length; i-- > 0;) s = n[i], o[s] || (e[s] = t[s], o[s] = !0);
        t = Object.getPrototypeOf(t)
    } while (t && (!r || r(t, e)) && t !== Object.prototype);
    return e
}

function dB(t, e, r) {
    t = String(t), (r === void 0 || r > t.length) && (r = t.length), r -= e.length;
    var n = t.indexOf(e, r);
    return n !== -1 && n === r
}

function pB(t) {
    if (!t) return null;
    var e = t.length;
    if (Cc(e)) return null;
    for (var r = new Array(e); e-- > 0;) r[e] = t[e];
    return r
}
var mB = function(t) {
        return function(e) {
            return t && e instanceof t
        }
    }(typeof Uint8Array != "undefined" && Object.getPrototypeOf(Uint8Array)),
    tn = {
        isArray: $1,
        isArrayBuffer: p3,
        isBuffer: KC,
        isFormData: sB,
        isArrayBufferView: ZC,
        isString: JC,
        isNumber: XC,
        isObject: m3,
        isPlainObject: Ff,
        isUndefined: Cc,
        isDate: eB,
        isFile: tB,
        isBlob: rB,
        isFunction: H1,
        isStream: iB,
        isURLSearchParams: oB,
        isStandardBrowserEnv: uB,
        forEach: Q1,
        merge: sp,
        extend: lB,
        trim: aB,
        stripBOM: fB,
        inherits: cB,
        toFlatObject: hB,
        kindOf: j1,
        kindOfTest: $o,
        endsWith: dB,
        toArray: pB,
        isTypedArray: mB,
        isFileList: nB
    },
    Wo = tn;

function fg(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
var v3 = function(e, r, n) {
        if (!r) return e;
        var i;
        if (n) i = n(r);
        else if (Wo.isURLSearchParams(r)) i = r.toString();
        else {
            var s = [];
            Wo.forEach(r, function(c, d) {
                c === null || typeof c == "undefined" || (Wo.isArray(c) ? d = d + "[]" : c = [c], Wo.forEach(c, function(I) {
                    Wo.isDate(I) ? I = I.toISOString() : Wo.isObject(I) && (I = JSON.stringify(I)), s.push(fg(d) + "=" + fg(I))
                }))
            }), i = s.join("&")
        }
        if (i) {
            var o = e.indexOf("#");
            o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + i
        }
        return e
    },
    vB = tn;

function Bh() {
    this.handlers = []
}
Bh.prototype.use = function(e, r, n) {
    return this.handlers.push({
        fulfilled: e,
        rejected: r,
        synchronous: n ? n.synchronous : !1,
        runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1
};
Bh.prototype.eject = function(e) {
    this.handlers[e] && (this.handlers[e] = null)
};
Bh.prototype.forEach = function(e) {
    vB.forEach(this.handlers, function(n) {
        n !== null && e(n)
    })
};
var gB = Bh,
    yB = tn,
    wB = function(e, r) {
        yB.forEach(e, function(i, s) {
            s !== r && s.toUpperCase() === r.toUpperCase() && (e[r] = i, delete e[s])
        })
    },
    g3 = tn;

function Pa(t, e, r, n, i) {
    Error.call(this), this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), n && (this.request = n), i && (this.response = i)
}
g3.inherits(Pa, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        }
    }
});
var y3 = Pa.prototype,
    w3 = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(t) {
    w3[t] = {
        value: t
    }
});
Object.defineProperties(Pa, w3);
Object.defineProperty(y3, "isAxiosError", {
    value: !0
});
Pa.from = function(t, e, r, n, i, s) {
    var o = Object.create(y3);
    return g3.toFlatObject(t, o, function(c) {
        return c !== Error.prototype
    }), Pa.call(o, t.message, e, r, n, i), o.name = t.name, s && Object.assign(o, s), o
};
var nu = Pa,
    x3 = {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
    },
    mi = tn;

function xB(t, e) {
    e = e || new FormData;
    var r = [];

    function n(s) {
        return s === null ? "" : mi.isDate(s) ? s.toISOString() : mi.isArrayBuffer(s) || mi.isTypedArray(s) ? typeof Blob == "function" ? new Blob([s]) : Buffer.from(s) : s
    }

    function i(s, o) {
        if (mi.isPlainObject(s) || mi.isArray(s)) {
            if (r.indexOf(s) !== -1) throw Error("Circular reference detected in " + o);
            r.push(s), mi.forEach(s, function(c, d) {
                if (!mi.isUndefined(c)) {
                    var y = o ? o + "." + d : d,
                        I;
                    if (c && !o && typeof c == "object") {
                        if (mi.endsWith(d, "{}")) c = JSON.stringify(c);
                        else if (mi.endsWith(d, "[]") && (I = mi.toArray(c))) {
                            I.forEach(function(N) {
                                !mi.isUndefined(N) && e.append(y, n(N))
                            });
                            return
                        }
                    }
                    i(c, y)
                }
            }), r.pop()
        } else e.append(o, n(s))
    }
    return i(t), e
}
var b3 = xB,
    O0 = nu,
    bB = function(e, r, n) {
        var i = n.config.validateStatus;
        !n.status || !i || i(n.status) ? e(n) : r(new O0("Request failed with status code " + n.status, [O0.ERR_BAD_REQUEST, O0.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n))
    },
    df = tn,
    AB = df.isStandardBrowserEnv() ? function() {
        return {
            write: function(r, n, i, s, o, a) {
                var c = [];
                c.push(r + "=" + encodeURIComponent(n)), df.isNumber(i) && c.push("expires=" + new Date(i).toGMTString()), df.isString(s) && c.push("path=" + s), df.isString(o) && c.push("domain=" + o), a === !0 && c.push("secure"), document.cookie = c.join("; ")
            },
            read: function(r) {
                var n = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
                return n ? decodeURIComponent(n[3]) : null
            },
            remove: function(r) {
                this.write(r, "", Date.now() - 864e5)
            }
        }
    }() : function() {
        return {
            write: function() {},
            read: function() {
                return null
            },
            remove: function() {}
        }
    }(),
    SB = function(e) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
    },
    MB = function(e, r) {
        return r ? e.replace(/\/+$/, "") + "/" + r.replace(/^\/+/, "") : e
    },
    EB = SB,
    _B = MB,
    A3 = function(e, r) {
        return e && !EB(r) ? _B(e, r) : r
    },
    R0 = tn,
    IB = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"],
    CB = function(e) {
        var r = {},
            n, i, s;
        return e && R0.forEach(e.split(`
`), function(a) {
            if (s = a.indexOf(":"), n = R0.trim(a.substr(0, s)).toLowerCase(), i = R0.trim(a.substr(s + 1)), n) {
                if (r[n] && IB.indexOf(n) >= 0) return;
                n === "set-cookie" ? r[n] = (r[n] ? r[n] : []).concat([i]) : r[n] = r[n] ? r[n] + ", " + i : i
            }
        }), r
    },
    cg = tn,
    BB = cg.isStandardBrowserEnv() ? function() {
        var e = /(msie|trident)/i.test(navigator.userAgent),
            r = document.createElement("a"),
            n;

        function i(s) {
            var o = s;
            return e && (r.setAttribute("href", o), o = r.href), r.setAttribute("href", o), {
                href: r.href,
                protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
                host: r.host,
                search: r.search ? r.search.replace(/^\?/, "") : "",
                hash: r.hash ? r.hash.replace(/^#/, "") : "",
                hostname: r.hostname,
                port: r.port,
                pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
            }
        }
        return n = i(window.location.href),
            function(o) {
                var a = cg.isString(o) ? i(o) : o;
                return a.protocol === n.protocol && a.host === n.host
            }
    }() : function() {
        return function() {
            return !0
        }
    }(),
    op = nu,
    kB = tn;

function S3(t) {
    op.call(this, t == null ? "canceled" : t, op.ERR_CANCELED), this.name = "CanceledError"
}
kB.inherits(S3, op, {
    __CANCEL__: !0
});
var kh = S3,
    NB = function(e) {
        var r = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
        return r && r[1] || ""
    },
    Su = tn,
    TB = bB,
    OB = AB,
    RB = v3,
    DB = A3,
    PB = CB,
    LB = BB,
    FB = x3,
    is = nu,
    UB = kh,
    zB = NB,
    hg = function(e) {
        return new Promise(function(n, i) {
            var s = e.data,
                o = e.headers,
                a = e.responseType,
                c;

            function d() {
                e.cancelToken && e.cancelToken.unsubscribe(c), e.signal && e.signal.removeEventListener("abort", c)
            }
            Su.isFormData(s) && Su.isStandardBrowserEnv() && delete o["Content-Type"];
            var y = new XMLHttpRequest;
            if (e.auth) {
                var I = e.auth.username || "",
                    N = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
                o.Authorization = "Basic " + btoa(I + ":" + N)
            }
            var E = DB(e.baseURL, e.url);
            y.open(e.method.toUpperCase(), RB(E, e.params, e.paramsSerializer), !0), y.timeout = e.timeout;

            function T() {
                if (!!y) {
                    var P = "getAllResponseHeaders" in y ? PB(y.getAllResponseHeaders()) : null,
                        O = !a || a === "text" || a === "json" ? y.responseText : y.response,
                        R = {
                            data: O,
                            status: y.status,
                            statusText: y.statusText,
                            headers: P,
                            config: e,
                            request: y
                        };
                    TB(function(W) {
                        n(W), d()
                    }, function(W) {
                        i(W), d()
                    }, R), y = null
                }
            }
            if ("onloadend" in y ? y.onloadend = T : y.onreadystatechange = function() {
                    !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf("file:") === 0) || setTimeout(T)
                }, y.onabort = function() {
                    !y || (i(new is("Request aborted", is.ECONNABORTED, e, y)), y = null)
                }, y.onerror = function() {
                    i(new is("Network Error", is.ERR_NETWORK, e, y, y)), y = null
                }, y.ontimeout = function() {
                    var O = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded",
                        R = e.transitional || FB;
                    e.timeoutErrorMessage && (O = e.timeoutErrorMessage), i(new is(O, R.clarifyTimeoutError ? is.ETIMEDOUT : is.ECONNABORTED, e, y)), y = null
                }, Su.isStandardBrowserEnv()) {
                var j = (e.withCredentials || LB(E)) && e.xsrfCookieName ? OB.read(e.xsrfCookieName) : void 0;
                j && (o[e.xsrfHeaderName] = j)
            }
            "setRequestHeader" in y && Su.forEach(o, function(O, R) {
                typeof s == "undefined" && R.toLowerCase() === "content-type" ? delete o[R] : y.setRequestHeader(R, O)
            }), Su.isUndefined(e.withCredentials) || (y.withCredentials = !!e.withCredentials), a && a !== "json" && (y.responseType = e.responseType), typeof e.onDownloadProgress == "function" && y.addEventListener("progress", e.onDownloadProgress), typeof e.onUploadProgress == "function" && y.upload && y.upload.addEventListener("progress", e.onUploadProgress), (e.cancelToken || e.signal) && (c = function(P) {
                !y || (i(!P || P && P.type ? new UB : P), y.abort(), y = null)
            }, e.cancelToken && e.cancelToken.subscribe(c), e.signal && (e.signal.aborted ? c() : e.signal.addEventListener("abort", c))), s || (s = null);
            var V = zB(E);
            if (V && ["http", "https", "file"].indexOf(V) === -1) {
                i(new is("Unsupported protocol " + V + ":", is.ERR_BAD_REQUEST, e));
                return
            }
            y.send(s)
        })
    },
    jB = null,
    Ur = tn,
    dg = wB,
    pg = nu,
    $B = x3,
    HB = b3,
    QB = {
        "Content-Type": "application/x-www-form-urlencoded"
    };

function mg(t, e) {
    !Ur.isUndefined(t) && Ur.isUndefined(t["Content-Type"]) && (t["Content-Type"] = e)
}

function qB() {
    var t;
    return (typeof XMLHttpRequest != "undefined" || typeof process != "undefined" && Object.prototype.toString.call(process) === "[object process]") && (t = hg), t
}

function WB(t, e, r) {
    if (Ur.isString(t)) try {
        return (e || JSON.parse)(t), Ur.trim(t)
    } catch (n) {
        if (n.name !== "SyntaxError") throw n
    }
    return (r || JSON.stringify)(t)
}
var Nh = {
    transitional: $B,
    adapter: qB(),
    transformRequest: [function(e, r) {
        if (dg(r, "Accept"), dg(r, "Content-Type"), Ur.isFormData(e) || Ur.isArrayBuffer(e) || Ur.isBuffer(e) || Ur.isStream(e) || Ur.isFile(e) || Ur.isBlob(e)) return e;
        if (Ur.isArrayBufferView(e)) return e.buffer;
        if (Ur.isURLSearchParams(e)) return mg(r, "application/x-www-form-urlencoded;charset=utf-8"), e.toString();
        var n = Ur.isObject(e),
            i = r && r["Content-Type"],
            s;
        if ((s = Ur.isFileList(e)) || n && i === "multipart/form-data") {
            var o = this.env && this.env.FormData;
            return HB(s ? {
                "files[]": e
            } : e, o && new o)
        } else if (n || i === "application/json") return mg(r, "application/json"), WB(e);
        return e
    }],
    transformResponse: [function(e) {
        var r = this.transitional || Nh.transitional,
            n = r && r.silentJSONParsing,
            i = r && r.forcedJSONParsing,
            s = !n && this.responseType === "json";
        if (s || i && Ur.isString(e) && e.length) try {
            return JSON.parse(e)
        } catch (o) {
            if (s) throw o.name === "SyntaxError" ? pg.from(o, pg.ERR_BAD_RESPONSE, this, null, this.response) : o
        }
        return e
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: jB
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*"
        }
    }
};
Ur.forEach(["delete", "get", "head"], function(e) {
    Nh.headers[e] = {}
});
Ur.forEach(["post", "put", "patch"], function(e) {
    Nh.headers[e] = Ur.merge(QB)
});
var q1 = Nh,
    VB = tn,
    GB = q1,
    YB = function(e, r, n) {
        var i = this || GB;
        return VB.forEach(n, function(o) {
            e = o.call(i, e, r)
        }), e
    },
    M3 = function(e) {
        return !!(e && e.__CANCEL__)
    },
    vg = tn,
    D0 = YB,
    KB = M3,
    ZB = q1,
    JB = kh;

function P0(t) {
    if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new JB
}
var XB = function(e) {
        P0(e), e.headers = e.headers || {}, e.data = D0.call(e, e.data, e.headers, e.transformRequest), e.headers = vg.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers), vg.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(i) {
            delete e.headers[i]
        });
        var r = e.adapter || ZB.adapter;
        return r(e).then(function(i) {
            return P0(e), i.data = D0.call(e, i.data, i.headers, e.transformResponse), i
        }, function(i) {
            return KB(i) || (P0(e), i && i.response && (i.response.data = D0.call(e, i.response.data, i.response.headers, e.transformResponse))), Promise.reject(i)
        })
    },
    Rn = tn,
    E3 = function(e, r) {
        r = r || {};
        var n = {};

        function i(y, I) {
            return Rn.isPlainObject(y) && Rn.isPlainObject(I) ? Rn.merge(y, I) : Rn.isPlainObject(I) ? Rn.merge({}, I) : Rn.isArray(I) ? I.slice() : I
        }

        function s(y) {
            if (Rn.isUndefined(r[y])) {
                if (!Rn.isUndefined(e[y])) return i(void 0, e[y])
            } else return i(e[y], r[y])
        }

        function o(y) {
            if (!Rn.isUndefined(r[y])) return i(void 0, r[y])
        }

        function a(y) {
            if (Rn.isUndefined(r[y])) {
                if (!Rn.isUndefined(e[y])) return i(void 0, e[y])
            } else return i(void 0, r[y])
        }

        function c(y) {
            if (y in r) return i(e[y], r[y]);
            if (y in e) return i(void 0, e[y])
        }
        var d = {
            url: o,
            method: o,
            data: o,
            baseURL: a,
            transformRequest: a,
            transformResponse: a,
            paramsSerializer: a,
            timeout: a,
            timeoutMessage: a,
            withCredentials: a,
            adapter: a,
            responseType: a,
            xsrfCookieName: a,
            xsrfHeaderName: a,
            onUploadProgress: a,
            onDownloadProgress: a,
            decompress: a,
            maxContentLength: a,
            maxBodyLength: a,
            beforeRedirect: a,
            transport: a,
            httpAgent: a,
            httpsAgent: a,
            cancelToken: a,
            socketPath: a,
            responseEncoding: a,
            validateStatus: c
        };
        return Rn.forEach(Object.keys(e).concat(Object.keys(r)), function(I) {
            var N = d[I] || s,
                E = N(I);
            Rn.isUndefined(E) && N !== c || (n[I] = E)
        }), n
    },
    _3 = {
        version: "0.27.2"
    },
    ek = _3.version,
    Os = nu,
    W1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(t, e) {
    W1[t] = function(n) {
        return typeof n === t || "a" + (e < 1 ? "n " : " ") + t
    }
});
var gg = {};
W1.transitional = function(e, r, n) {
    function i(s, o) {
        return "[Axios v" + ek + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "")
    }
    return function(s, o, a) {
        if (e === !1) throw new Os(i(o, " has been removed" + (r ? " in " + r : "")), Os.ERR_DEPRECATED);
        return r && !gg[o] && (gg[o] = !0, console.warn(i(o, " has been deprecated since v" + r + " and will be removed in the near future"))), e ? e(s, o, a) : !0
    }
};

function tk(t, e, r) {
    if (typeof t != "object") throw new Os("options must be an object", Os.ERR_BAD_OPTION_VALUE);
    for (var n = Object.keys(t), i = n.length; i-- > 0;) {
        var s = n[i],
            o = e[s];
        if (o) {
            var a = t[s],
                c = a === void 0 || o(a, s, t);
            if (c !== !0) throw new Os("option " + s + " must be " + c, Os.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (r !== !0) throw new Os("Unknown option " + s, Os.ERR_BAD_OPTION)
    }
}
var rk = {
        assertOptions: tk,
        validators: W1
    },
    I3 = tn,
    nk = v3,
    yg = gB,
    wg = XB,
    Th = E3,
    ik = A3,
    C3 = rk,
    Vo = C3.validators;

function La(t) {
    this.defaults = t, this.interceptors = {
        request: new yg,
        response: new yg
    }
}
La.prototype.request = function(e, r) {
    typeof e == "string" ? (r = r || {}, r.url = e) : r = e || {}, r = Th(this.defaults, r), r.method ? r.method = r.method.toLowerCase() : this.defaults.method ? r.method = this.defaults.method.toLowerCase() : r.method = "get";
    var n = r.transitional;
    n !== void 0 && C3.assertOptions(n, {
        silentJSONParsing: Vo.transitional(Vo.boolean),
        forcedJSONParsing: Vo.transitional(Vo.boolean),
        clarifyTimeoutError: Vo.transitional(Vo.boolean)
    }, !1);
    var i = [],
        s = !0;
    this.interceptors.request.forEach(function(E) {
        typeof E.runWhen == "function" && E.runWhen(r) === !1 || (s = s && E.synchronous, i.unshift(E.fulfilled, E.rejected))
    });
    var o = [];
    this.interceptors.response.forEach(function(E) {
        o.push(E.fulfilled, E.rejected)
    });
    var a;
    if (!s) {
        var c = [wg, void 0];
        for (Array.prototype.unshift.apply(c, i), c = c.concat(o), a = Promise.resolve(r); c.length;) a = a.then(c.shift(), c.shift());
        return a
    }
    for (var d = r; i.length;) {
        var y = i.shift(),
            I = i.shift();
        try {
            d = y(d)
        } catch (N) {
            I(N);
            break
        }
    }
    try {
        a = wg(d)
    } catch (N) {
        return Promise.reject(N)
    }
    for (; o.length;) a = a.then(o.shift(), o.shift());
    return a
};
La.prototype.getUri = function(e) {
    e = Th(this.defaults, e);
    var r = ik(e.baseURL, e.url);
    return nk(r, e.params, e.paramsSerializer)
};
I3.forEach(["delete", "get", "head", "options"], function(e) {
    La.prototype[e] = function(r, n) {
        return this.request(Th(n || {}, {
            method: e,
            url: r,
            data: (n || {}).data
        }))
    }
});
I3.forEach(["post", "put", "patch"], function(e) {
    function r(n) {
        return function(s, o, a) {
            return this.request(Th(a || {}, {
                method: e,
                headers: n ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: s,
                data: o
            }))
        }
    }
    La.prototype[e] = r(), La.prototype[e + "Form"] = r(!0)
});
var sk = La,
    ok = kh;

function Fa(t) {
    if (typeof t != "function") throw new TypeError("executor must be a function.");
    var e;
    this.promise = new Promise(function(i) {
        e = i
    });
    var r = this;
    this.promise.then(function(n) {
        if (!!r._listeners) {
            var i, s = r._listeners.length;
            for (i = 0; i < s; i++) r._listeners[i](n);
            r._listeners = null
        }
    }), this.promise.then = function(n) {
        var i, s = new Promise(function(o) {
            r.subscribe(o), i = o
        }).then(n);
        return s.cancel = function() {
            r.unsubscribe(i)
        }, s
    }, t(function(i) {
        r.reason || (r.reason = new ok(i), e(r.reason))
    })
}
Fa.prototype.throwIfRequested = function() {
    if (this.reason) throw this.reason
};
Fa.prototype.subscribe = function(e) {
    if (this.reason) {
        e(this.reason);
        return
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e]
};
Fa.prototype.unsubscribe = function(e) {
    if (!!this._listeners) {
        var r = this._listeners.indexOf(e);
        r !== -1 && this._listeners.splice(r, 1)
    }
};
Fa.source = function() {
    var e, r = new Fa(function(i) {
        e = i
    });
    return {
        token: r,
        cancel: e
    }
};
var ak = Fa,
    uk = function(e) {
        return function(n) {
            return e.apply(null, n)
        }
    },
    lk = tn,
    fk = function(e) {
        return lk.isObject(e) && e.isAxiosError === !0
    },
    xg = tn,
    ck = d3,
    Uf = sk,
    hk = E3,
    dk = q1;

function B3(t) {
    var e = new Uf(t),
        r = ck(Uf.prototype.request, e);
    return xg.extend(r, Uf.prototype, e), xg.extend(r, e), r.create = function(i) {
        return B3(hk(t, i))
    }, r
}
var On = B3(dk);
On.Axios = Uf;
On.CanceledError = kh;
On.CancelToken = ak;
On.isCancel = M3;
On.VERSION = _3.version;
On.toFormData = b3;
On.AxiosError = nu;
On.Cancel = On.CanceledError;
On.all = function(e) {
    return Promise.all(e)
};
On.spread = uk;
On.isAxiosError = fk;
U1.exports = On;
U1.exports.default = On;
var pk = U1.exports;
class Ho extends Error {}
class mk extends Ho {
    constructor(e) {
        super(`Invalid DateTime: ${e.toMessage()}`)
    }
}
class vk extends Ho {
    constructor(e) {
        super(`Invalid Interval: ${e.toMessage()}`)
    }
}
class gk extends Ho {
    constructor(e) {
        super(`Invalid Duration: ${e.toMessage()}`)
    }
}
class Pu extends Ho {}
class k3 extends Ho {
    constructor(e) {
        super(`Invalid unit ${e}`)
    }
}
class ei extends Ho {}
class Cs extends Ho {
    constructor() {
        super("Zone is an abstract class")
    }
}
const De = "numeric",
    ki = "short",
    Un = "long",
    ap = {
        year: De,
        month: De,
        day: De
    },
    N3 = {
        year: De,
        month: ki,
        day: De
    },
    yk = {
        year: De,
        month: ki,
        day: De,
        weekday: ki
    },
    T3 = {
        year: De,
        month: Un,
        day: De
    },
    O3 = {
        year: De,
        month: Un,
        day: De,
        weekday: Un
    },
    R3 = {
        hour: De,
        minute: De
    },
    D3 = {
        hour: De,
        minute: De,
        second: De
    },
    P3 = {
        hour: De,
        minute: De,
        second: De,
        timeZoneName: ki
    },
    L3 = {
        hour: De,
        minute: De,
        second: De,
        timeZoneName: Un
    },
    F3 = {
        hour: De,
        minute: De,
        hourCycle: "h23"
    },
    U3 = {
        hour: De,
        minute: De,
        second: De,
        hourCycle: "h23"
    },
    z3 = {
        hour: De,
        minute: De,
        second: De,
        hourCycle: "h23",
        timeZoneName: ki
    },
    j3 = {
        hour: De,
        minute: De,
        second: De,
        hourCycle: "h23",
        timeZoneName: Un
    },
    $3 = {
        year: De,
        month: De,
        day: De,
        hour: De,
        minute: De
    },
    H3 = {
        year: De,
        month: De,
        day: De,
        hour: De,
        minute: De,
        second: De
    },
    Q3 = {
        year: De,
        month: ki,
        day: De,
        hour: De,
        minute: De
    },
    q3 = {
        year: De,
        month: ki,
        day: De,
        hour: De,
        minute: De,
        second: De
    },
    wk = {
        year: De,
        month: ki,
        day: De,
        weekday: ki,
        hour: De,
        minute: De
    },
    W3 = {
        year: De,
        month: Un,
        day: De,
        hour: De,
        minute: De,
        timeZoneName: ki
    },
    V3 = {
        year: De,
        month: Un,
        day: De,
        hour: De,
        minute: De,
        second: De,
        timeZoneName: ki
    },
    G3 = {
        year: De,
        month: Un,
        day: De,
        weekday: Un,
        hour: De,
        minute: De,
        timeZoneName: Un
    },
    Y3 = {
        year: De,
        month: Un,
        day: De,
        weekday: Un,
        hour: De,
        minute: De,
        second: De,
        timeZoneName: Un
    };

function $t(t) {
    return typeof t == "undefined"
}

function _o(t) {
    return typeof t == "number"
}

function Oh(t) {
    return typeof t == "number" && t % 1 === 0
}

function xk(t) {
    return typeof t == "string"
}

function bk(t) {
    return Object.prototype.toString.call(t) === "[object Date]"
}

function K3() {
    try {
        return typeof Intl != "undefined" && !!Intl.RelativeTimeFormat
    } catch {
        return !1
    }
}

function Ak(t) {
    return Array.isArray(t) ? t : [t]
}

function bg(t, e, r) {
    if (t.length !== 0) return t.reduce((n, i) => {
        const s = [e(i), i];
        return n && r(n[0], s[0]) === n[0] ? n : s
    }, null)[1]
}

function Sk(t, e) {
    return e.reduce((r, n) => (r[n] = t[n], r), {})
}

function Ua(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e)
}

function hs(t, e, r) {
    return Oh(t) && t >= e && t <= r
}

function Mk(t, e) {
    return t - e * Math.floor(t / e)
}

function Br(t, e = 2) {
    const r = t < 0;
    let n;
    return r ? n = "-" + ("" + -t).padStart(e, "0") : n = ("" + t).padStart(e, "0"), n
}

function Rs(t) {
    if (!($t(t) || t === null || t === "")) return parseInt(t, 10)
}

function fo(t) {
    if (!($t(t) || t === null || t === "")) return parseFloat(t)
}

function V1(t) {
    if (!($t(t) || t === null || t === "")) {
        const e = parseFloat("0." + t) * 1e3;
        return Math.floor(e)
    }
}

function G1(t, e, r = !1) {
    const n = 10 ** e;
    return (r ? Math.trunc : Math.round)(t * n) / n
}

function Dl(t) {
    return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0)
}

function Yu(t) {
    return Dl(t) ? 366 : 365
}

function Bc(t, e) {
    const r = Mk(e - 1, 12) + 1,
        n = t + (e - r) / 12;
    return r === 2 ? Dl(n) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][r - 1]
}

function Y1(t) {
    let e = Date.UTC(t.year, t.month - 1, t.day, t.hour, t.minute, t.second, t.millisecond);
    return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(e.getUTCFullYear() - 1900)), +e
}

function kc(t) {
    const e = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7,
        r = t - 1,
        n = (r + Math.floor(r / 4) - Math.floor(r / 100) + Math.floor(r / 400)) % 7;
    return e === 4 || n === 3 ? 53 : 52
}

function up(t) {
    return t > 99 ? t : t > 60 ? 1900 + t : 2e3 + t
}

function Z3(t, e, r, n = null) {
    const i = new Date(t),
        s = {
            hourCycle: "h23",
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit"
        };
    n && (s.timeZone = n);
    const o = Ce({
            timeZoneName: e
        }, s),
        a = new Intl.DateTimeFormat(r, o).formatToParts(i).find(c => c.type.toLowerCase() === "timezonename");
    return a ? a.value : null
}

function Rh(t, e) {
    let r = parseInt(t, 10);
    Number.isNaN(r) && (r = 0);
    const n = parseInt(e, 10) || 0,
        i = r < 0 || Object.is(r, -0) ? -n : n;
    return r * 60 + i
}

function J3(t) {
    const e = Number(t);
    if (typeof t == "boolean" || t === "" || Number.isNaN(e)) throw new ei(`Invalid unit value ${t}`);
    return e
}

function Nc(t, e) {
    const r = {};
    for (const n in t)
        if (Ua(t, n)) {
            const i = t[n];
            if (i == null) continue;
            r[e(n)] = J3(i)
        }
    return r
}

function Ku(t, e) {
    const r = Math.trunc(Math.abs(t / 60)),
        n = Math.trunc(Math.abs(t % 60)),
        i = t >= 0 ? "+" : "-";
    switch (e) {
        case "short":
            return `${i}${Br(r,2)}:${Br(n,2)}`;
        case "narrow":
            return `${i}${r}${n>0?`:${n}`:""}`;
        case "techie":
            return `${i}${Br(r,2)}${Br(n,2)}`;
        default:
            throw new RangeError(`Value format ${e} is out of range for property format`)
    }
}

function Dh(t) {
    return Sk(t, ["hour", "minute", "second", "millisecond"])
}
const X3 = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/,
    Ek = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    e6 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    _k = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];

function t6(t) {
    switch (t) {
        case "narrow":
            return [..._k];
        case "short":
            return [...e6];
        case "long":
            return [...Ek];
        case "numeric":
            return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
            return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
            return null
    }
}
const r6 = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
    n6 = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
    Ik = ["M", "T", "W", "T", "F", "S", "S"];

function i6(t) {
    switch (t) {
        case "narrow":
            return [...Ik];
        case "short":
            return [...n6];
        case "long":
            return [...r6];
        case "numeric":
            return ["1", "2", "3", "4", "5", "6", "7"];
        default:
            return null
    }
}
const s6 = ["AM", "PM"],
    Ck = ["Before Christ", "Anno Domini"],
    Bk = ["BC", "AD"],
    kk = ["B", "A"];

function o6(t) {
    switch (t) {
        case "narrow":
            return [...kk];
        case "short":
            return [...Bk];
        case "long":
            return [...Ck];
        default:
            return null
    }
}

function Nk(t) {
    return s6[t.hour < 12 ? 0 : 1]
}

function Tk(t, e) {
    return i6(e)[t.weekday - 1]
}

function Ok(t, e) {
    return t6(e)[t.month - 1]
}

function Rk(t, e) {
    return o6(e)[t.year < 0 ? 0 : 1]
}

function Dk(t, e, r = "always", n = !1) {
    const i = {
            years: ["year", "yr."],
            quarters: ["quarter", "qtr."],
            months: ["month", "mo."],
            weeks: ["week", "wk."],
            days: ["day", "day", "days"],
            hours: ["hour", "hr."],
            minutes: ["minute", "min."],
            seconds: ["second", "sec."]
        },
        s = ["hours", "minutes", "seconds"].indexOf(t) === -1;
    if (r === "auto" && s) {
        const I = t === "days";
        switch (e) {
            case 1:
                return I ? "tomorrow" : `next ${i[t][0]}`;
            case -1:
                return I ? "yesterday" : `last ${i[t][0]}`;
            case 0:
                return I ? "today" : `this ${i[t][0]}`
        }
    }
    const o = Object.is(e, -0) || e < 0,
        a = Math.abs(e),
        c = a === 1,
        d = i[t],
        y = n ? c ? d[1] : d[2] || d[1] : c ? i[t][0] : t;
    return o ? `${a} ${y} ago` : `in ${a} ${y}`
}

function Ag(t, e) {
    let r = "";
    for (const n of t) n.literal ? r += n.val : r += e(n.val);
    return r
}
const Pk = {
    D: ap,
    DD: N3,
    DDD: T3,
    DDDD: O3,
    t: R3,
    tt: D3,
    ttt: P3,
    tttt: L3,
    T: F3,
    TT: U3,
    TTT: z3,
    TTTT: j3,
    f: $3,
    ff: Q3,
    fff: W3,
    ffff: G3,
    F: H3,
    FF: q3,
    FFF: V3,
    FFFF: Y3
};
class _n {
    static create(e, r = {}) {
        return new _n(e, r)
    }
    static parseFormat(e) {
        let r = null,
            n = "",
            i = !1;
        const s = [];
        for (let o = 0; o < e.length; o++) {
            const a = e.charAt(o);
            a === "'" ? (n.length > 0 && s.push({
                literal: i,
                val: n
            }), r = null, n = "", i = !i) : i || a === r ? n += a : (n.length > 0 && s.push({
                literal: !1,
                val: n
            }), n = a, r = a)
        }
        return n.length > 0 && s.push({
            literal: i,
            val: n
        }), s
    }
    static macroTokenToFormatOpts(e) {
        return Pk[e]
    }
    constructor(e, r) {
        this.opts = r, this.loc = e, this.systemLoc = null
    }
    formatWithSystemDefault(e, r) {
        return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, Ce(Ce({}, this.opts), r)).format()
    }
    formatDateTime(e, r = {}) {
        return this.loc.dtFormatter(e, Ce(Ce({}, this.opts), r)).format()
    }
    formatDateTimeParts(e, r = {}) {
        return this.loc.dtFormatter(e, Ce(Ce({}, this.opts), r)).formatToParts()
    }
    resolvedOptions(e, r = {}) {
        return this.loc.dtFormatter(e, Ce(Ce({}, this.opts), r)).resolvedOptions()
    }
    num(e, r = 0) {
        if (this.opts.forceSimple) return Br(e, r);
        const n = Ce({}, this.opts);
        return r > 0 && (n.padTo = r), this.loc.numberFormatter(n).format(e)
    }
    formatDateTimeFromString(e, r) {
        const n = this.loc.listingMode() === "en",
            i = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
            s = (E, T) => this.loc.extract(e, E, T),
            o = E => e.isOffsetFixed && e.offset === 0 && E.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, E.format) : "",
            a = () => n ? Nk(e) : s({
                hour: "numeric",
                hourCycle: "h12"
            }, "dayperiod"),
            c = (E, T) => n ? Ok(e, E) : s(T ? {
                month: E
            } : {
                month: E,
                day: "numeric"
            }, "month"),
            d = (E, T) => n ? Tk(e, E) : s(T ? {
                weekday: E
            } : {
                weekday: E,
                month: "long",
                day: "numeric"
            }, "weekday"),
            y = E => {
                const T = _n.macroTokenToFormatOpts(E);
                return T ? this.formatWithSystemDefault(e, T) : E
            },
            I = E => n ? Rk(e, E) : s({
                era: E
            }, "era"),
            N = E => {
                switch (E) {
                    case "S":
                        return this.num(e.millisecond);
                    case "u":
                    case "SSS":
                        return this.num(e.millisecond, 3);
                    case "s":
                        return this.num(e.second);
                    case "ss":
                        return this.num(e.second, 2);
                    case "uu":
                        return this.num(Math.floor(e.millisecond / 10), 2);
                    case "uuu":
                        return this.num(Math.floor(e.millisecond / 100));
                    case "m":
                        return this.num(e.minute);
                    case "mm":
                        return this.num(e.minute, 2);
                    case "h":
                        return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
                    case "hh":
                        return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
                    case "H":
                        return this.num(e.hour);
                    case "HH":
                        return this.num(e.hour, 2);
                    case "Z":
                        return o({
                            format: "narrow",
                            allowZ: this.opts.allowZ
                        });
                    case "ZZ":
                        return o({
                            format: "short",
                            allowZ: this.opts.allowZ
                        });
                    case "ZZZ":
                        return o({
                            format: "techie",
                            allowZ: this.opts.allowZ
                        });
                    case "ZZZZ":
                        return e.zone.offsetName(e.ts, {
                            format: "short",
                            locale: this.loc.locale
                        });
                    case "ZZZZZ":
                        return e.zone.offsetName(e.ts, {
                            format: "long",
                            locale: this.loc.locale
                        });
                    case "z":
                        return e.zoneName;
                    case "a":
                        return a();
                    case "d":
                        return i ? s({
                            day: "numeric"
                        }, "day") : this.num(e.day);
                    case "dd":
                        return i ? s({
                            day: "2-digit"
                        }, "day") : this.num(e.day, 2);
                    case "c":
                        return this.num(e.weekday);
                    case "ccc":
                        return d("short", !0);
                    case "cccc":
                        return d("long", !0);
                    case "ccccc":
                        return d("narrow", !0);
                    case "E":
                        return this.num(e.weekday);
                    case "EEE":
                        return d("short", !1);
                    case "EEEE":
                        return d("long", !1);
                    case "EEEEE":
                        return d("narrow", !1);
                    case "L":
                        return i ? s({
                            month: "numeric",
                            day: "numeric"
                        }, "month") : this.num(e.month);
                    case "LL":
                        return i ? s({
                            month: "2-digit",
                            day: "numeric"
                        }, "month") : this.num(e.month, 2);
                    case "LLL":
                        return c("short", !0);
                    case "LLLL":
                        return c("long", !0);
                    case "LLLLL":
                        return c("narrow", !0);
                    case "M":
                        return i ? s({
                            month: "numeric"
                        }, "month") : this.num(e.month);
                    case "MM":
                        return i ? s({
                            month: "2-digit"
                        }, "month") : this.num(e.month, 2);
                    case "MMM":
                        return c("short", !1);
                    case "MMMM":
                        return c("long", !1);
                    case "MMMMM":
                        return c("narrow", !1);
                    case "y":
                        return i ? s({
                            year: "numeric"
                        }, "year") : this.num(e.year);
                    case "yy":
                        return i ? s({
                            year: "2-digit"
                        }, "year") : this.num(e.year.toString().slice(-2), 2);
                    case "yyyy":
                        return i ? s({
                            year: "numeric"
                        }, "year") : this.num(e.year, 4);
                    case "yyyyyy":
                        return i ? s({
                            year: "numeric"
                        }, "year") : this.num(e.year, 6);
                    case "G":
                        return I("short");
                    case "GG":
                        return I("long");
                    case "GGGGG":
                        return I("narrow");
                    case "kk":
                        return this.num(e.weekYear.toString().slice(-2), 2);
                    case "kkkk":
                        return this.num(e.weekYear, 4);
                    case "W":
                        return this.num(e.weekNumber);
                    case "WW":
                        return this.num(e.weekNumber, 2);
                    case "o":
                        return this.num(e.ordinal);
                    case "ooo":
                        return this.num(e.ordinal, 3);
                    case "q":
                        return this.num(e.quarter);
                    case "qq":
                        return this.num(e.quarter, 2);
                    case "X":
                        return this.num(Math.floor(e.ts / 1e3));
                    case "x":
                        return this.num(e.ts);
                    default:
                        return y(E)
                }
            };
        return Ag(_n.parseFormat(r), N)
    }
    formatDurationFromString(e, r) {
        const n = c => {
                switch (c[0]) {
                    case "S":
                        return "millisecond";
                    case "s":
                        return "second";
                    case "m":
                        return "minute";
                    case "h":
                        return "hour";
                    case "d":
                        return "day";
                    case "w":
                        return "week";
                    case "M":
                        return "month";
                    case "y":
                        return "year";
                    default:
                        return null
                }
            },
            i = c => d => {
                const y = n(d);
                return y ? this.num(c.get(y), d.length) : d
            },
            s = _n.parseFormat(r),
            o = s.reduce((c, {
                literal: d,
                val: y
            }) => d ? c : c.concat(y), []),
            a = e.shiftTo(...o.map(n).filter(c => c));
        return Ag(s, i(a))
    }
}
class Si {
    constructor(e, r) {
        this.reason = e, this.explanation = r
    }
    toMessage() {
        return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason
    }
}
class Pl {
    get type() {
        throw new Cs
    }
    get name() {
        throw new Cs
    }
    get ianaName() {
        return this.name
    }
    get isUniversal() {
        throw new Cs
    }
    offsetName(e, r) {
        throw new Cs
    }
    formatOffset(e, r) {
        throw new Cs
    }
    offset(e) {
        throw new Cs
    }
    equals(e) {
        throw new Cs
    }
    get isValid() {
        throw new Cs
    }
}
let L0 = null;
class K1 extends Pl {
    static get instance() {
        return L0 === null && (L0 = new K1), L0
    }
    get type() {
        return "system"
    }
    get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone
    }
    get isUniversal() {
        return !1
    }
    offsetName(e, {
        format: r,
        locale: n
    }) {
        return Z3(e, r, n)
    }
    formatOffset(e, r) {
        return Ku(this.offset(e), r)
    }
    offset(e) {
        return -new Date(e).getTimezoneOffset()
    }
    equals(e) {
        return e.type === "system"
    }
    get isValid() {
        return !0
    }
}
let zf = {};

function Lk(t) {
    return zf[t] || (zf[t] = new Intl.DateTimeFormat("en-US", {
        hour12: !1,
        timeZone: t,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
    })), zf[t]
}
const Fk = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
};

function Uk(t, e) {
    const r = t.format(e).replace(/\u200E/g, ""),
        n = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(r),
        [, i, s, o, a, c, d, y] = n;
    return [o, i, s, a, c, d, y]
}

function zk(t, e) {
    const r = t.formatToParts(e),
        n = [];
    for (let i = 0; i < r.length; i++) {
        const {
            type: s,
            value: o
        } = r[i], a = Fk[s];
        s === "era" ? n[a] = o : $t(a) || (n[a] = parseInt(o, 10))
    }
    return n
}
let pf = {};
class As extends Pl {
    static create(e) {
        return pf[e] || (pf[e] = new As(e)), pf[e]
    }
    static resetCache() {
        pf = {}, zf = {}
    }
    static isValidSpecifier(e) {
        return this.isValidZone(e)
    }
    static isValidZone(e) {
        if (!e) return !1;
        try {
            return new Intl.DateTimeFormat("en-US", {
                timeZone: e
            }).format(), !0
        } catch {
            return !1
        }
    }
    constructor(e) {
        super(), this.zoneName = e, this.valid = As.isValidZone(e)
    }
    get type() {
        return "iana"
    }
    get name() {
        return this.zoneName
    }
    get isUniversal() {
        return !1
    }
    offsetName(e, {
        format: r,
        locale: n
    }) {
        return Z3(e, r, n, this.name)
    }
    formatOffset(e, r) {
        return Ku(this.offset(e), r)
    }
    offset(e) {
        const r = new Date(e);
        if (isNaN(r)) return NaN;
        const n = Lk(this.name);
        let [i, s, o, a, c, d, y] = n.formatToParts ? zk(n, r) : Uk(n, r);
        a === "BC" && (i = -Math.abs(i) + 1);
        const N = Y1({
            year: i,
            month: s,
            day: o,
            hour: c === 24 ? 0 : c,
            minute: d,
            second: y,
            millisecond: 0
        });
        let E = +r;
        const T = E % 1e3;
        return E -= T >= 0 ? T : 1e3 + T, (N - E) / (60 * 1e3)
    }
    equals(e) {
        return e.type === "iana" && e.name === this.name
    }
    get isValid() {
        return this.valid
    }
}
let F0 = null;
class yn extends Pl {
    static get utcInstance() {
        return F0 === null && (F0 = new yn(0)), F0
    }
    static instance(e) {
        return e === 0 ? yn.utcInstance : new yn(e)
    }
    static parseSpecifier(e) {
        if (e) {
            const r = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
            if (r) return new yn(Rh(r[1], r[2]))
        }
        return null
    }
    constructor(e) {
        super(), this.fixed = e
    }
    get type() {
        return "fixed"
    }
    get name() {
        return this.fixed === 0 ? "UTC" : `UTC${Ku(this.fixed,"narrow")}`
    }
    get ianaName() {
        return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Ku(-this.fixed,"narrow")}`
    }
    offsetName() {
        return this.name
    }
    formatOffset(e, r) {
        return Ku(this.fixed, r)
    }
    get isUniversal() {
        return !0
    }
    offset() {
        return this.fixed
    }
    equals(e) {
        return e.type === "fixed" && e.fixed === this.fixed
    }
    get isValid() {
        return !0
    }
}
class jk extends Pl {
    constructor(e) {
        super(), this.zoneName = e
    }
    get type() {
        return "invalid"
    }
    get name() {
        return this.zoneName
    }
    get isUniversal() {
        return !1
    }
    offsetName() {
        return null
    }
    formatOffset() {
        return ""
    }
    offset() {
        return NaN
    }
    equals() {
        return !1
    }
    get isValid() {
        return !1
    }
}

function Fs(t, e) {
    if ($t(t) || t === null) return e;
    if (t instanceof Pl) return t;
    if (xk(t)) {
        const r = t.toLowerCase();
        return r === "local" || r === "system" ? e : r === "utc" || r === "gmt" ? yn.utcInstance : yn.parseSpecifier(r) || As.create(t)
    } else return _o(t) ? yn.instance(t) : typeof t == "object" && t.offset && typeof t.offset == "number" ? t : new jk(t)
}
let Sg = () => Date.now(),
    Mg = "system",
    Eg = null,
    _g = null,
    Ig = null,
    Cg;
class Tr {
    static get now() {
        return Sg
    }
    static set now(e) {
        Sg = e
    }
    static set defaultZone(e) {
        Mg = e
    }
    static get defaultZone() {
        return Fs(Mg, K1.instance)
    }
    static get defaultLocale() {
        return Eg
    }
    static set defaultLocale(e) {
        Eg = e
    }
    static get defaultNumberingSystem() {
        return _g
    }
    static set defaultNumberingSystem(e) {
        _g = e
    }
    static get defaultOutputCalendar() {
        return Ig
    }
    static set defaultOutputCalendar(e) {
        Ig = e
    }
    static get throwOnInvalid() {
        return Cg
    }
    static set throwOnInvalid(e) {
        Cg = e
    }
    static resetCaches() {
        yr.resetCache(), As.resetCache()
    }
}
let Bg = {};

function $k(t, e = {}) {
    const r = JSON.stringify([t, e]);
    let n = Bg[r];
    return n || (n = new Intl.ListFormat(t, e), Bg[r] = n), n
}
let lp = {};

function fp(t, e = {}) {
    const r = JSON.stringify([t, e]);
    let n = lp[r];
    return n || (n = new Intl.DateTimeFormat(t, e), lp[r] = n), n
}
let cp = {};

function Hk(t, e) {
    const r = JSON.stringify([t, e]);
    let n = cp[r];
    return n || (n = new Intl.NumberFormat(t, e), cp[r] = n), n
}
let hp = {};

function Qk(t, e = {}) {
    const o = e,
        {
            base: r
        } = o,
        n = Wn(o, ["base"]),
        i = JSON.stringify([t, n]);
    let s = hp[i];
    return s || (s = new Intl.RelativeTimeFormat(t, e), hp[i] = s), s
}
let Lu = null;

function qk() {
    return Lu || (Lu = new Intl.DateTimeFormat().resolvedOptions().locale, Lu)
}

function Wk(t) {
    const e = t.indexOf("-u-");
    if (e === -1) return [t]; {
        let r;
        const n = t.substring(0, e);
        try {
            r = fp(t).resolvedOptions()
        } catch {
            r = fp(n).resolvedOptions()
        }
        const {
            numberingSystem: i,
            calendar: s
        } = r;
        return [n, i, s]
    }
}

function Vk(t, e, r) {
    return (r || e) && (t += "-u", r && (t += `-ca-${r}`), e && (t += `-nu-${e}`)), t
}

function Gk(t) {
    const e = [];
    for (let r = 1; r <= 12; r++) {
        const n = mt.utc(2016, r, 1);
        e.push(t(n))
    }
    return e
}

function Yk(t) {
    const e = [];
    for (let r = 1; r <= 7; r++) {
        const n = mt.utc(2016, 11, 13 + r);
        e.push(t(n))
    }
    return e
}

function mf(t, e, r, n, i) {
    const s = t.listingMode(r);
    return s === "error" ? null : s === "en" ? n(e) : i(e)
}

function Kk(t) {
    return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem === "latn"
}
class Zk {
    constructor(e, r, n) {
        this.padTo = n.padTo || 0, this.floor = n.floor || !1;
        const a = n,
            {
                padTo: i,
                floor: s
            } = a,
            o = Wn(a, ["padTo", "floor"]);
        if (!r || Object.keys(o).length > 0) {
            const c = Ce({
                useGrouping: !1
            }, n);
            n.padTo > 0 && (c.minimumIntegerDigits = n.padTo), this.inf = Hk(e, c)
        }
    }
    format(e) {
        if (this.inf) {
            const r = this.floor ? Math.floor(e) : e;
            return this.inf.format(r)
        } else {
            const r = this.floor ? Math.floor(e) : G1(e, 3);
            return Br(r, this.padTo)
        }
    }
}
class Jk {
    constructor(e, r, n) {
        this.opts = n;
        let i;
        if (e.zone.isUniversal) {
            const o = -1 * (e.offset / 60),
                a = o >= 0 ? `Etc/GMT+${o}` : `Etc/GMT${o}`;
            e.offset !== 0 && As.create(a).valid ? (i = a, this.dt = e) : (i = "UTC", n.timeZoneName ? this.dt = e : this.dt = e.offset === 0 ? e : mt.fromMillis(e.ts + e.offset * 60 * 1e3))
        } else e.zone.type === "system" ? this.dt = e : (this.dt = e, i = e.zone.name);
        const s = Ce({}, this.opts);
        i && (s.timeZone = i), this.dtf = fp(r, s)
    }
    format() {
        return this.dtf.format(this.dt.toJSDate())
    }
    formatToParts() {
        return this.dtf.formatToParts(this.dt.toJSDate())
    }
    resolvedOptions() {
        return this.dtf.resolvedOptions()
    }
}
class Xk {
    constructor(e, r, n) {
        this.opts = Ce({
            style: "long"
        }, n), !r && K3() && (this.rtf = Qk(e, n))
    }
    format(e, r) {
        return this.rtf ? this.rtf.format(e, r) : Dk(r, e, this.opts.numeric, this.opts.style !== "long")
    }
    formatToParts(e, r) {
        return this.rtf ? this.rtf.formatToParts(e, r) : []
    }
}
class yr {
    static fromOpts(e) {
        return yr.create(e.locale, e.numberingSystem, e.outputCalendar, e.defaultToEN)
    }
    static create(e, r, n, i = !1) {
        const s = e || Tr.defaultLocale,
            o = s || (i ? "en-US" : qk()),
            a = r || Tr.defaultNumberingSystem,
            c = n || Tr.defaultOutputCalendar;
        return new yr(o, a, c, s)
    }
    static resetCache() {
        Lu = null, lp = {}, cp = {}, hp = {}
    }
    static fromObject({
        locale: e,
        numberingSystem: r,
        outputCalendar: n
    } = {}) {
        return yr.create(e, r, n)
    }
    constructor(e, r, n, i) {
        const [s, o, a] = Wk(e);
        this.locale = s, this.numberingSystem = r || o || null, this.outputCalendar = n || a || null, this.intl = Vk(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = {
            format: {},
            standalone: {}
        }, this.monthsCache = {
            format: {},
            standalone: {}
        }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = i, this.fastNumbersCached = null
    }
    get fastNumbers() {
        return this.fastNumbersCached == null && (this.fastNumbersCached = Kk(this)), this.fastNumbersCached
    }
    listingMode() {
        const e = this.isEnglish(),
            r = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return e && r ? "en" : "intl"
    }
    clone(e) {
        return !e || Object.getOwnPropertyNames(e).length === 0 ? this : yr.create(e.locale || this.specifiedLocale, e.numberingSystem || this.numberingSystem, e.outputCalendar || this.outputCalendar, e.defaultToEN || !1)
    }
    redefaultToEN(e = {}) {
        return this.clone(xt(Ce({}, e), {
            defaultToEN: !0
        }))
    }
    redefaultToSystem(e = {}) {
        return this.clone(xt(Ce({}, e), {
            defaultToEN: !1
        }))
    }
    months(e, r = !1, n = !0) {
        return mf(this, e, n, t6, () => {
            const i = r ? {
                    month: e,
                    day: "numeric"
                } : {
                    month: e
                },
                s = r ? "format" : "standalone";
            return this.monthsCache[s][e] || (this.monthsCache[s][e] = Gk(o => this.extract(o, i, "month"))), this.monthsCache[s][e]
        })
    }
    weekdays(e, r = !1, n = !0) {
        return mf(this, e, n, i6, () => {
            const i = r ? {
                    weekday: e,
                    year: "numeric",
                    month: "long",
                    day: "numeric"
                } : {
                    weekday: e
                },
                s = r ? "format" : "standalone";
            return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = Yk(o => this.extract(o, i, "weekday"))), this.weekdaysCache[s][e]
        })
    }
    meridiems(e = !0) {
        return mf(this, void 0, e, () => s6, () => {
            if (!this.meridiemCache) {
                const r = {
                    hour: "numeric",
                    hourCycle: "h12"
                };
                this.meridiemCache = [mt.utc(2016, 11, 13, 9), mt.utc(2016, 11, 13, 19)].map(n => this.extract(n, r, "dayperiod"))
            }
            return this.meridiemCache
        })
    }
    eras(e, r = !0) {
        return mf(this, e, r, o6, () => {
            const n = {
                era: e
            };
            return this.eraCache[e] || (this.eraCache[e] = [mt.utc(-40, 1, 1), mt.utc(2017, 1, 1)].map(i => this.extract(i, n, "era"))), this.eraCache[e]
        })
    }
    extract(e, r, n) {
        const i = this.dtFormatter(e, r),
            s = i.formatToParts(),
            o = s.find(a => a.type.toLowerCase() === n);
        return o ? o.value : null
    }
    numberFormatter(e = {}) {
        return new Zk(this.intl, e.forceSimple || this.fastNumbers, e)
    }
    dtFormatter(e, r = {}) {
        return new Jk(e, this.intl, r)
    }
    relFormatter(e = {}) {
        return new Xk(this.intl, this.isEnglish(), e)
    }
    listFormatter(e = {}) {
        return $k(this.intl, e)
    }
    isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")
    }
    equals(e) {
        return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar
    }
}

function iu(...t) {
    const e = t.reduce((r, n) => r + n.source, "");
    return RegExp(`^${e}$`)
}

function su(...t) {
    return e => t.reduce(([r, n, i], s) => {
        const [o, a, c] = s(e, i);
        return [Ce(Ce({}, r), o), a || n, c]
    }, [{}, null, 1]).slice(0, 2)
}

function ou(t, ...e) {
    if (t == null) return [null, null];
    for (const [r, n] of e) {
        const i = r.exec(t);
        if (i) return n(i)
    }
    return [null, null]
}

function a6(...t) {
    return (e, r) => {
        const n = {};
        let i;
        for (i = 0; i < t.length; i++) n[t[i]] = Rs(e[r + i]);
        return [n, null, r + i]
    }
}
const u6 = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,
    eN = `(?:${u6.source}?(?:\\[(${X3.source})\\])?)?`,
    Z1 = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,
    l6 = RegExp(`${Z1.source}${eN}`),
    J1 = RegExp(`(?:T${l6.source})?`),
    tN = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,
    rN = /(\d{4})-?W(\d\d)(?:-?(\d))?/,
    nN = /(\d{4})-?(\d{3})/,
    iN = a6("weekYear", "weekNumber", "weekDay"),
    sN = a6("year", "ordinal"),
    oN = /(\d{4})-(\d\d)-(\d\d)/,
    f6 = RegExp(`${Z1.source} ?(?:${u6.source}|(${X3.source}))?`),
    aN = RegExp(`(?: ${f6.source})?`);

function ga(t, e, r) {
    const n = t[e];
    return $t(n) ? r : Rs(n)
}

function uN(t, e) {
    return [{
        year: ga(t, e),
        month: ga(t, e + 1, 1),
        day: ga(t, e + 2, 1)
    }, null, e + 3]
}

function au(t, e) {
    return [{
        hours: ga(t, e, 0),
        minutes: ga(t, e + 1, 0),
        seconds: ga(t, e + 2, 0),
        milliseconds: V1(t[e + 3])
    }, null, e + 4]
}

function Ll(t, e) {
    const r = !t[e] && !t[e + 1],
        n = Rh(t[e + 1], t[e + 2]),
        i = r ? null : yn.instance(n);
    return [{}, i, e + 3]
}

function Fl(t, e) {
    const r = t[e] ? As.create(t[e]) : null;
    return [{}, r, e + 1]
}
const lN = RegExp(`^T?${Z1.source}$`),
    fN = /^-?P(?:(?:(-?\d{1,9}(?:\.\d{1,9})?)Y)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,9}(?:\.\d{1,9})?)W)?(?:(-?\d{1,9}(?:\.\d{1,9})?)D)?(?:T(?:(-?\d{1,9}(?:\.\d{1,9})?)H)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;

function cN(t) {
    const [e, r, n, i, s, o, a, c, d] = t, y = e[0] === "-", I = c && c[0] === "-", N = (E, T = !1) => E !== void 0 && (T || E && y) ? -E : E;
    return [{
        years: N(fo(r)),
        months: N(fo(n)),
        weeks: N(fo(i)),
        days: N(fo(s)),
        hours: N(fo(o)),
        minutes: N(fo(a)),
        seconds: N(fo(c), c === "-0"),
        milliseconds: N(V1(d), I)
    }]
}
const hN = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function X1(t, e, r, n, i, s, o) {
    const a = {
        year: e.length === 2 ? up(Rs(e)) : Rs(e),
        month: e6.indexOf(r) + 1,
        day: Rs(n),
        hour: Rs(i),
        minute: Rs(s)
    };
    return o && (a.second = Rs(o)), t && (a.weekday = t.length > 3 ? r6.indexOf(t) + 1 : n6.indexOf(t) + 1), a
}
const dN = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

function pN(t) {
    const [, e, r, n, i, s, o, a, c, d, y, I] = t, N = X1(e, i, n, r, s, o, a);
    let E;
    return c ? E = hN[c] : d ? E = 0 : E = Rh(y, I), [N, new yn(E)]
}

function mN(t) {
    return t.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim()
}
const vN = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
    gN = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
    yN = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

function kg(t) {
    const [, e, r, n, i, s, o, a] = t;
    return [X1(e, i, n, r, s, o, a), yn.utcInstance]
}

function wN(t) {
    const [, e, r, n, i, s, o, a] = t;
    return [X1(e, a, r, n, i, s, o), yn.utcInstance]
}
const xN = iu(tN, J1),
    bN = iu(rN, J1),
    AN = iu(nN, J1),
    SN = iu(l6),
    c6 = su(uN, au, Ll, Fl),
    MN = su(iN, au, Ll, Fl),
    EN = su(sN, au, Ll, Fl),
    _N = su(au, Ll, Fl);

function IN(t) {
    return ou(t, [xN, c6], [bN, MN], [AN, EN], [SN, _N])
}

function CN(t) {
    return ou(mN(t), [dN, pN])
}

function BN(t) {
    return ou(t, [vN, kg], [gN, kg], [yN, wN])
}

function kN(t) {
    return ou(t, [fN, cN])
}
const NN = su(au);

function TN(t) {
    return ou(t, [lN, NN])
}
const ON = iu(oN, aN),
    RN = iu(f6),
    DN = su(au, Ll, Fl);

function PN(t) {
    return ou(t, [ON, c6], [RN, DN])
}
const LN = "Invalid Duration",
    h6 = {
        weeks: {
            days: 7,
            hours: 7 * 24,
            minutes: 7 * 24 * 60,
            seconds: 7 * 24 * 60 * 60,
            milliseconds: 7 * 24 * 60 * 60 * 1e3
        },
        days: {
            hours: 24,
            minutes: 24 * 60,
            seconds: 24 * 60 * 60,
            milliseconds: 24 * 60 * 60 * 1e3
        },
        hours: {
            minutes: 60,
            seconds: 60 * 60,
            milliseconds: 60 * 60 * 1e3
        },
        minutes: {
            seconds: 60,
            milliseconds: 60 * 1e3
        },
        seconds: {
            milliseconds: 1e3
        }
    },
    FN = Ce({
        years: {
            quarters: 4,
            months: 12,
            weeks: 52,
            days: 365,
            hours: 365 * 24,
            minutes: 365 * 24 * 60,
            seconds: 365 * 24 * 60 * 60,
            milliseconds: 365 * 24 * 60 * 60 * 1e3
        },
        quarters: {
            months: 3,
            weeks: 13,
            days: 91,
            hours: 91 * 24,
            minutes: 91 * 24 * 60,
            seconds: 91 * 24 * 60 * 60,
            milliseconds: 91 * 24 * 60 * 60 * 1e3
        },
        months: {
            weeks: 4,
            days: 30,
            hours: 30 * 24,
            minutes: 30 * 24 * 60,
            seconds: 30 * 24 * 60 * 60,
            milliseconds: 30 * 24 * 60 * 60 * 1e3
        }
    }, h6),
    Vn = 146097 / 400,
    Go = 146097 / 4800,
    UN = Ce({
        years: {
            quarters: 4,
            months: 12,
            weeks: Vn / 7,
            days: Vn,
            hours: Vn * 24,
            minutes: Vn * 24 * 60,
            seconds: Vn * 24 * 60 * 60,
            milliseconds: Vn * 24 * 60 * 60 * 1e3
        },
        quarters: {
            months: 3,
            weeks: Vn / 28,
            days: Vn / 4,
            hours: Vn * 24 / 4,
            minutes: Vn * 24 * 60 / 4,
            seconds: Vn * 24 * 60 * 60 / 4,
            milliseconds: Vn * 24 * 60 * 60 * 1e3 / 4
        },
        months: {
            weeks: Go / 7,
            days: Go,
            hours: Go * 24,
            minutes: Go * 24 * 60,
            seconds: Go * 24 * 60 * 60,
            milliseconds: Go * 24 * 60 * 60 * 1e3
        }
    }, h6),
    mo = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"],
    zN = mo.slice(0).reverse();

function co(t, e, r = !1) {
    const n = {
        values: r ? e.values : Ce(Ce({}, t.values), e.values || {}),
        loc: t.loc.clone(e.loc),
        conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy
    };
    return new qt(n)
}

function jN(t) {
    return t < 0 ? Math.floor(t) : Math.ceil(t)
}

function d6(t, e, r, n, i) {
    const s = t[i][r],
        o = e[r] / s,
        a = Math.sign(o) === Math.sign(n[i]),
        c = !a && n[i] !== 0 && Math.abs(o) <= 1 ? jN(o) : Math.trunc(o);
    n[i] += c, e[r] -= c * s
}

function $N(t, e) {
    zN.reduce((r, n) => $t(e[n]) ? r : (r && d6(t, e, r, e, n), n), null)
}
class qt {
    constructor(e) {
        const r = e.conversionAccuracy === "longterm" || !1;
        this.values = e.values, this.loc = e.loc || yr.create(), this.conversionAccuracy = r ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = r ? UN : FN, this.isLuxonDuration = !0
    }
    static fromMillis(e, r) {
        return qt.fromObject({
            milliseconds: e
        }, r)
    }
    static fromObject(e, r = {}) {
        if (e == null || typeof e != "object") throw new ei(`Duration.fromObject: argument expected to be an object, got ${e===null?"null":typeof e}`);
        return new qt({
            values: Nc(e, qt.normalizeUnit),
            loc: yr.fromObject(r),
            conversionAccuracy: r.conversionAccuracy
        })
    }
    static fromDurationLike(e) {
        if (_o(e)) return qt.fromMillis(e);
        if (qt.isDuration(e)) return e;
        if (typeof e == "object") return qt.fromObject(e);
        throw new ei(`Unknown duration argument ${e} of type ${typeof e}`)
    }
    static fromISO(e, r) {
        const [n] = kN(e);
        return n ? qt.fromObject(n, r) : qt.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`)
    }
    static fromISOTime(e, r) {
        const [n] = TN(e);
        return n ? qt.fromObject(n, r) : qt.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`)
    }
    static invalid(e, r = null) {
        if (!e) throw new ei("need to specify a reason the Duration is invalid");
        const n = e instanceof Si ? e : new Si(e, r);
        if (Tr.throwOnInvalid) throw new gk(n);
        return new qt({
            invalid: n
        })
    }
    static normalizeUnit(e) {
        const r = {
            year: "years",
            years: "years",
            quarter: "quarters",
            quarters: "quarters",
            month: "months",
            months: "months",
            week: "weeks",
            weeks: "weeks",
            day: "days",
            days: "days",
            hour: "hours",
            hours: "hours",
            minute: "minutes",
            minutes: "minutes",
            second: "seconds",
            seconds: "seconds",
            millisecond: "milliseconds",
            milliseconds: "milliseconds"
        }[e && e.toLowerCase()];
        if (!r) throw new k3(e);
        return r
    }
    static isDuration(e) {
        return e && e.isLuxonDuration || !1
    }
    get locale() {
        return this.isValid ? this.loc.locale : null
    }
    get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null
    }
    toFormat(e, r = {}) {
        const n = xt(Ce({}, r), {
            floor: r.round !== !1 && r.floor !== !1
        });
        return this.isValid ? _n.create(this.loc, n).formatDurationFromString(this, e) : LN
    }
    toHuman(e = {}) {
        const r = mo.map(n => {
            const i = this.values[n];
            return $t(i) ? null : this.loc.numberFormatter(xt(Ce({
                style: "unit",
                unitDisplay: "long"
            }, e), {
                unit: n.slice(0, -1)
            })).format(i)
        }).filter(n => n);
        return this.loc.listFormatter(Ce({
            type: "conjunction",
            style: e.listStyle || "narrow"
        }, e)).format(r)
    }
    toObject() {
        return this.isValid ? Ce({}, this.values) : {}
    }
    toISO() {
        if (!this.isValid) return null;
        let e = "P";
        return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += G1(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e
    }
    toISOTime(e = {}) {
        if (!this.isValid) return null;
        const r = this.toMillis();
        if (r < 0 || r >= 864e5) return null;
        e = Ce({
            suppressMilliseconds: !1,
            suppressSeconds: !1,
            includePrefix: !1,
            format: "extended"
        }, e);
        const n = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
        let i = e.format === "basic" ? "hhmm" : "hh:mm";
        (!e.suppressSeconds || n.seconds !== 0 || n.milliseconds !== 0) && (i += e.format === "basic" ? "ss" : ":ss", (!e.suppressMilliseconds || n.milliseconds !== 0) && (i += ".SSS"));
        let s = n.toFormat(i);
        return e.includePrefix && (s = "T" + s), s
    }
    toJSON() {
        return this.toISO()
    }
    toString() {
        return this.toISO()
    }
    toMillis() {
        return this.as("milliseconds")
    }
    valueOf() {
        return this.toMillis()
    }
    plus(e) {
        if (!this.isValid) return this;
        const r = qt.fromDurationLike(e),
            n = {};
        for (const i of mo)(Ua(r.values, i) || Ua(this.values, i)) && (n[i] = r.get(i) + this.get(i));
        return co(this, {
            values: n
        }, !0)
    }
    minus(e) {
        if (!this.isValid) return this;
        const r = qt.fromDurationLike(e);
        return this.plus(r.negate())
    }
    mapUnits(e) {
        if (!this.isValid) return this;
        const r = {};
        for (const n of Object.keys(this.values)) r[n] = J3(e(this.values[n], n));
        return co(this, {
            values: r
        }, !0)
    }
    get(e) {
        return this[qt.normalizeUnit(e)]
    }
    set(e) {
        if (!this.isValid) return this;
        const r = Ce(Ce({}, this.values), Nc(e, qt.normalizeUnit));
        return co(this, {
            values: r
        })
    }
    reconfigure({
        locale: e,
        numberingSystem: r,
        conversionAccuracy: n
    } = {}) {
        const i = this.loc.clone({
                locale: e,
                numberingSystem: r
            }),
            s = {
                loc: i
            };
        return n && (s.conversionAccuracy = n), co(this, s)
    }
    as(e) {
        return this.isValid ? this.shiftTo(e).get(e) : NaN
    }
    normalize() {
        if (!this.isValid) return this;
        const e = this.toObject();
        return $N(this.matrix, e), co(this, {
            values: e
        }, !0)
    }
    shiftTo(...e) {
        if (!this.isValid) return this;
        if (e.length === 0) return this;
        e = e.map(o => qt.normalizeUnit(o));
        const r = {},
            n = {},
            i = this.toObject();
        let s;
        for (const o of mo)
            if (e.indexOf(o) >= 0) {
                s = o;
                let a = 0;
                for (const d in n) a += this.matrix[d][o] * n[d], n[d] = 0;
                _o(i[o]) && (a += i[o]);
                const c = Math.trunc(a);
                r[o] = c, n[o] = (a * 1e3 - c * 1e3) / 1e3;
                for (const d in i) mo.indexOf(d) > mo.indexOf(o) && d6(this.matrix, i, d, r, o)
            } else _o(i[o]) && (n[o] = i[o]);
        for (const o in n) n[o] !== 0 && (r[s] += o === s ? n[o] : n[o] / this.matrix[s][o]);
        return co(this, {
            values: r
        }, !0).normalize()
    }
    negate() {
        if (!this.isValid) return this;
        const e = {};
        for (const r of Object.keys(this.values)) e[r] = this.values[r] === 0 ? 0 : -this.values[r];
        return co(this, {
            values: e
        }, !0)
    }
    get years() {
        return this.isValid ? this.values.years || 0 : NaN
    }
    get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN
    }
    get months() {
        return this.isValid ? this.values.months || 0 : NaN
    }
    get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN
    }
    get days() {
        return this.isValid ? this.values.days || 0 : NaN
    }
    get hours() {
        return this.isValid ? this.values.hours || 0 : NaN
    }
    get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN
    }
    get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN
    }
    get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN
    }
    get isValid() {
        return this.invalid === null
    }
    get invalidReason() {
        return this.invalid ? this.invalid.reason : null
    }
    get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null
    }
    equals(e) {
        if (!this.isValid || !e.isValid || !this.loc.equals(e.loc)) return !1;

        function r(n, i) {
            return n === void 0 || n === 0 ? i === void 0 || i === 0 : n === i
        }
        for (const n of mo)
            if (!r(this.values[n], e.values[n])) return !1;
        return !0
    }
}
const Mu = "Invalid Interval";

function HN(t, e) {
    return !t || !t.isValid ? Mr.invalid("missing or invalid start") : !e || !e.isValid ? Mr.invalid("missing or invalid end") : e < t ? Mr.invalid("end before start", `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`) : null
}
class Mr {
    constructor(e) {
        this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0
    }
    static invalid(e, r = null) {
        if (!e) throw new ei("need to specify a reason the Interval is invalid");
        const n = e instanceof Si ? e : new Si(e, r);
        if (Tr.throwOnInvalid) throw new vk(n);
        return new Mr({
            invalid: n
        })
    }
    static fromDateTimes(e, r) {
        const n = Iu(e),
            i = Iu(r),
            s = HN(n, i);
        return s == null ? new Mr({
            start: n,
            end: i
        }) : s
    }
    static after(e, r) {
        const n = qt.fromDurationLike(r),
            i = Iu(e);
        return Mr.fromDateTimes(i, i.plus(n))
    }
    static before(e, r) {
        const n = qt.fromDurationLike(r),
            i = Iu(e);
        return Mr.fromDateTimes(i.minus(n), i)
    }
    static fromISO(e, r) {
        const [n, i] = (e || "").split("/", 2);
        if (n && i) {
            let s, o;
            try {
                s = mt.fromISO(n, r), o = s.isValid
            } catch {
                o = !1
            }
            let a, c;
            try {
                a = mt.fromISO(i, r), c = a.isValid
            } catch {
                c = !1
            }
            if (o && c) return Mr.fromDateTimes(s, a);
            if (o) {
                const d = qt.fromISO(i, r);
                if (d.isValid) return Mr.after(s, d)
            } else if (c) {
                const d = qt.fromISO(n, r);
                if (d.isValid) return Mr.before(a, d)
            }
        }
        return Mr.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`)
    }
    static isInterval(e) {
        return e && e.isLuxonInterval || !1
    }
    get start() {
        return this.isValid ? this.s : null
    }
    get end() {
        return this.isValid ? this.e : null
    }
    get isValid() {
        return this.invalidReason === null
    }
    get invalidReason() {
        return this.invalid ? this.invalid.reason : null
    }
    get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null
    }
    length(e = "milliseconds") {
        return this.isValid ? this.toDuration(e).get(e) : NaN
    }
    count(e = "milliseconds") {
        if (!this.isValid) return NaN;
        const r = this.start.startOf(e),
            n = this.end.startOf(e);
        return Math.floor(n.diff(r, e).get(e)) + 1
    }
    hasSame(e) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1
    }
    isEmpty() {
        return this.s.valueOf() === this.e.valueOf()
    }
    isAfter(e) {
        return this.isValid ? this.s > e : !1
    }
    isBefore(e) {
        return this.isValid ? this.e <= e : !1
    }
    contains(e) {
        return this.isValid ? this.s <= e && this.e > e : !1
    }
    set({
        start: e,
        end: r
    } = {}) {
        return this.isValid ? Mr.fromDateTimes(e || this.s, r || this.e) : this
    }
    splitAt(...e) {
        if (!this.isValid) return [];
        const r = e.map(Iu).filter(o => this.contains(o)).sort(),
            n = [];
        let {
            s: i
        } = this, s = 0;
        for (; i < this.e;) {
            const o = r[s] || this.e,
                a = +o > +this.e ? this.e : o;
            n.push(Mr.fromDateTimes(i, a)), i = a, s += 1
        }
        return n
    }
    splitBy(e) {
        const r = qt.fromDurationLike(e);
        if (!this.isValid || !r.isValid || r.as("milliseconds") === 0) return [];
        let {
            s: n
        } = this, i = 1, s;
        const o = [];
        for (; n < this.e;) {
            const a = this.start.plus(r.mapUnits(c => c * i));
            s = +a > +this.e ? this.e : a, o.push(Mr.fromDateTimes(n, s)), n = s, i += 1
        }
        return o
    }
    divideEqually(e) {
        return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : []
    }
    overlaps(e) {
        return this.e > e.s && this.s < e.e
    }
    abutsStart(e) {
        return this.isValid ? +this.e == +e.s : !1
    }
    abutsEnd(e) {
        return this.isValid ? +e.e == +this.s : !1
    }
    engulfs(e) {
        return this.isValid ? this.s <= e.s && this.e >= e.e : !1
    }
    equals(e) {
        return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e)
    }
    intersection(e) {
        if (!this.isValid) return this;
        const r = this.s > e.s ? this.s : e.s,
            n = this.e < e.e ? this.e : e.e;
        return r >= n ? null : Mr.fromDateTimes(r, n)
    }
    union(e) {
        if (!this.isValid) return this;
        const r = this.s < e.s ? this.s : e.s,
            n = this.e > e.e ? this.e : e.e;
        return Mr.fromDateTimes(r, n)
    }
    static merge(e) {
        const [r, n] = e.sort((i, s) => i.s - s.s).reduce(([i, s], o) => s ? s.overlaps(o) || s.abutsStart(o) ? [i, s.union(o)] : [i.concat([s]), o] : [i, o], [
            [], null
        ]);
        return n && r.push(n), r
    }
    static xor(e) {
        let r = null,
            n = 0;
        const i = [],
            s = e.map(c => [{
                time: c.s,
                type: "s"
            }, {
                time: c.e,
                type: "e"
            }]),
            o = Array.prototype.concat(...s),
            a = o.sort((c, d) => c.time - d.time);
        for (const c of a) n += c.type === "s" ? 1 : -1, n === 1 ? r = c.time : (r && +r != +c.time && i.push(Mr.fromDateTimes(r, c.time)), r = null);
        return Mr.merge(i)
    }
    difference(...e) {
        return Mr.xor([this].concat(e)).map(r => this.intersection(r)).filter(r => r && !r.isEmpty())
    }
    toString() {
        return this.isValid ? `[${this.s.toISO()} \u2013 ${this.e.toISO()})` : Mu
    }
    toISO(e) {
        return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : Mu
    }
    toISODate() {
        return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Mu
    }
    toISOTime(e) {
        return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : Mu
    }
    toFormat(e, {
        separator: r = " \u2013 "
    } = {}) {
        return this.isValid ? `${this.s.toFormat(e)}${r}${this.e.toFormat(e)}` : Mu
    }
    toDuration(e, r) {
        return this.isValid ? this.e.diff(this.s, e, r) : qt.invalid(this.invalidReason)
    }
    mapEndpoints(e) {
        return Mr.fromDateTimes(e(this.s), e(this.e))
    }
}
class vf {
    static hasDST(e = Tr.defaultZone) {
        const r = mt.now().setZone(e).set({
            month: 12
        });
        return !e.isUniversal && r.offset !== r.set({
            month: 6
        }).offset
    }
    static isValidIANAZone(e) {
        return As.isValidZone(e)
    }
    static normalizeZone(e) {
        return Fs(e, Tr.defaultZone)
    }
    static months(e = "long", {
        locale: r = null,
        numberingSystem: n = null,
        locObj: i = null,
        outputCalendar: s = "gregory"
    } = {}) {
        return (i || yr.create(r, n, s)).months(e)
    }
    static monthsFormat(e = "long", {
        locale: r = null,
        numberingSystem: n = null,
        locObj: i = null,
        outputCalendar: s = "gregory"
    } = {}) {
        return (i || yr.create(r, n, s)).months(e, !0)
    }
    static weekdays(e = "long", {
        locale: r = null,
        numberingSystem: n = null,
        locObj: i = null
    } = {}) {
        return (i || yr.create(r, n, null)).weekdays(e)
    }
    static weekdaysFormat(e = "long", {
        locale: r = null,
        numberingSystem: n = null,
        locObj: i = null
    } = {}) {
        return (i || yr.create(r, n, null)).weekdays(e, !0)
    }
    static meridiems({
        locale: e = null
    } = {}) {
        return yr.create(e).meridiems()
    }
    static eras(e = "short", {
        locale: r = null
    } = {}) {
        return yr.create(r, null, "gregory").eras(e)
    }
    static features() {
        return {
            relative: K3()
        }
    }
}

function Ng(t, e) {
    const r = i => i.toUTC(0, {
            keepLocalTime: !0
        }).startOf("day").valueOf(),
        n = r(e) - r(t);
    return Math.floor(qt.fromMillis(n).as("days"))
}

function QN(t, e, r) {
    const n = [
            ["years", (a, c) => c.year - a.year],
            ["quarters", (a, c) => c.quarter - a.quarter],
            ["months", (a, c) => c.month - a.month + (c.year - a.year) * 12],
            ["weeks", (a, c) => {
                const d = Ng(a, c);
                return (d - d % 7) / 7
            }],
            ["days", Ng]
        ],
        i = {};
    let s, o;
    for (const [a, c] of n)
        if (r.indexOf(a) >= 0) {
            s = a;
            let d = c(t, e);
            o = t.plus({
                [a]: d
            }), o > e ? (t = t.plus({
                [a]: d - 1
            }), d -= 1) : t = o, i[a] = d
        }
    return [t, i, o, s]
}

function qN(t, e, r, n) {
    let [i, s, o, a] = QN(t, e, r);
    const c = e - i,
        d = r.filter(I => ["hours", "minutes", "seconds", "milliseconds"].indexOf(I) >= 0);
    d.length === 0 && (o < e && (o = i.plus({
        [a]: 1
    })), o !== i && (s[a] = (s[a] || 0) + c / (o - i)));
    const y = qt.fromObject(s, n);
    return d.length > 0 ? qt.fromMillis(c, n).shiftTo(...d).plus(y) : y
}
const em = {
        arab: "[\u0660-\u0669]",
        arabext: "[\u06F0-\u06F9]",
        bali: "[\u1B50-\u1B59]",
        beng: "[\u09E6-\u09EF]",
        deva: "[\u0966-\u096F]",
        fullwide: "[\uFF10-\uFF19]",
        gujr: "[\u0AE6-\u0AEF]",
        hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
        khmr: "[\u17E0-\u17E9]",
        knda: "[\u0CE6-\u0CEF]",
        laoo: "[\u0ED0-\u0ED9]",
        limb: "[\u1946-\u194F]",
        mlym: "[\u0D66-\u0D6F]",
        mong: "[\u1810-\u1819]",
        mymr: "[\u1040-\u1049]",
        orya: "[\u0B66-\u0B6F]",
        tamldec: "[\u0BE6-\u0BEF]",
        telu: "[\u0C66-\u0C6F]",
        thai: "[\u0E50-\u0E59]",
        tibt: "[\u0F20-\u0F29]",
        latn: "\\d"
    },
    Tg = {
        arab: [1632, 1641],
        arabext: [1776, 1785],
        bali: [6992, 7001],
        beng: [2534, 2543],
        deva: [2406, 2415],
        fullwide: [65296, 65303],
        gujr: [2790, 2799],
        khmr: [6112, 6121],
        knda: [3302, 3311],
        laoo: [3792, 3801],
        limb: [6470, 6479],
        mlym: [3430, 3439],
        mong: [6160, 6169],
        mymr: [4160, 4169],
        orya: [2918, 2927],
        tamldec: [3046, 3055],
        telu: [3174, 3183],
        thai: [3664, 3673],
        tibt: [3872, 3881]
    },
    WN = em.hanidec.replace(/[\[|\]]/g, "").split("");

function VN(t) {
    let e = parseInt(t, 10);
    if (isNaN(e)) {
        e = "";
        for (let r = 0; r < t.length; r++) {
            const n = t.charCodeAt(r);
            if (t[r].search(em.hanidec) !== -1) e += WN.indexOf(t[r]);
            else
                for (const i in Tg) {
                    const [s, o] = Tg[i];
                    n >= s && n <= o && (e += n - s)
                }
        }
        return parseInt(e, 10)
    } else return e
}

function vi({
    numberingSystem: t
}, e = "") {
    return new RegExp(`${em[t||"latn"]}${e}`)
}
const GN = "missing Intl.DateTimeFormat.formatToParts support";

function er(t, e = r => r) {
    return {
        regex: t,
        deser: ([r]) => e(VN(r))
    }
}
const YN = String.fromCharCode(160),
    p6 = `[ ${YN}]`,
    m6 = new RegExp(p6, "g");

function KN(t) {
    return t.replace(/\./g, "\\.?").replace(m6, p6)
}

function Og(t) {
    return t.replace(/\./g, "").replace(m6, " ").toLowerCase()
}

function gi(t, e) {
    return t === null ? null : {
        regex: RegExp(t.map(KN).join("|")),
        deser: ([r]) => t.findIndex(n => Og(r) === Og(n)) + e
    }
}

function Rg(t, e) {
    return {
        regex: t,
        deser: ([, r, n]) => Rh(r, n),
        groups: e
    }
}

function U0(t) {
    return {
        regex: t,
        deser: ([e]) => e
    }
}

function ZN(t) {
    return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
}

function JN(t, e) {
    const r = vi(e),
        n = vi(e, "{2}"),
        i = vi(e, "{3}"),
        s = vi(e, "{4}"),
        o = vi(e, "{6}"),
        a = vi(e, "{1,2}"),
        c = vi(e, "{1,3}"),
        d = vi(e, "{1,6}"),
        y = vi(e, "{1,9}"),
        I = vi(e, "{2,4}"),
        N = vi(e, "{4,6}"),
        E = V => ({
            regex: RegExp(ZN(V.val)),
            deser: ([P]) => P,
            literal: !0
        }),
        j = (V => {
            if (t.literal) return E(V);
            switch (V.val) {
                case "G":
                    return gi(e.eras("short", !1), 0);
                case "GG":
                    return gi(e.eras("long", !1), 0);
                case "y":
                    return er(d);
                case "yy":
                    return er(I, up);
                case "yyyy":
                    return er(s);
                case "yyyyy":
                    return er(N);
                case "yyyyyy":
                    return er(o);
                case "M":
                    return er(a);
                case "MM":
                    return er(n);
                case "MMM":
                    return gi(e.months("short", !0, !1), 1);
                case "MMMM":
                    return gi(e.months("long", !0, !1), 1);
                case "L":
                    return er(a);
                case "LL":
                    return er(n);
                case "LLL":
                    return gi(e.months("short", !1, !1), 1);
                case "LLLL":
                    return gi(e.months("long", !1, !1), 1);
                case "d":
                    return er(a);
                case "dd":
                    return er(n);
                case "o":
                    return er(c);
                case "ooo":
                    return er(i);
                case "HH":
                    return er(n);
                case "H":
                    return er(a);
                case "hh":
                    return er(n);
                case "h":
                    return er(a);
                case "mm":
                    return er(n);
                case "m":
                    return er(a);
                case "q":
                    return er(a);
                case "qq":
                    return er(n);
                case "s":
                    return er(a);
                case "ss":
                    return er(n);
                case "S":
                    return er(c);
                case "SSS":
                    return er(i);
                case "u":
                    return U0(y);
                case "uu":
                    return U0(a);
                case "uuu":
                    return er(r);
                case "a":
                    return gi(e.meridiems(), 0);
                case "kkkk":
                    return er(s);
                case "kk":
                    return er(I, up);
                case "W":
                    return er(a);
                case "WW":
                    return er(n);
                case "E":
                case "c":
                    return er(r);
                case "EEE":
                    return gi(e.weekdays("short", !1, !1), 1);
                case "EEEE":
                    return gi(e.weekdays("long", !1, !1), 1);
                case "ccc":
                    return gi(e.weekdays("short", !0, !1), 1);
                case "cccc":
                    return gi(e.weekdays("long", !0, !1), 1);
                case "Z":
                case "ZZ":
                    return Rg(new RegExp(`([+-]${a.source})(?::(${n.source}))?`), 2);
                case "ZZZ":
                    return Rg(new RegExp(`([+-]${a.source})(${n.source})?`), 2);
                case "z":
                    return U0(/[a-z_+-/]{1,256}?/i);
                default:
                    return E(V)
            }
        })(t) || {
            invalidReason: GN
        };
    return j.token = t, j
}
const XN = {
    year: {
        "2-digit": "yy",
        numeric: "yyyyy"
    },
    month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
    },
    day: {
        numeric: "d",
        "2-digit": "dd"
    },
    weekday: {
        short: "EEE",
        long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour: {
        numeric: "h",
        "2-digit": "hh"
    },
    minute: {
        numeric: "m",
        "2-digit": "mm"
    },
    second: {
        numeric: "s",
        "2-digit": "ss"
    }
};

function eT(t, e, r) {
    const {
        type: n,
        value: i
    } = t;
    if (n === "literal") return {
        literal: !0,
        val: i
    };
    const s = r[n];
    let o = XN[n];
    if (typeof o == "object" && (o = o[s]), o) return {
        literal: !1,
        val: o
    }
}

function tT(t) {
    return [`^${t.map(r=>r.regex).reduce((r,n)=>`${r}(${n.source})`,"")}$`, t]
}

function rT(t, e, r) {
    const n = t.match(e);
    if (n) {
        const i = {};
        let s = 1;
        for (const o in r)
            if (Ua(r, o)) {
                const a = r[o],
                    c = a.groups ? a.groups + 1 : 1;
                !a.literal && a.token && (i[a.token.val[0]] = a.deser(n.slice(s, s + c))), s += c
            }
        return [n, i]
    } else return [n, {}]
}

function nT(t) {
    const e = s => {
        switch (s) {
            case "S":
                return "millisecond";
            case "s":
                return "second";
            case "m":
                return "minute";
            case "h":
            case "H":
                return "hour";
            case "d":
                return "day";
            case "o":
                return "ordinal";
            case "L":
            case "M":
                return "month";
            case "y":
                return "year";
            case "E":
            case "c":
                return "weekday";
            case "W":
                return "weekNumber";
            case "k":
                return "weekYear";
            case "q":
                return "quarter";
            default:
                return null
        }
    };
    let r = null,
        n;
    return $t(t.z) || (r = As.create(t.z)), $t(t.Z) || (r || (r = new yn(t.Z)), n = t.Z), $t(t.q) || (t.M = (t.q - 1) * 3 + 1), $t(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), $t(t.u) || (t.S = V1(t.u)), [Object.keys(t).reduce((s, o) => {
        const a = e(o);
        return a && (s[a] = t[o]), s
    }, {}), r, n]
}
let z0 = null;

function iT() {
    return z0 || (z0 = mt.fromMillis(1555555555555)), z0
}

function sT(t, e) {
    if (t.literal) return t;
    const r = _n.macroTokenToFormatOpts(t.val);
    if (!r) return t;
    const s = _n.create(e, r).formatDateTimeParts(iT()).map(o => eT(o, e, r));
    return s.includes(void 0) ? t : s
}

function oT(t, e) {
    return Array.prototype.concat(...t.map(r => sT(r, e)))
}

function v6(t, e, r) {
    const n = oT(_n.parseFormat(r), t),
        i = n.map(o => JN(o, t)),
        s = i.find(o => o.invalidReason);
    if (s) return {
        input: e,
        tokens: n,
        invalidReason: s.invalidReason
    }; {
        const [o, a] = tT(i), c = RegExp(o, "i"), [d, y] = rT(e, c, a), [I, N, E] = y ? nT(y) : [null, null, void 0];
        if (Ua(y, "a") && Ua(y, "H")) throw new Pu("Can't include meridiem when specifying 24-hour format");
        return {
            input: e,
            tokens: n,
            regex: c,
            rawMatches: d,
            matches: y,
            result: I,
            zone: N,
            specificOffset: E
        }
    }
}

function aT(t, e, r) {
    const {
        result: n,
        zone: i,
        specificOffset: s,
        invalidReason: o
    } = v6(t, e, r);
    return [n, i, s, o]
}
const g6 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
    y6 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

function ri(t, e) {
    return new Si("unit out of range", `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`)
}

function w6(t, e, r) {
    const n = new Date(Date.UTC(t, e - 1, r));
    t < 100 && t >= 0 && n.setUTCFullYear(n.getUTCFullYear() - 1900);
    const i = n.getUTCDay();
    return i === 0 ? 7 : i
}

function x6(t, e, r) {
    return r + (Dl(t) ? y6 : g6)[e - 1]
}

function b6(t, e) {
    const r = Dl(t) ? y6 : g6,
        n = r.findIndex(s => s < e),
        i = e - r[n];
    return {
        month: n + 1,
        day: i
    }
}

function dp(t) {
    const {
        year: e,
        month: r,
        day: n
    } = t, i = x6(e, r, n), s = w6(e, r, n);
    let o = Math.floor((i - s + 10) / 7),
        a;
    return o < 1 ? (a = e - 1, o = kc(a)) : o > kc(e) ? (a = e + 1, o = 1) : a = e, Ce({
        weekYear: a,
        weekNumber: o,
        weekday: s
    }, Dh(t))
}

function Dg(t) {
    const {
        weekYear: e,
        weekNumber: r,
        weekday: n
    } = t, i = w6(e, 1, 4), s = Yu(e);
    let o = r * 7 + n - i - 3,
        a;
    o < 1 ? (a = e - 1, o += Yu(a)) : o > s ? (a = e + 1, o -= Yu(e)) : a = e;
    const {
        month: c,
        day: d
    } = b6(a, o);
    return Ce({
        year: a,
        month: c,
        day: d
    }, Dh(t))
}

function j0(t) {
    const {
        year: e,
        month: r,
        day: n
    } = t, i = x6(e, r, n);
    return Ce({
        year: e,
        ordinal: i
    }, Dh(t))
}

function Pg(t) {
    const {
        year: e,
        ordinal: r
    } = t, {
        month: n,
        day: i
    } = b6(e, r);
    return Ce({
        year: e,
        month: n,
        day: i
    }, Dh(t))
}

function uT(t) {
    const e = Oh(t.weekYear),
        r = hs(t.weekNumber, 1, kc(t.weekYear)),
        n = hs(t.weekday, 1, 7);
    return e ? r ? n ? !1 : ri("weekday", t.weekday) : ri("week", t.week) : ri("weekYear", t.weekYear)
}

function lT(t) {
    const e = Oh(t.year),
        r = hs(t.ordinal, 1, Yu(t.year));
    return e ? r ? !1 : ri("ordinal", t.ordinal) : ri("year", t.year)
}

function A6(t) {
    const e = Oh(t.year),
        r = hs(t.month, 1, 12),
        n = hs(t.day, 1, Bc(t.year, t.month));
    return e ? r ? n ? !1 : ri("day", t.day) : ri("month", t.month) : ri("year", t.year)
}

function S6(t) {
    const {
        hour: e,
        minute: r,
        second: n,
        millisecond: i
    } = t, s = hs(e, 0, 23) || e === 24 && r === 0 && n === 0 && i === 0, o = hs(r, 0, 59), a = hs(n, 0, 59), c = hs(i, 0, 999);
    return s ? o ? a ? c ? !1 : ri("millisecond", i) : ri("second", n) : ri("minute", r) : ri("hour", e)
}
const $0 = "Invalid DateTime",
    Lg = 864e13;

function gf(t) {
    return new Si("unsupported zone", `the zone "${t.name}" is not supported`)
}

function H0(t) {
    return t.weekData === null && (t.weekData = dp(t.c)), t.weekData
}

function Eu(t, e) {
    const r = {
        ts: t.ts,
        zone: t.zone,
        c: t.c,
        o: t.o,
        loc: t.loc,
        invalid: t.invalid
    };
    return new mt(xt(Ce(Ce({}, r), e), {
        old: r
    }))
}

function M6(t, e, r) {
    let n = t - e * 60 * 1e3;
    const i = r.offset(n);
    if (e === i) return [n, e];
    n -= (i - e) * 60 * 1e3;
    const s = r.offset(n);
    return i === s ? [n, i] : [t - Math.min(i, s) * 60 * 1e3, Math.max(i, s)]
}

function Fg(t, e) {
    t += e * 60 * 1e3;
    const r = new Date(t);
    return {
        year: r.getUTCFullYear(),
        month: r.getUTCMonth() + 1,
        day: r.getUTCDate(),
        hour: r.getUTCHours(),
        minute: r.getUTCMinutes(),
        second: r.getUTCSeconds(),
        millisecond: r.getUTCMilliseconds()
    }
}

function jf(t, e, r) {
    return M6(Y1(t), e, r)
}

function Ug(t, e) {
    const r = t.o,
        n = t.c.year + Math.trunc(e.years),
        i = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3,
        s = xt(Ce({}, t.c), {
            year: n,
            month: i,
            day: Math.min(t.c.day, Bc(n, i)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
        }),
        o = qt.fromObject({
            years: e.years - Math.trunc(e.years),
            quarters: e.quarters - Math.trunc(e.quarters),
            months: e.months - Math.trunc(e.months),
            weeks: e.weeks - Math.trunc(e.weeks),
            days: e.days - Math.trunc(e.days),
            hours: e.hours,
            minutes: e.minutes,
            seconds: e.seconds,
            milliseconds: e.milliseconds
        }).as("milliseconds"),
        a = Y1(s);
    let [c, d] = M6(a, r, t.zone);
    return o !== 0 && (c += o, d = t.zone.offset(c)), {
        ts: c,
        o: d
    }
}

function _u(t, e, r, n, i, s) {
    const {
        setZone: o,
        zone: a
    } = r;
    if (t && Object.keys(t).length !== 0) {
        const c = e || a,
            d = mt.fromObject(t, xt(Ce({}, r), {
                zone: c,
                specificOffset: s
            }));
        return o ? d : d.setZone(a)
    } else return mt.invalid(new Si("unparsable", `the input "${i}" can't be parsed as ${n}`))
}

function yf(t, e, r = !0) {
    return t.isValid ? _n.create(yr.create("en-US"), {
        allowZ: r,
        forceSimple: !0
    }).formatDateTimeFromString(t, e) : null
}

function Q0(t, e) {
    const r = t.c.year > 9999 || t.c.year < 0;
    let n = "";
    return r && t.c.year >= 0 && (n += "+"), n += Br(t.c.year, r ? 6 : 4), e ? (n += "-", n += Br(t.c.month), n += "-", n += Br(t.c.day)) : (n += Br(t.c.month), n += Br(t.c.day)), n
}

function zg(t, e, r, n, i, s) {
    let o = Br(t.c.hour);
    return e ? (o += ":", o += Br(t.c.minute), (t.c.second !== 0 || !r) && (o += ":")) : o += Br(t.c.minute), (t.c.second !== 0 || !r) && (o += Br(t.c.second), (t.c.millisecond !== 0 || !n) && (o += ".", o += Br(t.c.millisecond, 3))), i && (t.isOffsetFixed && t.offset === 0 && !s ? o += "Z" : t.o < 0 ? (o += "-", o += Br(Math.trunc(-t.o / 60)), o += ":", o += Br(Math.trunc(-t.o % 60))) : (o += "+", o += Br(Math.trunc(t.o / 60)), o += ":", o += Br(Math.trunc(t.o % 60)))), s && (o += "[" + t.zone.ianaName + "]"), o
}
const E6 = {
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
    },
    fT = {
        weekNumber: 1,
        weekday: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
    },
    cT = {
        ordinal: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
    },
    _6 = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
    hT = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
    dT = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

function jg(t) {
    const e = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
    }[t.toLowerCase()];
    if (!e) throw new k3(t);
    return e
}

function $g(t, e) {
    const r = Fs(e.zone, Tr.defaultZone),
        n = yr.fromObject(e),
        i = Tr.now();
    let s, o;
    if ($t(t.year)) s = i;
    else {
        for (const d of _6) $t(t[d]) && (t[d] = E6[d]);
        const a = A6(t) || S6(t);
        if (a) return mt.invalid(a);
        const c = r.offset(i);
        [s, o] = jf(t, c, r)
    }
    return new mt({
        ts: s,
        zone: r,
        loc: n,
        o
    })
}

function Hg(t, e, r) {
    const n = $t(r.round) ? !0 : r.round,
        i = (o, a) => (o = G1(o, n || r.calendary ? 0 : 2, !0), e.loc.clone(r).relFormatter(r).format(o, a)),
        s = o => r.calendary ? e.hasSame(t, o) ? 0 : e.startOf(o).diff(t.startOf(o), o).get(o) : e.diff(t, o).get(o);
    if (r.unit) return i(s(r.unit), r.unit);
    for (const o of r.units) {
        const a = s(o);
        if (Math.abs(a) >= 1) return i(a, o)
    }
    return i(t > e ? -0 : 0, r.units[r.units.length - 1])
}

function Qg(t) {
    let e = {},
        r;
    return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], r = Array.from(t).slice(0, t.length - 1)) : r = Array.from(t), [e, r]
}
class mt {
    constructor(e) {
        const r = e.zone || Tr.defaultZone;
        let n = e.invalid || (Number.isNaN(e.ts) ? new Si("invalid input") : null) || (r.isValid ? null : gf(r));
        this.ts = $t(e.ts) ? Tr.now() : e.ts;
        let i = null,
            s = null;
        if (!n)
            if (e.old && e.old.ts === this.ts && e.old.zone.equals(r))[i, s] = [e.old.c, e.old.o];
            else {
                const a = r.offset(this.ts);
                i = Fg(this.ts, a), n = Number.isNaN(i.year) ? new Si("invalid input") : null, i = n ? null : i, s = n ? null : a
            }
        this._zone = r, this.loc = e.loc || yr.create(), this.invalid = n, this.weekData = null, this.c = i, this.o = s, this.isLuxonDateTime = !0
    }
    static now() {
        return new mt({})
    }
    static local() {
        const [e, r] = Qg(arguments), [n, i, s, o, a, c, d] = r;
        return $g({
            year: n,
            month: i,
            day: s,
            hour: o,
            minute: a,
            second: c,
            millisecond: d
        }, e)
    }
    static utc() {
        const [e, r] = Qg(arguments), [n, i, s, o, a, c, d] = r;
        return e.zone = yn.utcInstance, $g({
            year: n,
            month: i,
            day: s,
            hour: o,
            minute: a,
            second: c,
            millisecond: d
        }, e)
    }
    static fromJSDate(e, r = {}) {
        const n = bk(e) ? e.valueOf() : NaN;
        if (Number.isNaN(n)) return mt.invalid("invalid input");
        const i = Fs(r.zone, Tr.defaultZone);
        return i.isValid ? new mt({
            ts: n,
            zone: i,
            loc: yr.fromObject(r)
        }) : mt.invalid(gf(i))
    }
    static fromMillis(e, r = {}) {
        if (_o(e)) return e < -Lg || e > Lg ? mt.invalid("Timestamp out of range") : new mt({
            ts: e,
            zone: Fs(r.zone, Tr.defaultZone),
            loc: yr.fromObject(r)
        });
        throw new ei(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`)
    }
    static fromSeconds(e, r = {}) {
        if (_o(e)) return new mt({
            ts: e * 1e3,
            zone: Fs(r.zone, Tr.defaultZone),
            loc: yr.fromObject(r)
        });
        throw new ei("fromSeconds requires a numerical input")
    }
    static fromObject(e, r = {}) {
        e = e || {};
        const n = Fs(r.zone, Tr.defaultZone);
        if (!n.isValid) return mt.invalid(gf(n));
        const i = Tr.now(),
            s = $t(r.specificOffset) ? n.offset(i) : r.specificOffset,
            o = Nc(e, jg),
            a = !$t(o.ordinal),
            c = !$t(o.year),
            d = !$t(o.month) || !$t(o.day),
            y = c || d,
            I = o.weekYear || o.weekNumber,
            N = yr.fromObject(r);
        if ((y || a) && I) throw new Pu("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        if (d && a) throw new Pu("Can't mix ordinal dates with month/day");
        const E = I || o.weekday && !y;
        let T, j, V = Fg(i, s);
        E ? (T = hT, j = fT, V = dp(V)) : a ? (T = dT, j = cT, V = j0(V)) : (T = _6, j = E6);
        let P = !1;
        for (const J of T) {
            const pe = o[J];
            $t(pe) ? P ? o[J] = j[J] : o[J] = V[J] : P = !0
        }
        const O = E ? uT(o) : a ? lT(o) : A6(o),
            R = O || S6(o);
        if (R) return mt.invalid(R);
        const q = E ? Dg(o) : a ? Pg(o) : o,
            [W, Y] = jf(q, s, n),
            G = new mt({
                ts: W,
                zone: n,
                o: Y,
                loc: N
            });
        return o.weekday && y && e.weekday !== G.weekday ? mt.invalid("mismatched weekday", `you can't specify both a weekday of ${o.weekday} and a date of ${G.toISO()}`) : G
    }
    static fromISO(e, r = {}) {
        const [n, i] = IN(e);
        return _u(n, i, r, "ISO 8601", e)
    }
    static fromRFC2822(e, r = {}) {
        const [n, i] = CN(e);
        return _u(n, i, r, "RFC 2822", e)
    }
    static fromHTTP(e, r = {}) {
        const [n, i] = BN(e);
        return _u(n, i, r, "HTTP", r)
    }
    static fromFormat(e, r, n = {}) {
        if ($t(e) || $t(r)) throw new ei("fromFormat requires an input string and a format");
        const {
            locale: i = null,
            numberingSystem: s = null
        } = n, o = yr.fromOpts({
            locale: i,
            numberingSystem: s,
            defaultToEN: !0
        }), [a, c, d, y] = aT(o, e, r);
        return y ? mt.invalid(y) : _u(a, c, n, `format ${r}`, e, d)
    }
    static fromString(e, r, n = {}) {
        return mt.fromFormat(e, r, n)
    }
    static fromSQL(e, r = {}) {
        const [n, i] = PN(e);
        return _u(n, i, r, "SQL", e)
    }
    static invalid(e, r = null) {
        if (!e) throw new ei("need to specify a reason the DateTime is invalid");
        const n = e instanceof Si ? e : new Si(e, r);
        if (Tr.throwOnInvalid) throw new mk(n);
        return new mt({
            invalid: n
        })
    }
    static isDateTime(e) {
        return e && e.isLuxonDateTime || !1
    }
    get(e) {
        return this[e]
    }
    get isValid() {
        return this.invalid === null
    }
    get invalidReason() {
        return this.invalid ? this.invalid.reason : null
    }
    get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null
    }
    get locale() {
        return this.isValid ? this.loc.locale : null
    }
    get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null
    }
    get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null
    }
    get zone() {
        return this._zone
    }
    get zoneName() {
        return this.isValid ? this.zone.name : null
    }
    get year() {
        return this.isValid ? this.c.year : NaN
    }
    get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN
    }
    get month() {
        return this.isValid ? this.c.month : NaN
    }
    get day() {
        return this.isValid ? this.c.day : NaN
    }
    get hour() {
        return this.isValid ? this.c.hour : NaN
    }
    get minute() {
        return this.isValid ? this.c.minute : NaN
    }
    get second() {
        return this.isValid ? this.c.second : NaN
    }
    get millisecond() {
        return this.isValid ? this.c.millisecond : NaN
    }
    get weekYear() {
        return this.isValid ? H0(this).weekYear : NaN
    }
    get weekNumber() {
        return this.isValid ? H0(this).weekNumber : NaN
    }
    get weekday() {
        return this.isValid ? H0(this).weekday : NaN
    }
    get ordinal() {
        return this.isValid ? j0(this.c).ordinal : NaN
    }
    get monthShort() {
        return this.isValid ? vf.months("short", {
            locObj: this.loc
        })[this.month - 1] : null
    }
    get monthLong() {
        return this.isValid ? vf.months("long", {
            locObj: this.loc
        })[this.month - 1] : null
    }
    get weekdayShort() {
        return this.isValid ? vf.weekdays("short", {
            locObj: this.loc
        })[this.weekday - 1] : null
    }
    get weekdayLong() {
        return this.isValid ? vf.weekdays("long", {
            locObj: this.loc
        })[this.weekday - 1] : null
    }
    get offset() {
        return this.isValid ? +this.o : NaN
    }
    get offsetNameShort() {
        return this.isValid ? this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
        }) : null
    }
    get offsetNameLong() {
        return this.isValid ? this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
        }) : null
    }
    get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null
    }
    get isInDST() {
        return this.isOffsetFixed ? !1 : this.offset > this.set({
            month: 1,
            day: 1
        }).offset || this.offset > this.set({
            month: 5
        }).offset
    }
    get isInLeapYear() {
        return Dl(this.year)
    }
    get daysInMonth() {
        return Bc(this.year, this.month)
    }
    get daysInYear() {
        return this.isValid ? Yu(this.year) : NaN
    }
    get weeksInWeekYear() {
        return this.isValid ? kc(this.weekYear) : NaN
    }
    resolvedLocaleOptions(e = {}) {
        const {
            locale: r,
            numberingSystem: n,
            calendar: i
        } = _n.create(this.loc.clone(e), e).resolvedOptions(this);
        return {
            locale: r,
            numberingSystem: n,
            outputCalendar: i
        }
    }
    toUTC(e = 0, r = {}) {
        return this.setZone(yn.instance(e), r)
    }
    toLocal() {
        return this.setZone(Tr.defaultZone)
    }
    setZone(e, {
        keepLocalTime: r = !1,
        keepCalendarTime: n = !1
    } = {}) {
        if (e = Fs(e, Tr.defaultZone), e.equals(this.zone)) return this;
        if (e.isValid) {
            let i = this.ts;
            if (r || n) {
                const s = e.offset(this.ts),
                    o = this.toObject();
                [i] = jf(o, s, e)
            }
            return Eu(this, {
                ts: i,
                zone: e
            })
        } else return mt.invalid(gf(e))
    }
    reconfigure({
        locale: e,
        numberingSystem: r,
        outputCalendar: n
    } = {}) {
        const i = this.loc.clone({
            locale: e,
            numberingSystem: r,
            outputCalendar: n
        });
        return Eu(this, {
            loc: i
        })
    }
    setLocale(e) {
        return this.reconfigure({
            locale: e
        })
    }
    set(e) {
        if (!this.isValid) return this;
        const r = Nc(e, jg),
            n = !$t(r.weekYear) || !$t(r.weekNumber) || !$t(r.weekday),
            i = !$t(r.ordinal),
            s = !$t(r.year),
            o = !$t(r.month) || !$t(r.day),
            a = s || o,
            c = r.weekYear || r.weekNumber;
        if ((a || i) && c) throw new Pu("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        if (o && i) throw new Pu("Can't mix ordinal dates with month/day");
        let d;
        n ? d = Dg(Ce(Ce({}, dp(this.c)), r)) : $t(r.ordinal) ? (d = Ce(Ce({}, this.toObject()), r), $t(r.day) && (d.day = Math.min(Bc(d.year, d.month), d.day))) : d = Pg(Ce(Ce({}, j0(this.c)), r));
        const [y, I] = jf(d, this.o, this.zone);
        return Eu(this, {
            ts: y,
            o: I
        })
    }
    plus(e) {
        if (!this.isValid) return this;
        const r = qt.fromDurationLike(e);
        return Eu(this, Ug(this, r))
    }
    minus(e) {
        if (!this.isValid) return this;
        const r = qt.fromDurationLike(e).negate();
        return Eu(this, Ug(this, r))
    }
    startOf(e) {
        if (!this.isValid) return this;
        const r = {},
            n = qt.normalizeUnit(e);
        switch (n) {
            case "years":
                r.month = 1;
            case "quarters":
            case "months":
                r.day = 1;
            case "weeks":
            case "days":
                r.hour = 0;
            case "hours":
                r.minute = 0;
            case "minutes":
                r.second = 0;
            case "seconds":
                r.millisecond = 0;
                break
        }
        if (n === "weeks" && (r.weekday = 1), n === "quarters") {
            const i = Math.ceil(this.month / 3);
            r.month = (i - 1) * 3 + 1
        }
        return this.set(r)
    }
    endOf(e) {
        return this.isValid ? this.plus({
            [e]: 1
        }).startOf(e).minus(1) : this
    }
    toFormat(e, r = {}) {
        return this.isValid ? _n.create(this.loc.redefaultToEN(r)).formatDateTimeFromString(this, e) : $0
    }
    toLocaleString(e = ap, r = {}) {
        return this.isValid ? _n.create(this.loc.clone(r), e).formatDateTime(this) : $0
    }
    toLocaleParts(e = {}) {
        return this.isValid ? _n.create(this.loc.clone(e), e).formatDateTimeParts(this) : []
    }
    toISO({
        format: e = "extended",
        suppressSeconds: r = !1,
        suppressMilliseconds: n = !1,
        includeOffset: i = !0,
        extendedZone: s = !1
    } = {}) {
        if (!this.isValid) return null;
        const o = e === "extended";
        let a = Q0(this, o);
        return a += "T", a += zg(this, o, r, n, i, s), a
    }
    toISODate({
        format: e = "extended"
    } = {}) {
        return this.isValid ? Q0(this, e === "extended") : null
    }
    toISOWeekDate() {
        return yf(this, "kkkk-'W'WW-c")
    }
    toISOTime({
        suppressMilliseconds: e = !1,
        suppressSeconds: r = !1,
        includeOffset: n = !0,
        includePrefix: i = !1,
        extendedZone: s = !1,
        format: o = "extended"
    } = {}) {
        return this.isValid ? (i ? "T" : "") + zg(this, o === "extended", r, e, n, s) : null
    }
    toRFC2822() {
        return yf(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1)
    }
    toHTTP() {
        return yf(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'")
    }
    toSQLDate() {
        return this.isValid ? Q0(this, !0) : null
    }
    toSQLTime({
        includeOffset: e = !0,
        includeZone: r = !1,
        includeOffsetSpace: n = !0
    } = {}) {
        let i = "HH:mm:ss.SSS";
        return (r || e) && (n && (i += " "), r ? i += "z" : e && (i += "ZZ")), yf(this, i, !0)
    }
    toSQL(e = {}) {
        return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null
    }
    toString() {
        return this.isValid ? this.toISO() : $0
    }
    valueOf() {
        return this.toMillis()
    }
    toMillis() {
        return this.isValid ? this.ts : NaN
    }
    toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN
    }
    toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN
    }
    toJSON() {
        return this.toISO()
    }
    toBSON() {
        return this.toJSDate()
    }
    toObject(e = {}) {
        if (!this.isValid) return {};
        const r = Ce({}, this.c);
        return e.includeConfig && (r.outputCalendar = this.outputCalendar, r.numberingSystem = this.loc.numberingSystem, r.locale = this.loc.locale), r
    }
    toJSDate() {
        return new Date(this.isValid ? this.ts : NaN)
    }
    diff(e, r = "milliseconds", n = {}) {
        if (!this.isValid || !e.isValid) return qt.invalid("created by diffing an invalid DateTime");
        const i = Ce({
                locale: this.locale,
                numberingSystem: this.numberingSystem
            }, n),
            s = Ak(r).map(qt.normalizeUnit),
            o = e.valueOf() > this.valueOf(),
            a = o ? this : e,
            c = o ? e : this,
            d = qN(a, c, s, i);
        return o ? d.negate() : d
    }
    diffNow(e = "milliseconds", r = {}) {
        return this.diff(mt.now(), e, r)
    }
    until(e) {
        return this.isValid ? Mr.fromDateTimes(this, e) : this
    }
    hasSame(e, r) {
        if (!this.isValid) return !1;
        const n = e.valueOf(),
            i = this.setZone(e.zone, {
                keepLocalTime: !0
            });
        return i.startOf(r) <= n && n <= i.endOf(r)
    }
    equals(e) {
        return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc)
    }
    toRelative(e = {}) {
        if (!this.isValid) return null;
        const r = e.base || mt.fromObject({}, {
                zone: this.zone
            }),
            n = e.padding ? this < r ? -e.padding : e.padding : 0;
        let i = ["years", "months", "days", "hours", "minutes", "seconds"],
            s = e.unit;
        return Array.isArray(e.unit) && (i = e.unit, s = void 0), Hg(r, this.plus(n), xt(Ce({}, e), {
            numeric: "always",
            units: i,
            unit: s
        }))
    }
    toRelativeCalendar(e = {}) {
        return this.isValid ? Hg(e.base || mt.fromObject({}, {
            zone: this.zone
        }), this, xt(Ce({}, e), {
            numeric: "auto",
            units: ["years", "months", "days"],
            calendary: !0
        })) : null
    }
    static min(...e) {
        if (!e.every(mt.isDateTime)) throw new ei("min requires all arguments be DateTimes");
        return bg(e, r => r.valueOf(), Math.min)
    }
    static max(...e) {
        if (!e.every(mt.isDateTime)) throw new ei("max requires all arguments be DateTimes");
        return bg(e, r => r.valueOf(), Math.max)
    }
    static fromFormatExplain(e, r, n = {}) {
        const {
            locale: i = null,
            numberingSystem: s = null
        } = n, o = yr.fromOpts({
            locale: i,
            numberingSystem: s,
            defaultToEN: !0
        });
        return v6(o, e, r)
    }
    static fromStringExplain(e, r, n = {}) {
        return mt.fromFormatExplain(e, r, n)
    }
    static get DATE_SHORT() {
        return ap
    }
    static get DATE_MED() {
        return N3
    }
    static get DATE_MED_WITH_WEEKDAY() {
        return yk
    }
    static get DATE_FULL() {
        return T3
    }
    static get DATE_HUGE() {
        return O3
    }
    static get TIME_SIMPLE() {
        return R3
    }
    static get TIME_WITH_SECONDS() {
        return D3
    }
    static get TIME_WITH_SHORT_OFFSET() {
        return P3
    }
    static get TIME_WITH_LONG_OFFSET() {
        return L3
    }
    static get TIME_24_SIMPLE() {
        return F3
    }
    static get TIME_24_WITH_SECONDS() {
        return U3
    }
    static get TIME_24_WITH_SHORT_OFFSET() {
        return z3
    }
    static get TIME_24_WITH_LONG_OFFSET() {
        return j3
    }
    static get DATETIME_SHORT() {
        return $3
    }
    static get DATETIME_SHORT_WITH_SECONDS() {
        return H3
    }
    static get DATETIME_MED() {
        return Q3
    }
    static get DATETIME_MED_WITH_SECONDS() {
        return q3
    }
    static get DATETIME_MED_WITH_WEEKDAY() {
        return wk
    }
    static get DATETIME_FULL() {
        return W3
    }
    static get DATETIME_FULL_WITH_SECONDS() {
        return V3
    }
    static get DATETIME_HUGE() {
        return G3
    }
    static get DATETIME_HUGE_WITH_SECONDS() {
        return Y3
    }
}

function Iu(t) {
    if (mt.isDateTime(t)) return t;
    if (t && t.valueOf && _o(t.valueOf())) return mt.fromJSDate(t);
    if (t && typeof t == "object") return mt.fromObject(t);
    throw new ei(`Unknown datetime argument: ${t}, of type ${typeof t}`)
}

function pT(t) {
    if (t.length >= 255) throw new TypeError("Alphabet too long");
    for (var e = new Uint8Array(256), r = 0; r < e.length; r++) e[r] = 255;
    for (var n = 0; n < t.length; n++) {
        var i = t.charAt(n),
            s = i.charCodeAt(0);
        if (e[s] !== 255) throw new TypeError(i + " is ambiguous");
        e[s] = n
    }
    var o = t.length,
        a = t.charAt(0),
        c = Math.log(o) / Math.log(256),
        d = Math.log(256) / Math.log(o);

    function y(E) {
        if (E instanceof Uint8Array || (ArrayBuffer.isView(E) ? E = new Uint8Array(E.buffer, E.byteOffset, E.byteLength) : Array.isArray(E) && (E = Uint8Array.from(E))), !(E instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
        if (E.length === 0) return "";
        for (var T = 0, j = 0, V = 0, P = E.length; V !== P && E[V] === 0;) V++, T++;
        for (var O = (P - V) * d + 1 >>> 0, R = new Uint8Array(O); V !== P;) {
            for (var q = E[V], W = 0, Y = O - 1;
                (q !== 0 || W < j) && Y !== -1; Y--, W++) q += 256 * R[Y] >>> 0, R[Y] = q % o >>> 0, q = q / o >>> 0;
            if (q !== 0) throw new Error("Non-zero carry");
            j = W, V++
        }
        for (var G = O - j; G !== O && R[G] === 0;) G++;
        for (var J = a.repeat(T); G < O; ++G) J += t.charAt(R[G]);
        return J
    }

    function I(E) {
        if (typeof E != "string") throw new TypeError("Expected String");
        if (E.length === 0) return new Uint8Array;
        for (var T = 0, j = 0, V = 0; E[T] === a;) j++, T++;
        for (var P = (E.length - T) * c + 1 >>> 0, O = new Uint8Array(P); E[T];) {
            var R = e[E.charCodeAt(T)];
            if (R === 255) return;
            for (var q = 0, W = P - 1;
                (R !== 0 || q < V) && W !== -1; W--, q++) R += o * O[W] >>> 0, O[W] = R % 256 >>> 0, R = R / 256 >>> 0;
            if (R !== 0) throw new Error("Non-zero carry");
            V = q, T++
        }
        for (var Y = P - V; Y !== P && O[Y] === 0;) Y++;
        for (var G = new Uint8Array(j + (P - Y)), J = j; Y !== P;) G[J++] = O[Y++];
        return G
    }

    function N(E) {
        var T = I(E);
        if (T) return T;
        throw new Error("Non-base" + o + " character")
    }
    return {
        encode: y,
        decodeUnsafe: I,
        decode: N
    }
}
var mT = pT;
const vT = mT,
    gT = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var pp = vT(gT);
const yT = pk.create({
        baseURL: "/api/rewards"
    }),
    la = class {
        constructor(e = null) {
            this.token = e
        }
        static getInstance() {
            return la.instance || (la.instance = new la), la.instance
        }
        setToken(e) {
            this.token = e
        }
    };
let ya = la;
nm(ya, "instance");
const q0 = async (t, e, r = 60) => {
        const n = new TextEncoder().encode(JSON.stringify({
                action: t,
                exp: mt.local().toUTC().plus({
                    minutes: r
                }).toUnixInteger()
            })),
            i = await e.signMessage(n),
            s = e.publicKey.toBase58(),
            o = pp.encode(n),
            a = pp.encode(i);
        return `${s}.${o}.${a}`
    },
    W0 = async (t, e, r, n = 5) => {
        const {
            method: i,
            url: s,
            data: o
        } = t;
        let a;
        if (e === "skip") {
            const d = ya.getInstance().token;
            if (d) {
                const [, y] = d.split("."), I = JSON.parse(new TextDecoder().decode(pp.decode(y)));
                mt.local().toUTC().toUnixInteger() > I.exp ? (a = await q0(e, r, n), ya.getInstance().setToken(a)) : a = d
            } else a = await q0(e, r, n), ya.getInstance().setToken(a)
        } else a = await q0(e, r, n);
        return (await yT.request({
            data: o,
            method: i,
            url: s,
            headers: {
                Authorization: `Bearer ${a}`
            }
        })).data
    },
    qg = ({
        children: t,
        title: e
    }) => vr("div", {
        className: " bg-black min-h-full",
        children: [qe("header", {
            className: "text-gray-600 body-font",
            children: vr("div", {
                className: "container mx-auto flex flex-wrap p-5 flex-col md:flex-row items-center",
                children: [qe("nav", {
                    className: "flex lg:w-2/5 flex-wrap items-center text-base md:ml-auto"
                }), qe("a", {
                    className: "flex order-first lg:order-none lg:w-1/5 title-font font-medium items-center text-gray-900 lg:items-center lg:justify-center mb-4 md:mb-0",
                    children: qe("span", {
                        className: "text-xl",
                        children: "Tap to Earn App"
                    })
                }), qe("div", {
                    className: "lg:w-2/5 inline-flex lg:justify-end lg:ml-0",
                    children: qe(VI, {})
                })]
            })
        }), qe("main", {
            className: "container mx-auto",
            children: t
        })]
    });
var wT = "/assets/alien.5494066e.jpg";
const xT = () => {
        const {
            publicKey: t
        } = Ol();
        return t ? qe(qg, {
            title: "Rewards",
            children: qe(bT, {
                publicKey: t
            })
        }) : qe(qg, {
            title: "Posts",
            children: qe("div", {
                className: "flex flex-col items-center justify-center text-xl",
                children: "Connect your wallet to authenticate"
            })
        })
    },
    bT = ({
        publicKey: t
    }) => {
        var a, c;
        const e = Ol(),
            r = GC(["reward", t.toBase58()], ({
                queryKey: d
            }) => {
                const [y, I] = d;
                return W0({
                    method: "POST",
                    url: `/${I}`
                }, "skip", {
                    publicKey: t,
                    signMessage: e.signMessage
                })
            }),
            n = lg(() => W0({
                method: "POST",
                url: "/",
                data: {
                    userAddress: t.toBase58()
                }
            }, "skip", {
                publicKey: t,
                signMessage: e.signMessage
            }), {
                onSuccess: () => {
                    r.refetch()
                }
            }),
            i = lg(() => W0({
                method: "DELETE",
                url: `/${t.toBase58()}`
            }, "posts:delete", {
                publicKey: t,
                signMessage: e.signMessage
            }), {
                onSuccess: () => {
                    r.refetch()
                }
            }),
            s = () => {
                n.mutate()
            },
            o = () => {
                i.mutate()
            };
        return qe("div", {
            children: vr("section", {
                className: "bg-clr well center",
                children: [qe("div", {
                    className: "square"
                }), vr("div", {
                    className: "container md-add",
                    children: [qe("h2", {
                        className: "clr1 fw-b text-white",
                        children: "Premine $ALIEN"
                    }), vr("div", {
                        className: "flex justify-center",
                        children: [" ", qe("hr", {
                            className: "hr__mod"
                        })]
                    }), qe("div", {
                        className: "flex justify-center",
                        children: qe("img", {
                            src: wT,
                            width: "202",
                            height: "209",
                            alt: ""
                        })
                    }), vr("div", {
                        className: "flex justify-center",
                        children: [" ", qe("hr", {
                            className: "hr__mod"
                        })]
                    })]
                }), vr("div", {
                    className: "container px-5 py-24 mx-auto",
                    children: [qe("div", {
                        className: "flex flex-col text-center w-full mb-12",
                        children: vr("h1", {
                            className: "sm:text-3xl text-2xl font-medium title-font mb-4 text-white",
                            children: ["Your Reward is ", ((c = (a = r.data) == null ? void 0 : a.xpAmount) != null ? c : 0).toString()]
                        })
                    }), qe("div", {
                        className: "lg:w-1/2 md:w-2/3 mx-auto",
                        children: vr("div", {
                            className: "p-2 w-full flex",
                            children: [qe("button", {
                                type: "button",
                                onClick: s,
                                className: "btn flex mx-auto text-white mt-[50px] bg-indigo-500 border-0 py-2 px-8 focus:outline-none hover:bg-indigo-600 rounded text-lg",
                                children: "Tap"
                            }), qe("button", {
                                type: "button",
                                onClick: o,
                                className: "btn flex mx-auto text-white bg-indigo-500 border-0 py-2 px-8 focus:outline-none hover:bg-indigo-600 rounded text-lg",
                                children: "Claim"
                            })]
                        })
                    })]
                })]
            })
        })
    },
    AT = new LC,
    ST = () => {
        const t = Xd.Mainnet,
            e = _e.exports.useMemo(() => fI(t), [t]),
            r = _e.exports.useMemo(() => [new NI, new BI, new LI, new UI({
                network: t
            }), new jI], [t]);
        return qe(HC, {
            client: AT,
            children: qe(yI, {
                endpoint: e,
                children: qe(EI, {
                    wallets: r,
                    autoConnect: !0,
                    children: qe(WI, {
                        children: qe(yC, {
                            children: qe(gC, {
                                children: qe(t3, {
                                    path: "/",
                                    element: qe(xT, {})
                                })
                            })
                        })
                    })
                })
            })
        })
    };
V0.createRoot(document.getElementById("root")).render(qe(Qe.StrictMode, {
    children: qe(ST, {})
}));
export {
    VA as E, bt as P, l1 as a, f1 as b, zn as c, IT as e, _a as i, Zb as r, pl as s, gS as v
};